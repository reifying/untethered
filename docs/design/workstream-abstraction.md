# Workstream Abstraction

## Overview

### Problem Statement

The current architecture conflates iOS front-end sessions with Claude Code sessions. When a user wants to start a recipe with fresh context (clean context window), they must create a new session, which:
1. Creates a new entry in the session list
2. Requires separate queue management
3. Fragments the user's logical unit of work across multiple UI entries

Users think in terms of "work I'm doing" (e.g., "implement feature X"), not "Claude conversations I'm having."

### Goals

1. Introduce a **Workstream** abstraction that represents a logical unit of work
2. Decouple workstream identity from Claude session identity
3. Enable context window clearing without creating new UI entries
4. Simplify queue management (queue manages workstreams, not Claude sessions)
5. Hide Claude sessions as an implementation detail

### Non-goals

- Showing conversation history across multiple Claude sessions within a workstream
- Exposing Claude sessions directly in the UI
- Changing the Claude CLI or `.jsonl` file format
- Changing the Claude Code session naming behavior

## Background & Context

### Current State

```
iOS Session (CDUserSession + CDBackendSession)
    â”œâ”€â”€ id: UUID (copied from Claude session)
    â”œâ”€â”€ name, working_directory, queue_priority
    â””â”€â”€ messages (from Claude session)

Claude Session (.jsonl file)
    â”œâ”€â”€ id: UUID (filename)
    â””â”€â”€ messages
```

- iOS session UUID = Claude session UUID (1:1 mapping)
- Session list shows Claude sessions
- Queue manages Claude sessions
- No way to "clear context" without creating a new session

### Why Now

Recipe orchestration sometimes needs fresh context windows. Users shouldn't have to manage multiple sessions for what they perceive as one piece of work.

### Related Work

- @recipe-new-session-support.md - Recipes starting on new sessions
- @STANDARDS.md - WebSocket protocol and session ID conventions

## Detailed Design

### Data Model

#### Workstream (New Concept)

```
Workstream
    â”œâ”€â”€ id: UUID (front-end generated, independent of Claude)
    â”œâ”€â”€ name: String (user-editable or auto-generated)
    â”œâ”€â”€ working_directory: String
    â”œâ”€â”€ queue_priority: high | normal | low
    â”œâ”€â”€ priority_order: Double (for ordering within priority level)
    â”œâ”€â”€ active_claude_session_id: UUID? (nullable)
    â”œâ”€â”€ created_at: Timestamp
    â””â”€â”€ last_modified: Timestamp
```

#### Claude Session (Unchanged internally, relationship changes)

```
Claude Session
    â”œâ”€â”€ id: UUID (from .jsonl filename)
    â”œâ”€â”€ workstream_id: UUID? (nullable - which workstream owns it)
    â”œâ”€â”€ name: String (auto-generated by Claude)
    â”œâ”€â”€ working_directory: String
    â”œâ”€â”€ messages: [Message]
    â””â”€â”€ last_modified: Timestamp
```

#### Relationships

- **Workstream â†’ Claude Session**: 0 or 1 (nullable `active_claude_session_id`)
- **Claude Session â†’ Workstream**: 0 or 1 (nullable `workstream_id`)

A workstream with no active Claude session is in a "cleared" state. Next prompt creates a new Claude session.

A Claude session with no workstream is orphaned (pre-migration or direct CLI usage).

### State Transitions

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                      Workstream                         â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚   Created   â”‚â”€â”€â”€â–¶â”‚   Active    â”‚â”€â”€â”€â–¶â”‚   Cleared   â”‚ â”‚
â”‚  â”‚ (no claude) â”‚    â”‚(has claude) â”‚    â”‚ (no claude) â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚        â”‚                  â–²                   â”‚         â”‚
â”‚        â”‚   first prompt   â”‚      clear        â”‚         â”‚
â”‚        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜         â”‚
â”‚                     next prompt                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### API Design

#### WebSocket Protocol Changes

**New Message: `create_workstream`**

Creates a new workstream. iOS generates the UUID.

```json
iOS â†’ Backend: {
  "type": "create_workstream",
  "workstream_id": "<workstream-uuid>",
  "name": "<optional-name>",
  "working_directory": "<path>"
}

Backend â†’ iOS: {
  "type": "workstream_created",
  "workstream_id": "<workstream-uuid>",
  "name": "<name>",
  "working_directory": "<path>",
  "created_at": "<ISO-8601>"
}
```

**Error Cases:**
- Missing `workstream_id`: `{type: "error", message: "workstream_id required"}`
- Missing `working_directory`: `{type: "error", message: "working_directory required"}`

**New Message: `clear_context`**

Clears the active Claude session from a workstream without affecting queue position.

```json
iOS â†’ Backend: {
  "type": "clear_context",
  "workstream_id": "<workstream-uuid>"
}

Backend â†’ iOS: {
  "type": "context_cleared",
  "workstream_id": "<workstream-uuid>",
  "previous_claude_session_id": "<claude-session-uuid>"
}
```

**Error Cases:**
- Missing `workstream_id`: `{type: "error", message: "workstream_id required"}`
- Workstream not found: `{type: "error", message: "Workstream not found: <id>"}`
- Workstream has no active session: `{type: "context_cleared", previous_claude_session_id: null}` (not an error)

**Modified Message: `prompt`**

Now uses `workstream_id` instead of `session_id`. The `new_session_id` and `resume_session_id` fields are deprecated.

```json
iOS â†’ Backend: {
  "type": "prompt",
  "text": "<prompt-text>",
  "workstream_id": "<workstream-uuid>",
  "working_directory": "<path>",
  "system_prompt": "<optional>"
}
```

Backend behavior:
1. Look up workstream by `workstream_id`
2. If workstream not found â†’ error
3. If workstream has active Claude session â†’ resume it (use `--resume`)
4. If workstream has no active Claude session â†’ create new Claude session (use `--session-id`), link to workstream

**Backward Compatibility:** During transition, backend accepts both:
- `workstream_id` (new)
- `new_session_id` / `resume_session_id` (deprecated, auto-creates workstream wrapper)

**New Message: `workstream_list`** (replaces `session_list`)

Sent after `connected` response.

```json
Backend â†’ iOS: {
  "type": "workstream_list",
  "workstreams": [
    {
      "workstream_id": "<workstream-uuid>",
      "name": "<workstream-name>",
      "working_directory": "<path>",
      "active_claude_session_id": "<claude-session-uuid>",
      "queue_priority": "normal",
      "priority_order": 1.5,
      "created_at": "<ISO-8601>",
      "last_modified": "<ISO-8601>",
      "message_count": 15,
      "preview": "Last message text..."
    }
  ]
}
```

**New Message: `workstream_updated`**

Sent when workstream metadata changes (name, active session, message count).

```json
Backend â†’ iOS: {
  "type": "workstream_updated",
  "workstream_id": "<workstream-uuid>",
  "active_claude_session_id": "<claude-session-uuid>",
  "last_modified": "<ISO-8601>",
  "message_count": 16,
  "preview": "New last message..."
}
```

**Modified Message: `start_recipe`**

Now uses `workstream_id`:

```json
iOS â†’ Backend: {
  "type": "start_recipe",
  "workstream_id": "<workstream-uuid>",
  "recipe_id": "implement-and-review",
  "working_directory": "<path>"
}
```

### Code Examples

#### Backend: Workstream State Management

New file: `backend/src/voice_code/workstream.clj`

```clojure
(ns voice-code.workstream
  "Workstream state management and persistence."
  (:require [clojure.java.io :as io]
            [clojure.edn :as edn]
            [clojure.tools.logging :as log]))

;; ============================================================================
;; Workstream Index
;; ============================================================================

(defonce workstream-index
  ;; workstream-id -> {:id "..."
  ;;                   :name "..."
  ;;                   :working-directory "..."
  ;;                   :active-claude-session-id "..." or nil
  ;;                   :queue-priority :normal
  ;;                   :priority-order 0.0
  ;;                   :created-at timestamp-ms
  ;;                   :last-modified timestamp-ms}
  (atom {}))

(defn get-workstream-index-path
  "Get path to workstream index file"
  []
  (let [home (System/getProperty "user.home")]
    (str home "/.voice-code/workstreams.edn")))

(defn save-workstream-index!
  "Persist workstream index to disk"
  []
  (try
    (let [index-path (get-workstream-index-path)
          index-file (io/file index-path)]
      (io/make-parents index-file)
      (spit index-file (pr-str @workstream-index))
      (log/debug "Workstream index saved" {:count (count @workstream-index)}))
    (catch Exception e
      (log/error e "Failed to save workstream index"))))

(defn load-workstream-index!
  "Load workstream index from disk"
  []
  (try
    (let [index-path (get-workstream-index-path)
          index-file (io/file index-path)]
      (when (.exists index-file)
        (let [data (edn/read-string (slurp index-file))]
          (reset! workstream-index data)
          (log/info "Workstream index loaded" {:count (count data)}))))
    (catch Exception e
      (log/error e "Failed to load workstream index"))))

;; ============================================================================
;; CRUD Operations
;; ============================================================================

(defn create-workstream!
  "Create a new workstream. Returns the created workstream."
  [{:keys [id name working-directory]}]
  (let [now (System/currentTimeMillis)
        workstream {:id id
                    :name (or name (str "New Workstream"))
                    :working-directory working-directory
                    :active-claude-session-id nil
                    :queue-priority :normal
                    :priority-order 0.0
                    :created-at now
                    :last-modified now}]
    (swap! workstream-index assoc id workstream)
    (save-workstream-index!)
    (log/info "Created workstream" {:id id :name name :working-directory working-directory})
    workstream))

(defn get-workstream
  "Get workstream by ID, or nil if not found"
  [workstream-id]
  (get @workstream-index workstream-id))

(defn get-all-workstreams
  "Get all workstreams as a vector"
  []
  (vec (vals @workstream-index)))

(defn update-workstream!
  "Update workstream fields. Returns updated workstream."
  [workstream-id updates]
  (when (get @workstream-index workstream-id)
    (let [updates-with-timestamp (assoc updates :last-modified (System/currentTimeMillis))
          updated (swap! workstream-index update workstream-id merge updates-with-timestamp)]
      (save-workstream-index!)
      (get updated workstream-id))))

(defn link-claude-session!
  "Link a Claude session to a workstream"
  [workstream-id claude-session-id]
  (update-workstream! workstream-id {:active-claude-session-id claude-session-id}))

(defn unlink-claude-session!
  "Unlink (clear) the active Claude session from a workstream.
   Returns the previous Claude session ID."
  [workstream-id]
  (let [previous-id (:active-claude-session-id (get-workstream workstream-id))]
    (update-workstream! workstream-id {:active-claude-session-id nil})
    previous-id))

(defn delete-workstream!
  "Delete a workstream"
  [workstream-id]
  (swap! workstream-index dissoc workstream-id)
  (save-workstream-index!)
  (log/info "Deleted workstream" {:id workstream-id}))
```

#### Backend: Message Handler Integration

In `server.clj`, add new message handlers:

```clojure
;; Timestamp formatting helper (add near other utility functions)
(defn format-timestamp
  "Format milliseconds timestamp as ISO-8601 string"
  [ms]
  (.format (java.time.format.DateTimeFormatter/ISO_INSTANT)
           (java.time.Instant/ofEpochMilli ms)))

(defn handle-create-workstream
  "Handle create_workstream message"
  [channel data]
  (let [workstream-id (:workstream-id data)
        name (:name data)
        working-directory (:working-directory data)]
    (cond
      (not workstream-id)
      (send-to-client! channel {:type :error :message "workstream_id required"})

      (not working-directory)
      (send-to-client! channel {:type :error :message "working_directory required"})

      :else
      (let [workstream (ws/create-workstream!
                        {:id workstream-id
                         :name name
                         :working-directory working-directory})]
        (send-to-client! channel
                         {:type :workstream-created
                          :workstream-id workstream-id
                          :name (:name workstream)
                          :working-directory working-directory
                          :created-at (format-timestamp (:created-at workstream))})))))

(defn handle-clear-context
  "Handle clear_context message"
  [channel data]
  (let [workstream-id (:workstream-id data)]
    (cond
      (not workstream-id)
      (send-to-client! channel {:type :error :message "workstream_id required"})

      (not (ws/get-workstream workstream-id))
      (send-to-client! channel {:type :error :message (str "Workstream not found: " workstream-id)})

      :else
      (let [previous-session-id (ws/unlink-claude-session! workstream-id)]
        (log/info "Cleared context for workstream"
                  {:workstream-id workstream-id
                   :previous-session-id previous-session-id})
        (send-to-client! channel
                         {:type :context-cleared
                          :workstream-id workstream-id
                          :previous-claude-session-id previous-session-id})))))

(defn handle-prompt-with-workstream
  "Handle prompt message using workstream abstraction"
  [channel data]
  (let [workstream-id (:workstream-id data)
        text (:text data)
        working-directory (:working-directory data)
        system-prompt (:system-prompt data)]
    (if-let [workstream (ws/get-workstream workstream-id)]
      (let [active-session-id (:active-claude-session-id workstream)
            ;; Determine if this is new or resume
            is-new-session? (nil? active-session-id)
            ;; For new sessions, generate a new Claude session ID
            claude-session-id (or active-session-id (str (java.util.UUID/randomUUID)))]

        ;; Acquire lock
        (if (repl/acquire-session-lock! claude-session-id)
          (do
            ;; If new session, link it to workstream now
            (when is-new-session?
              (ws/link-claude-session! workstream-id claude-session-id))

            ;; Invoke Claude
            (claude/invoke-claude-async
             text
             (fn [response]
               ;; ... response handling ...
               (repl/release-session-lock! claude-session-id))
             (if is-new-session? :new-session-id :resume-session-id) claude-session-id
             :working-directory (or working-directory (:working-directory workstream))
             :system-prompt system-prompt))

          ;; Session locked
          (send-session-locked! channel claude-session-id)))

      ;; Workstream not found
      (send-to-client! channel {:type :error :message (str "Workstream not found: " workstream-id)}))))

;; ============================================================================
;; Backward Compatibility: Legacy session_id prompts
;; ============================================================================

(defn get-or-create-workstream-for-session!
  "Get existing workstream for a Claude session, or create one if none exists.
   Used for backward compatibility with legacy session_id prompts."
  [claude-session-id working-directory]
  (let [session-meta (repl/get-session-metadata claude-session-id)]
    (if-let [workstream-id (:workstream-id session-meta)]
      ;; Session already has a workstream
      (ws/get-workstream workstream-id)
      ;; Create new workstream wrapper
      (let [ws-id (str (java.util.UUID/randomUUID))
            session-name (or (:name session-meta) "Migrated Session")
            workstream (ws/create-workstream!
                        {:id ws-id
                         :name session-name
                         :working-directory (or working-directory
                                                (:working-directory session-meta)
                                                (System/getProperty "user.dir"))})]
        ;; Link Claude session to workstream
        (ws/link-claude-session! ws-id claude-session-id)
        ;; Update session metadata with workstream reference
        (swap! repl/session-index assoc-in [claude-session-id :workstream-id] ws-id)
        (repl/save-index! @repl/session-index)
        (log/info "Created workstream wrapper for legacy session"
                  {:workstream-id ws-id :claude-session-id claude-session-id})
        workstream))))

(defn handle-prompt-legacy
  "Handle prompt message with legacy session_id fields.
   Auto-creates workstream wrapper for backward compatibility.

   Supports:
   - new-session-id: Create new Claude session (creates new workstream)
   - resume-session-id: Resume existing Claude session (finds/creates workstream)"
  [channel data]
  (let [new-session-id (:new-session-id data)
        resume-session-id (:resume-session-id data)
        text (:text data)
        working-directory (:working-directory data)
        system-prompt (:system-prompt data)]
    (cond
      ;; New session: create workstream + Claude session
      new-session-id
      (let [workstream (ws/create-workstream!
                        {:id (str (java.util.UUID/randomUUID))
                         :name "New Session"
                         :working-directory (or working-directory
                                                (System/getProperty "user.dir"))})]
        (ws/link-claude-session! (:id workstream) new-session-id)
        (log/info "Legacy new-session-id: created workstream wrapper"
                  {:workstream-id (:id workstream) :claude-session-id new-session-id})
        ;; Delegate to workstream handler
        (handle-prompt-with-workstream channel
                                       (assoc data :workstream-id (:id workstream))))

      ;; Resume session: find/create workstream, then delegate
      resume-session-id
      (let [workstream (get-or-create-workstream-for-session! resume-session-id working-directory)]
        (log/info "Legacy resume-session-id: using workstream"
                  {:workstream-id (:id workstream) :claude-session-id resume-session-id})
        (handle-prompt-with-workstream channel
                                       (assoc data :workstream-id (:id workstream))))

      ;; Neither field present - error
      :else
      (send-to-client! channel
                       {:type :error
                        :message "Either workstream_id, new_session_id, or resume_session_id required"}))))

(defn handle-prompt
  "Unified prompt handler supporting both workstream_id and legacy session_id fields.
   Prefers workstream_id if present, falls back to legacy handling."
  [channel data]
  (if (:workstream-id data)
    (handle-prompt-with-workstream channel data)
    (handle-prompt-legacy channel data)))
```

#### iOS: CDWorkstream Entity

New file: `ios/VoiceCode/Models/CDWorkstream.swift`

```swift
import Foundation
import CoreData

@objc(CDWorkstream)
public class CDWorkstream: NSManagedObject {
    @NSManaged public var id: UUID
    @NSManaged public var name: String
    @NSManaged public var workingDirectory: String
    @NSManaged public var activeClaudeSessionId: UUID?
    @NSManaged public var queuePriority: String      // "high", "normal", "low"
    @NSManaged public var priorityOrder: Double
    @NSManaged public var createdAt: Date
    @NSManaged public var lastModified: Date

    // Cached from active Claude session for display
    @NSManaged public var messageCount: Int32
    @NSManaged public var preview: String?
    @NSManaged public var unreadCount: Int32

    // Queue membership
    @NSManaged public var isInPriorityQueue: Bool
    @NSManaged public var priorityQueuedAt: Date?
}

// MARK: - Computed Properties
extension CDWorkstream {
    /// Whether workstream has an active Claude session
    var hasActiveSession: Bool {
        activeClaudeSessionId != nil
    }

    /// Whether workstream is in "cleared" state (no active session)
    var isCleared: Bool {
        activeClaudeSessionId == nil
    }
}

// MARK: - Fetch Requests
extension CDWorkstream {
    @nonobjc public class func fetchRequest() -> NSFetchRequest<CDWorkstream> {
        return NSFetchRequest<CDWorkstream>(entityName: "CDWorkstream")
    }

    /// Fetch all workstreams sorted by last modified
    static func fetchAllWorkstreams() -> NSFetchRequest<CDWorkstream> {
        let request = fetchRequest()
        request.sortDescriptors = [
            NSSortDescriptor(keyPath: \CDWorkstream.lastModified, ascending: false)
        ]
        return request
    }

    /// Fetch workstreams for a specific working directory
    static func fetchWorkstreams(workingDirectory: String) -> NSFetchRequest<CDWorkstream> {
        let request = fetchRequest()
        request.predicate = NSPredicate(format: "workingDirectory == %@", workingDirectory)
        request.sortDescriptors = [
            NSSortDescriptor(keyPath: \CDWorkstream.lastModified, ascending: false)
        ]
        return request
    }

    /// Fetch workstream by ID
    static func fetchWorkstream(id: UUID) -> NSFetchRequest<CDWorkstream> {
        let request = fetchRequest()
        request.predicate = NSPredicate(format: "id == %@", id as CVarArg)
        request.fetchLimit = 1
        return request
    }

    /// Fetch workstreams in priority queue, sorted by priority
    static func fetchQueuedWorkstreams() -> NSFetchRequest<CDWorkstream> {
        let request = fetchRequest()
        request.predicate = NSPredicate(format: "isInPriorityQueue == YES")
        request.sortDescriptors = [
            NSSortDescriptor(keyPath: \CDWorkstream.queuePriority, ascending: true),
            NSSortDescriptor(keyPath: \CDWorkstream.priorityOrder, ascending: true)
        ]
        return request
    }
}

extension CDWorkstream: Identifiable {}
```

#### iOS: CoreData Schema Changes

Update `VoiceCode.xcdatamodeld` to add the new `CDWorkstream` entity:

**New Entity: CDWorkstream**

| Attribute | Type | Optional | Default | Notes |
|-----------|------|----------|---------|-------|
| id | UUID | No | - | Primary key, unique constraint |
| name | String | No | - | Display name |
| workingDirectory | String | No | - | Project path |
| activeClaudeSessionId | UUID | Yes | nil | Currently linked Claude session |
| queuePriority | String | No | "normal" | "high", "normal", "low" |
| priorityOrder | Double | No | 0 | Ordering within priority level |
| createdAt | Date | No | - | Creation timestamp |
| lastModified | Date | No | - | Last update timestamp |
| messageCount | Integer 32 | No | 0 | Cached count from active session |
| preview | String | Yes | nil | Cached preview from active session |
| unreadCount | Integer 32 | No | 0 | Unread message count |
| isInPriorityQueue | Boolean | No | NO | Queue membership flag |
| priorityQueuedAt | Date | Yes | nil | When added to queue |

**Indexes:**
- Unique constraint on `id`
- Index on `workingDirectory` for directory-based filtering
- Index on `isInPriorityQueue`, `queuePriority`, `priorityOrder` for queue queries

**Migration Notes:**
- This is an additive schema change (new entity only)
- Use lightweight migration - no mapping model required
- Existing `CDBackendSession` entity unchanged; it continues to cache Claude session data
- `CDBackendSession` remains the source for `CDMessage` relationships

**Model Version:**
- Create new model version (e.g., `VoiceCode 3.xcdatamodel`)
- Set as current model version
- Ensure `NSMigratePersistentStoresAutomaticallyOption` and `NSInferMappingModelAutomaticallyOption` are enabled in `PersistenceController`

#### iOS: WorkstreamSyncManager

New file: `ios/VoiceCode/Managers/WorkstreamSyncManager.swift`

```swift
import Foundation
import CoreData
import os.log

private let logger = Logger(subsystem: "com.travisbrown.VoiceCode", category: "WorkstreamSync")

/// Manages synchronization of workstream metadata between backend and CoreData.
/// Replaces SessionSyncManager for workstream-based UI.
class WorkstreamSyncManager: ObservableObject {
    private let persistenceController: PersistenceController
    private let context: NSManagedObjectContext

    init(persistenceController: PersistenceController = .shared) {
        self.persistenceController = persistenceController
        self.context = persistenceController.container.viewContext
    }

    // MARK: - Workstream List Handling

    /// Handle workstream_list message from backend
    /// - Parameter workstreams: Array of workstream metadata dictionaries
    func handleWorkstreamList(_ workstreams: [[String: Any]]) async {
        logger.info("ğŸ“¥ Received workstream_list with \(workstreams.count) workstreams")

        await withCheckedContinuation { (continuation: CheckedContinuation<Void, Never>) in
            persistenceController.performBackgroundTask { [weak self] backgroundContext in
                guard let self = self else {
                    continuation.resume()
                    return
                }

                for data in workstreams {
                    guard let idString = data["workstream_id"] as? String,
                          let id = UUID(uuidString: idString) else {
                        logger.warning("âš ï¸ Skipping workstream with invalid ID")
                        continue
                    }
                    self.upsertWorkstream(id: id, data: data, in: backgroundContext)
                }

                do {
                    if backgroundContext.hasChanges {
                        try backgroundContext.save()
                        logger.info("âœ… Saved \(workstreams.count) workstreams to CoreData")

                        DispatchQueue.main.async {
                            NotificationCenter.default.post(name: .workstreamListDidUpdate, object: nil)
                        }
                    }
                } catch {
                    logger.error("âŒ Failed to save workstream_list: \(error.localizedDescription)")
                }

                continuation.resume()
            }
        }
    }

    // MARK: - Workstream Updated Handling

    /// Handle workstream_updated message from backend
    func handleWorkstreamUpdated(_ data: [String: Any]) async {
        guard let idString = data["workstream_id"] as? String,
              let id = UUID(uuidString: idString) else {
            logger.warning("âš ï¸ workstream_updated missing valid workstream_id")
            return
        }

        logger.info("ğŸ“¨ workstream_updated received: \(idString.prefix(8))...")

        await withCheckedContinuation { (continuation: CheckedContinuation<Void, Never>) in
            persistenceController.performBackgroundTask { [weak self] backgroundContext in
                guard let self = self else {
                    continuation.resume()
                    return
                }

                self.upsertWorkstream(id: id, data: data, in: backgroundContext)

                do {
                    if backgroundContext.hasChanges {
                        try backgroundContext.save()
                        logger.info("âœ… Updated workstream: \(idString.prefix(8))...")
                    }
                } catch {
                    logger.error("âŒ Failed to save workstream_updated: \(error.localizedDescription)")
                }

                continuation.resume()
            }
        }
    }

    // MARK: - Context Cleared Handling

    /// Handle context_cleared message - clears active session and associated messages
    func handleContextCleared(workstreamId: UUID, previousClaudeSessionId: UUID?) async {
        logger.info("ğŸ§¹ context_cleared for workstream: \(workstreamId.uuidString.prefix(8))...")

        await withCheckedContinuation { (continuation: CheckedContinuation<Void, Never>) in
            persistenceController.performBackgroundTask { [weak self] backgroundContext in
                guard self != nil else {
                    continuation.resume()
                    return
                }

                // Update workstream
                let workstreamRequest = CDWorkstream.fetchWorkstream(id: workstreamId)
                if let workstream = try? backgroundContext.fetch(workstreamRequest).first {
                    workstream.activeClaudeSessionId = nil
                    workstream.messageCount = 0
                    workstream.preview = nil
                    logger.info("âœ… Cleared workstream active session")
                }

                // Delete messages associated with the previous Claude session
                if let previousSessionId = previousClaudeSessionId {
                    let messageRequest: NSFetchRequest<NSFetchRequestResult> = CDMessage.fetchRequest()
                    messageRequest.predicate = NSPredicate(format: "sessionId == %@", previousSessionId as CVarArg)
                    let deleteRequest = NSBatchDeleteRequest(fetchRequest: messageRequest)

                    do {
                        try backgroundContext.execute(deleteRequest)
                        logger.info("âœ… Deleted messages for cleared session: \(previousSessionId.uuidString.prefix(8))...")
                    } catch {
                        logger.error("âŒ Failed to delete messages: \(error.localizedDescription)")
                    }
                }

                do {
                    if backgroundContext.hasChanges {
                        try backgroundContext.save()
                    }
                } catch {
                    logger.error("âŒ Failed to save context_cleared: \(error.localizedDescription)")
                }

                continuation.resume()
            }
        }
    }

    // MARK: - Private Helpers

    private func upsertWorkstream(id: UUID, data: [String: Any], in context: NSManagedObjectContext) {
        let request = CDWorkstream.fetchWorkstream(id: id)
        let workstream: CDWorkstream

        if let existing = try? context.fetch(request).first {
            workstream = existing
        } else {
            workstream = CDWorkstream(context: context)
            workstream.id = id
            workstream.createdAt = Date()
            workstream.isInPriorityQueue = false
        }

        if let name = data["name"] as? String {
            workstream.name = name
        }
        if let workingDirectory = data["working_directory"] as? String {
            workstream.workingDirectory = workingDirectory
        }
        if let activeSessionIdString = data["active_claude_session_id"] as? String {
            workstream.activeClaudeSessionId = UUID(uuidString: activeSessionIdString)
        } else if data["active_claude_session_id"] == nil || data["active_claude_session_id"] is NSNull {
            workstream.activeClaudeSessionId = nil
        }
        if let priority = data["queue_priority"] as? String {
            workstream.queuePriority = priority
        }
        if let priorityOrder = data["priority_order"] as? Double {
            workstream.priorityOrder = priorityOrder
        }
        if let messageCount = data["message_count"] as? Int {
            workstream.messageCount = Int32(messageCount)
        }
        if let preview = data["preview"] as? String {
            workstream.preview = preview
        }
        if let lastModifiedString = data["last_modified"] as? String {
            let formatter = ISO8601DateFormatter()
            if let date = formatter.date(from: lastModifiedString) {
                workstream.lastModified = date
            }
        }
    }

    /// Create a new workstream locally (before sending to backend)
    func createWorkstream(workingDirectory: String, name: String? = nil) -> CDWorkstream {
        let workstream = CDWorkstream(context: context)
        workstream.id = UUID()
        workstream.name = name ?? "New Workstream"
        workstream.workingDirectory = workingDirectory
        workstream.queuePriority = "normal"
        workstream.priorityOrder = 0
        workstream.createdAt = Date()
        workstream.lastModified = Date()
        workstream.messageCount = 0
        workstream.isInPriorityQueue = false

        try? context.save()
        logger.info("âœ… Created local workstream: \(workstream.id.uuidString.prefix(8))...")
        return workstream
    }
}

// MARK: - Notification Names

extension Notification.Name {
    /// Posted when workstream list is updated from backend
    static let workstreamListDidUpdate = Notification.Name("workstreamListDidUpdate")

    // Note: .sessionListDidUpdate is deprecated and will be removed
    // once all UI components migrate to workstream-based views
}
```

#### iOS: VoiceCodeClient Updates

Add to `VoiceCodeClient.swift`:

```swift
// Add property for workstream sync manager
let workstreamSyncManager: WorkstreamSyncManager

// In init(), add:
self.workstreamSyncManager = WorkstreamSyncManager(persistenceController: .shared)

// New message types in handleMessage(_:) - note async calls wrapped in Task
case "workstream_list":
    if let workstreams = message["workstreams"] as? [[String: Any]] {
        Task {
            await workstreamSyncManager.handleWorkstreamList(workstreams)
        }
    }

case "workstream_created":
    // Backend confirms creation
    if let data = message as? [String: Any] {
        Task {
            await workstreamSyncManager.handleWorkstreamUpdated(data)
        }
    }

case "workstream_updated":
    if let data = message as? [String: Any] {
        Task {
            await workstreamSyncManager.handleWorkstreamUpdated(data)
        }
    }

case "context_cleared":
    if let idString = message["workstream_id"] as? String,
       let id = UUID(uuidString: idString) {
        let previousSessionId: UUID?
        if let prevIdString = message["previous_claude_session_id"] as? String {
            previousSessionId = UUID(uuidString: prevIdString)
        } else {
            previousSessionId = nil
        }
        Task {
            await workstreamSyncManager.handleContextCleared(
                workstreamId: id,
                previousClaudeSessionId: previousSessionId
            )
        }
    }

// New methods for sending workstream messages
func createWorkstream(id: UUID, name: String?, workingDirectory: String) {
    var message: [String: Any] = [
        "type": "create_workstream",
        "workstream_id": id.uuidString.lowercased(),
        "working_directory": workingDirectory
    ]
    if let name = name {
        message["name"] = name
    }
    send(message)
}

func clearContext(workstreamId: UUID) {
    let message: [String: Any] = [
        "type": "clear_context",
        "workstream_id": workstreamId.uuidString.lowercased()
    ]
    send(message)
}

func sendPrompt(text: String, workstreamId: UUID, workingDirectory: String? = nil, systemPrompt: String? = nil) {
    var message: [String: Any] = [
        "type": "prompt",
        "text": text,
        "workstream_id": workstreamId.uuidString.lowercased()
    ]
    if let dir = workingDirectory {
        message["working_directory"] = dir
    }
    if let systemPrompt = systemPrompt, !systemPrompt.trimmingCharacters(in: .whitespaces).isEmpty {
        message["system_prompt"] = systemPrompt
    }
    send(message)
}
```

### Component Interactions

#### Sequence: New Workstream with First Prompt

```
iOS                         Backend                      Claude CLI
 |                             |                             |
 |--create_workstream--------->|                             |
 |  workstream_id: ws-123      |                             |
 |  working_directory: /proj   |                             |
 |                             |                             |
 |                             |--create workstream          |
 |                             |  active_claude_session: nil |
 |                             |                             |
 |<--workstream_created--------|                             |
 |                             |                             |
 |--prompt-------------------->|                             |
 |  workstream_id: ws-123      |                             |
 |  text: "Hello"              |                             |
 |                             |                             |
 |                             |--lookup ws-123              |
 |                             |  active_session: nil        |
 |                             |                             |
 |                             |--generate cs-uuid           |
 |                             |--link cs-uuid to ws-123     |
 |                             |                             |
 |                             |--invoke-claude-async------->|
 |                             |  --session-id cs-uuid       |
 |                             |                             |
 |                             |<--response------------------|
 |                             |                             |
 |<--workstream_updated--------|                             |
 |  active_claude_session_id:  |                             |
 |    cs-uuid                  |                             |
 |  message_count: 2           |                             |
```

#### Sequence: Clear Context and New Prompt

```
iOS                         Backend                      Claude CLI
 |                             |                             |
 |--clear_context------------->|                             |
 |  workstream_id: ws-123      |                             |
 |                             |                             |
 |                             |--unlink cs-old from ws-123  |
 |                             |                             |
 |<--context_cleared-----------|                             |
 |  previous_session: cs-old   |                             |
 |                             |                             |
 |  (UI clears messages,       |                             |
 |   keeps workstream)         |                             |
 |                             |                             |
 |--prompt-------------------->|                             |
 |  workstream_id: ws-123      |                             |
 |  text: "Start fresh"        |                             |
 |                             |                             |
 |                             |--lookup ws-123              |
 |                             |  active_session: nil        |
 |                             |                             |
 |                             |--generate cs-new            |
 |                             |--link cs-new to ws-123      |
 |                             |                             |
 |                             |--invoke-claude-async------->|
 |                             |  --session-id cs-new        |
 |                             |                             |
```

### Migration Strategy

#### Backend Migration

1. **On startup**, after loading `session-index`:
   - Load existing `workstream-index` if present
   - For each Claude session without a `workstream-id`:
     - Create a new workstream with:
       - `id` = new UUID (not copying Claude session ID)
       - `name` = Claude session name
       - `working-directory` = Claude session working directory
       - `active-claude-session-id` = Claude session ID
     - Update Claude session metadata with `workstream-id`
   - Save both indices

```clojure
(defn migrate-sessions-to-workstreams!
  "Create workstream wrappers for orphaned Claude sessions"
  []
  (let [sessions (repl/get-all-sessions)
        orphaned (filter #(nil? (:workstream-id %)) sessions)]
    (doseq [session orphaned]
      (let [ws-id (str (java.util.UUID/randomUUID))
            workstream {:id ws-id
                        :name (:name session)
                        :working-directory (:working-directory session)
                        :active-claude-session-id (:session-id session)
                        :queue-priority :normal
                        :priority-order 0.0
                        :created-at (:created-at session)
                        :last-modified (:last-modified session)}]
        ;; Add workstream
        (swap! workstream-index assoc ws-id workstream)
        ;; Link session to workstream
        (swap! repl/session-index assoc-in [(:session-id session) :workstream-id] ws-id)))
    (save-workstream-index!)
    (repl/save-index! @repl/session-index)
    (log/info "Migrated sessions to workstreams" {:count (count orphaned)})))
```

#### iOS Migration

1. **On first launch after upgrade**:
   - Backend sends `workstream_list` (migrated workstreams)
   - iOS stores in `CDWorkstream` entities
   - Existing `CDBackendSession` entities remain as cache

2. **CoreData model version**:
   - Add new `CDWorkstream` entity
   - No changes to `CDBackendSession` (it becomes internal cache)
   - Lightweight migration handles schema update

### Recipe Integration

Recipes can request fresh context by calling `clear_context` internally:

```clojure
(defn execute-recipe-step-with-fresh-context
  "Execute recipe step after clearing context for clean context window"
  [channel workstream-id working-dir orch-state recipe]
  ;; Clear existing context
  (let [previous-session (ws/unlink-claude-session! workstream-id)]
    (log/info "Cleared context for fresh recipe step"
              {:workstream-id workstream-id
               :previous-session previous-session})
    ;; Notify client
    (send-to-client! channel
                     {:type :context-cleared
                      :workstream-id workstream-id
                      :previous-claude-session-id previous-session})
    ;; Next prompt will create new Claude session
    (execute-recipe-step channel workstream-id working-dir orch-state recipe)))
```

## Verification Strategy

### Unit Tests

#### Backend Tests

```clojure
(ns voice-code.workstream-test
  (:require [clojure.test :refer :all]
            [voice-code.workstream :as ws]))

(deftest create-workstream-test
  (testing "creates workstream with correct fields"
    (reset! ws/workstream-index {})
    (let [result (ws/create-workstream!
                  {:id "test-id"
                   :name "Test Workstream"
                   :working-directory "/test/path"})]
      (is (= "test-id" (:id result)))
      (is (= "Test Workstream" (:name result)))
      (is (= "/test/path" (:working-directory result)))
      (is (nil? (:active-claude-session-id result)))
      (is (= :normal (:queue-priority result)))))

  (testing "defaults name when not provided"
    (reset! ws/workstream-index {})
    (let [result (ws/create-workstream!
                  {:id "test-id-2"
                   :working-directory "/test"})]
      (is (= "New Workstream" (:name result))))))

(deftest link-unlink-claude-session-test
  (testing "links and unlinks Claude session"
    (reset! ws/workstream-index {})
    (ws/create-workstream! {:id "ws-1" :working-directory "/test"})

    ;; Link
    (ws/link-claude-session! "ws-1" "claude-123")
    (is (= "claude-123" (:active-claude-session-id (ws/get-workstream "ws-1"))))

    ;; Unlink
    (let [previous (ws/unlink-claude-session! "ws-1")]
      (is (= "claude-123" previous))
      (is (nil? (:active-claude-session-id (ws/get-workstream "ws-1")))))))

(deftest clear-context-returns-previous-session-test
  (testing "clear returns nil when no active session"
    (reset! ws/workstream-index {})
    (ws/create-workstream! {:id "ws-1" :working-directory "/test"})
    (is (nil? (ws/unlink-claude-session! "ws-1")))))
```

#### iOS Tests

```swift
import XCTest
@testable import VoiceCode

class WorkstreamTests: XCTestCase {
    var persistenceController: PersistenceController!
    var manager: WorkstreamSyncManager!

    override func setUp() {
        persistenceController = PersistenceController.preview
        manager = WorkstreamSyncManager(persistenceController: persistenceController)
    }

    func testCreateWorkstream() {
        let workstream = manager.createWorkstream(
            workingDirectory: "/test/path",
            name: "Test Workstream"
        )

        XCTAssertNotNil(workstream.id)
        XCTAssertEqual(workstream.name, "Test Workstream")
        XCTAssertEqual(workstream.workingDirectory, "/test/path")
        XCTAssertNil(workstream.activeClaudeSessionId)
        XCTAssertTrue(workstream.isCleared)
    }

    func testHandleContextCleared() async {
        // Create workstream with active session
        let previousSessionId = UUID()
        let workstream = manager.createWorkstream(workingDirectory: "/test")
        workstream.activeClaudeSessionId = previousSessionId
        workstream.messageCount = 10
        try? persistenceController.container.viewContext.save()

        // Handle clear (async method)
        await manager.handleContextCleared(
            workstreamId: workstream.id,
            previousClaudeSessionId: previousSessionId
        )

        // Verify - need to refetch since background context was used
        let context = persistenceController.container.viewContext
        context.refreshAllObjects()

        let request = CDWorkstream.fetchWorkstream(id: workstream.id)
        let refreshedWorkstream = try? context.fetch(request).first

        XCTAssertNotNil(refreshedWorkstream)
        XCTAssertNil(refreshedWorkstream?.activeClaudeSessionId)
        XCTAssertEqual(refreshedWorkstream?.messageCount, 0)
    }

    func testHandleContextClearedWithNilPreviousSession() async {
        // Create workstream with no active session
        let workstream = manager.createWorkstream(workingDirectory: "/test")
        workstream.messageCount = 5
        try? persistenceController.container.viewContext.save()

        // Handle clear with nil previous session (edge case)
        await manager.handleContextCleared(
            workstreamId: workstream.id,
            previousClaudeSessionId: nil
        )

        // Verify
        let context = persistenceController.container.viewContext
        context.refreshAllObjects()

        let request = CDWorkstream.fetchWorkstream(id: workstream.id)
        let refreshedWorkstream = try? context.fetch(request).first

        XCTAssertNotNil(refreshedWorkstream)
        XCTAssertNil(refreshedWorkstream?.activeClaudeSessionId)
        XCTAssertEqual(refreshedWorkstream?.messageCount, 0)
    }
}
```

### Integration Tests

#### Test 1: Full Workstream Lifecycle

**Setup:**
1. Start backend server
2. Connect iOS client via WebSocket
3. Wait for `connected` response

**Steps:**
```
1. Send create_workstream:
   {"type": "create_workstream", "workstream_id": "ws-test-1", "working_directory": "/tmp/test"}

2. Verify workstream_created received:
   - Assert response.workstream_id == "ws-test-1"
   - Assert response.active_claude_session_id == null

3. Send first prompt:
   {"type": "prompt", "workstream_id": "ws-test-1", "text": "Hello"}

4. Capture Claude session ID from response:
   - Store response.session_id as first_claude_session

5. Send clear_context:
   {"type": "clear_context", "workstream_id": "ws-test-1"}

6. Verify context_cleared received:
   - Assert response.workstream_id == "ws-test-1"
   - Assert response.previous_claude_session_id == first_claude_session

7. Send second prompt:
   {"type": "prompt", "workstream_id": "ws-test-1", "text": "Fresh start"}

8. Verify new Claude session:
   - Store response.session_id as second_claude_session
   - Assert second_claude_session != first_claude_session

9. Verify workstream unchanged:
   - Get workstream from workstream_list
   - Assert workstream.workstream_id == "ws-test-1" (unchanged)
   - Assert workstream.active_claude_session_id == second_claude_session
```

**Assertions:**
- Workstream ID constant throughout: "ws-test-1"
- Two distinct Claude session IDs created
- Messages only from second Claude session visible

#### Test 2: Migration of Existing Sessions

**Setup:**
1. Create legacy session directly (simulate pre-migration state):
   - Create .jsonl file at `~/.claude/projects/test/<uuid>.jsonl`
   - Add to session-index without workstream-id field
2. Start backend server (triggers migration)

**Steps:**
```
1. Connect iOS client

2. Verify workstream_list contains migrated session:
   - Find workstream where active_claude_session_id == legacy_session_uuid
   - Assert workstream.name == legacy session name
   - Assert workstream.working_directory == legacy working directory

3. Send prompt using legacy resume_session_id:
   {"type": "prompt", "resume_session_id": "<legacy_uuid>", "text": "Test"}

4. Verify auto-created workstream:
   - Response should succeed (no error)
   - Subsequent workstream_list should show workstream linked to legacy session
```

**Assertions:**
- Migration creates workstream for each orphaned Claude session
- Legacy session_id prompts work via auto-created workstream
- Workstream inherits name and working_directory from Claude session

#### Test 3: Recipe with Fresh Context

**Setup:**
1. Create workstream with active Claude session
2. Start recipe that requires fresh context (mock recipe with `:fresh-context true` step)

**Steps:**
```
1. Create workstream and send initial prompt:
   - Store initial claude_session_id

2. Start recipe:
   {"type": "start_recipe", "workstream_id": "ws-test", "recipe_id": "test-fresh-context"}

3. Mock recipe step triggers clear internally

4. Verify context_cleared sent:
   - Assert previous_claude_session_id == initial session

5. Verify recipe continues on new session:
   - Recipe step executes successfully
   - New claude_session_id != initial session
   - Workstream ID unchanged

6. Verify recipe completion:
   - recipe_exited received with success reason
   - Workstream.active_claude_session_id == new session
```

**Assertions:**
- Recipe can clear context mid-execution
- Workstream identity preserved through clear
- New Claude session created for fresh context
- Recipe completion unaffected by session change

#### Test 4: Backward Compatibility

**Setup:**
1. Start backend with workstream support enabled

**Steps:**
```
1. Send legacy new_session_id prompt:
   {"type": "prompt", "new_session_id": "legacy-new-uuid", "text": "Hello", "working_directory": "/tmp"}

2. Verify workstream auto-created:
   - Check workstream_list for new workstream
   - Workstream.active_claude_session_id == "legacy-new-uuid"

3. Send legacy resume_session_id prompt:
   {"type": "prompt", "resume_session_id": "legacy-new-uuid", "text": "Continue"}

4. Verify same workstream used:
   - Response succeeds
   - No new workstream created (count unchanged)

5. Send workstream_id prompt to same workstream:
   {"type": "prompt", "workstream_id": "<auto-created-ws-id>", "text": "Modern"}

6. Verify interoperability:
   - Same Claude session resumed
   - Response succeeds
```

**Assertions:**
- Legacy new_session_id creates workstream automatically
- Legacy resume_session_id finds existing workstream
- Can switch between legacy and workstream_id prompts
- No duplicate workstreams created

### Acceptance Criteria

1. User sees workstreams in session list, not Claude sessions
2. Clearing context keeps user in same workstream
3. Queue position preserved after clear
4. Workstream name persists through clears
5. Migration creates workstream wrappers for existing sessions
6. Recipes can request fresh context without UI disruption
7. Messages display from active Claude session only
8. Backward compatibility: legacy `session_id` prompts still work

## Alternatives Considered

### Alternative 1: Multiple Claude Sessions Per Workstream (Visible History)

**Approach**: Show combined history from all Claude sessions in a workstream.

**Pros**:
- User can see full work history
- No data "lost" after clear

**Cons**:
- Complex message aggregation logic
- Confusing when context resets but messages remain
- Performance concerns with large histories

**Decision**: Rejected. User only needs current context; archived sessions are implementation detail.

### Alternative 2: Workstream as Tag on Claude Sessions

**Approach**: Add `workstream_tag` field to Claude sessions, filter UI by tag.

**Pros**:
- Simpler data model
- No new entity needed

**Cons**:
- Doesn't solve queue management (queue still per-session)
- Doesn't enable clear operation
- Confusing relationship model

**Decision**: Rejected. Doesn't address core problem.

### Alternative 3: Client-Side Only Abstraction

**Approach**: iOS manages workstreamâ†’session mapping locally, backend unchanged.

**Pros**:
- No backend changes
- Faster to implement

**Cons**:
- State lost on app reinstall
- No cross-device sync
- Queue management still server-side, can't use workstreams

**Decision**: Rejected. Server needs to understand workstreams for queue management.

## Risks & Mitigations

### Risk 1: Migration Data Loss

**Risk**: Migration fails and loses session references.

**Mitigation**: Migration is additive (creates new workstream records). Original Claude sessions unchanged. Can rebuild workstream index from session files by scanning for orphaned sessions.

### Risk 2: Orphaned Claude Sessions Accumulate

**Risk**: Cleared sessions pile up in filesystem (~/.claude/projects/).

**Mitigation**:
- Initial: Not blocking for MVP; Claude CLI manages its own cleanup
- Future: Add retention policy (delete sessions unlinked for >30 days)

### Risk 3: Backward Compatibility

**Risk**: Old iOS app connects to new backend (or vice versa).

**Mitigation**:
- Backend accepts both `session_id` and `workstream_id` during transition
- Legacy `session_id` prompts auto-create workstream wrapper
- Version field in hello message enables feature detection

### Risk 4: State Inconsistency

**Risk**: Workstream index and session index get out of sync.

**Mitigation**:
- Atomic updates using swap!
- Rebuild capability from Claude session files
- Validation on startup that verifies linkages

### Rollback Strategy

1. Revert iOS to use `session_id` instead of `workstream_id`
2. Backend continues accepting both (no change needed)
3. Workstream data becomes orphaned but harmless
4. Users see Claude sessions directly again
5. No data loss - Claude sessions were never modified
