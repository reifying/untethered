{"id":"voice-code-message-too-long-hfn","content_hash":"8d917e4bff5fcc1959d302ec7ac539e1ee01e7496bcdda2aa9e10517a8fd4bbb","title":"Delta Sync Session History","description":"## Design Document\n@docs/design/delta-sync-session-history.md\n\n## Overview\nImplement delta sync for session history to eliminate redundant message transfer and improve truncation behavior. When iOS subscribes to a session, it sends the UUID of its newest cached message. The backend only sends messages newer than that ID, using smart per-message truncation (20KB max) instead of dividing budget equally among all messages.\n\n## Acceptance Criteria\n1. Subscribe with `last_message_id` returns only newer messages\n2. Subscribe without `last_message_id` returns recent messages (backward compatible)\n3. Messages under 20KB are never truncated\n4. Messages over 20KB are truncated with marker showing size\n5. Response never exceeds client's max message size setting\n6. Newest messages are prioritized when budget is exhausted\n7. `is_complete: false` indicates budget exhaustion\n8. iOS displays truncated content with appropriate indicator\n9. All existing tests continue to pass","status":"closed","priority":2,"issue_type":"epic","created_at":"2025-12-31T17:07:49.744716-06:00","updated_at":"2025-12-31T17:45:32.350309-06:00","closed_at":"2025-12-31T17:45:32.350309-06:00","source_repo":"."}
{"id":"voice-code-message-too-long-hfn.2","content_hash":"a21eebf96f8de0c796c2a21375dd30ba7d66a43bbe708d88c759dc984c6277a6","title":"Implement build-session-history-response function","description":"## Design Reference\n@docs/design/delta-sync-session-history.md#backend-new-truncation-algorithm\n\n## Context\nThis is the core algorithm for delta sync. It replaces the current equal-budget truncation with smart per-message truncation that prioritizes recent messages and preserves small messages intact.\n\n## Requirements\n- [ ] Create `per-message-max-bytes` constant (20KB)\n- [ ] Implement `build-session-history-response` function with delta sync logic\n- [ ] Find messages newer than `last-message-id` (or all if not provided)\n- [ ] Work backwards from newest message, adding until budget exhausted\n- [ ] Truncate only messages exceeding per-message-max (20KB)\n- [ ] Return `is-complete`, `oldest-message-id`, `newest-message-id`\n\n## Technical Approach\n- File to modify: `backend/src/voice_code/server.clj`\n- Algorithm:\n  1. Find index of last-message-id in message list\n  2. Get messages newer than that index (or all if not found)\n  3. Reverse to process newest first\n  4. Loop: truncate large messages, add to result until budget exhausted\n  5. Reverse back to chronological order\n  6. Return with metadata fields\n\n## Verification\n- [ ] Unit test: Empty message list returns empty result with nil IDs\n- [ ] Unit test: All messages fit in budget ‚Üí is-complete true\n- [ ] Unit test: Budget exhausted mid-way ‚Üí is-complete false, newest prioritized\n- [ ] Unit test: last-message-id found ‚Üí only newer messages returned\n- [ ] Unit test: last-message-id not found ‚Üí all recent messages returned\n- [ ] Unit test: Large messages (\u003e20KB) truncated with marker\n- [ ] Unit test: Small messages (\u003c20KB) preserved intact\n\n## Acceptance Criteria\n- Messages under 20KB are never truncated\n- Messages over 20KB are truncated with marker showing size\n- Newest messages are prioritized when budget is exhausted","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-31T17:08:42.505319-06:00","updated_at":"2025-12-31T20:09:36.291425-06:00","closed_at":"2025-12-31T20:09:36.291425-06:00","source_repo":"."}
{"id":"voice-code-message-too-long-hfn.3","content_hash":"db62b66a87f3f69e8bcdc609e2ddc0765366977d4e8f55730480b02c1c082b2c","title":"Update subscribe handler to use delta sync algorithm","description":"## Design Reference\n@docs/design/delta-sync-session-history.md#backend-updated-subscribe-handler\n\n## Context\nThe subscribe handler must be updated to parse the new `last_message_id` field, call the new `build-session-history-response` function, and return the new response fields.\n\n## Requirements\n- [ ] Parse optional `last-message-id` from subscribe message\n- [ ] Pass `last-message-id` to `build-session-history-response`\n- [ ] Include `oldest-message-id`, `newest-message-id`, `is-complete` in response\n- [ ] Log delta sync usage for debugging\n- [ ] Handle backward compatibility (missing `last-message-id` = full history)\n\n## Technical Approach\n- File to modify: `backend/src/voice_code/server.clj`\n- In the \"subscribe\" case of message handler:\n  1. Extract `last-message-id` from data map\n  2. Call `build-session-history-response` with filtered messages, last-message-id, and max-bytes\n  3. Destructure result to get messages, is-complete, oldest-message-id, newest-message-id\n  4. Include all fields in `session-history` response\n\n## Dependencies\n- Requires: \"Implement build-session-history-response function\"\n\n## Verification\n- [ ] Integration test: Subscribe without last_message_id returns recent messages\n- [ ] Integration test: Subscribe with valid last_message_id returns only newer\n- [ ] Integration test: Subscribe with stale/unknown last_message_id returns recent messages\n- [ ] Integration test: Response includes is_complete, oldest_message_id, newest_message_id\n- [ ] All existing subscribe tests continue to pass\n\n## Acceptance Criteria\n- Subscribe with `last_message_id` returns only newer messages\n- Subscribe without `last_message_id` returns recent messages (backward compatible)\n- All existing tests continue to pass","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-31T17:09:05.07216-06:00","updated_at":"2025-12-31T23:07:34.648982-06:00","closed_at":"2025-12-31T23:07:34.648982-06:00","source_repo":".","dependencies":[{"issue_id":"voice-code-message-too-long-hfn.3","depends_on_id":"voice-code-message-too-long-hfn.2","type":"blocks","created_at":"2025-12-31T17:09:10.946434-06:00","created_by":"travisbrown"}]}
{"id":"voice-code-message-too-long-hfn.4","content_hash":"a922c37a930becb406a929802d1d8abe3947ef8c1028be51a4db0407396d52bd","title":"Implement iOS getNewestCachedMessageId function","description":"## Design Reference\n@docs/design/delta-sync-session-history.md#ios-updated-subscribe-call\n\n## Context\niOS needs a function to query CoreData for the newest message UUID for a given session. This UUID will be sent to the backend as `last_message_id` to enable delta sync.\n\n## Requirements\n- [ ] Create `getNewestCachedMessageId(sessionId:)` function in VoiceCodeClient\n- [ ] Query CDMessage sorted by timestamp descending, limit 1\n- [ ] Return the message's UUID as lowercase string (per STANDARDS.md)\n- [ ] Return nil on error or if no messages exist\n- [ ] Log errors for debugging\n\n## Technical Approach\n- File to modify: `ios/VoiceCode/Managers/VoiceCodeClient.swift`\n- Implementation:\n  1. Parse sessionId string to UUID\n  2. Create NSFetchRequest for CDMessage\n  3. Set predicate: sessionId == uuid\n  4. Set sort: timestamp descending\n  5. Set fetchLimit: 1\n  6. Execute fetch on PersistenceController.shared.container.viewContext\n  7. Return first result's id.uuidString.lowercased()\n\n## Parallelization\nCan be worked alongside: \"Update subscribe handler to use delta sync algorithm\"\n\n## Verification\n- [ ] Manual test: Function returns correct UUID for session with messages\n- [ ] Manual test: Function returns nil for session with no messages\n- [ ] Manual test: Function returns nil for invalid session ID\n- [ ] Verify UUID is lowercase\n\n## Acceptance Criteria\n- iOS can retrieve the newest cached message ID for any session","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-31T17:09:31.941192-06:00","updated_at":"2025-12-31T23:36:49.264849-06:00","closed_at":"2025-12-31T23:36:49.264849-06:00","source_repo":"."}
{"id":"voice-code-message-too-long-hfn.5","content_hash":"95bb7f5d225b3673b0459c7d5d3c0d11c230c351598bfcd8c97d989c51bda62a","title":"Update iOS subscribe to send last_message_id","description":"## Design Reference\n@docs/design/delta-sync-session-history.md#ios-updated-subscribe-call\n\n## Context\nThe iOS subscribe call must be updated to include `last_message_id` when subscribing to a session. This enables delta sync, reducing redundant data transfer.\n\n## Requirements\n- [ ] Update `subscribe(sessionId:)` to call `getNewestCachedMessageId`\n- [ ] Include `last_message_id` in subscribe message if available\n- [ ] Log whether delta sync is being used\n- [ ] Maintain backward compatibility (message still valid without last_message_id)\n\n## Technical Approach\n- File to modify: `ios/VoiceCode/Managers/VoiceCodeClient.swift`\n- In `subscribe(sessionId:)`:\n  1. Call getNewestCachedMessageId(sessionId:)\n  2. Build message dictionary with type and session_id\n  3. If lastMessageId exists, add \"last_message_id\" key\n  4. Log delta sync status\n  5. Send message\n\n## Dependencies\n- Requires: \"Implement iOS getNewestCachedMessageId function\"\n- Requires: \"Update subscribe handler to use delta sync algorithm\" (backend must accept the field)\n\n## Verification\n- [ ] Manual test: Subscribe message includes last_message_id when messages exist\n- [ ] Manual test: Subscribe message omits last_message_id when no cached messages\n- [ ] Console logs show delta sync status\n- [ ] Backend receives and logs last_message_id\n\n## Acceptance Criteria\n- Subscribe with `last_message_id` returns only newer messages\n- Subscribe without `last_message_id` returns recent messages (backward compatible)","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-31T17:09:46.221114-06:00","updated_at":"2026-01-01T09:40:00.041412-06:00","closed_at":"2026-01-01T09:40:00.041412-06:00","source_repo":".","dependencies":[{"issue_id":"voice-code-message-too-long-hfn.5","depends_on_id":"voice-code-message-too-long-hfn.4","type":"blocks","created_at":"2025-12-31T17:09:52.114723-06:00","created_by":"travisbrown"},{"issue_id":"voice-code-message-too-long-hfn.5","depends_on_id":"voice-code-message-too-long-hfn.3","type":"blocks","created_at":"2025-12-31T17:09:52.521672-06:00","created_by":"travisbrown"}]}
{"id":"voice-code-message-too-long-hfn.6","content_hash":"bc93a21520062d8a41f47b1a7133da007a6df6521b0b1c33c7bbf7457445ec6a","title":"Handle is_complete response in iOS session history","description":"## Design Reference\n@docs/design/delta-sync-session-history.md#ios-handle-incomplete-response\n\n## Context\niOS needs to handle the new `is_complete` field in session_history responses. When false, it indicates the budget was exhausted before all messages could be sent, meaning there's a gap in history.\n\n## Requirements\n- [ ] Parse `is_complete` field from session_history response\n- [ ] Parse `oldest_message_id` and `newest_message_id` fields\n- [ ] Log warning when is_complete is false\n- [ ] Optionally display indicator to user when history is incomplete\n\n## Technical Approach\n- File to modify: `ios/VoiceCode/Managers/VoiceCodeClient.swift`\n- In session_history case handler:\n  1. Extract is_complete boolean (default true for backward compatibility)\n  2. Extract oldest_message_id and newest_message_id strings\n  3. Log if is_complete is false\n  4. Consider: notify delegate or post notification for UI indicator\n\n## Parallelization\nCan be worked alongside: \"Update iOS subscribe to send last_message_id\"\n\n## Dependencies\n- Requires: \"Update subscribe handler to use delta sync algorithm\" (backend must send the fields)\n\n## Verification\n- [ ] Manual test: is_complete=true logged correctly\n- [ ] Manual test: is_complete=false triggers warning log\n- [ ] Manual test: Missing is_complete field defaults to true (backward compat)\n- [ ] Console shows oldest/newest message IDs\n\n## Acceptance Criteria\n- `is_complete: false` indicates budget exhaustion\n- iOS displays truncated content with appropriate indicator","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-31T17:10:14.827133-06:00","updated_at":"2026-01-01T10:18:52.105878-06:00","closed_at":"2026-01-01T10:18:52.105878-06:00","source_repo":".","dependencies":[{"issue_id":"voice-code-message-too-long-hfn.6","depends_on_id":"voice-code-message-too-long-hfn.3","type":"blocks","created_at":"2025-12-31T17:10:19.9067-06:00","created_by":"travisbrown"}]}
{"id":"voice-code-message-too-long-hfn.7","content_hash":"a391dc5590611dd33e7bbd39768dc8619ef70871a56186f6d6a0fef0a9100f34","title":"Update STANDARDS.md with delta sync protocol","description":"## Design Reference\n@docs/design/delta-sync-session-history.md#required-documentation-updates\n\n## Context\nSTANDARDS.md documents the WebSocket protocol. It must be updated to reflect the new delta sync fields and behavior.\n\n## Requirements\n- [ ] Document `last_message_id` optional field in Subscribe message\n- [ ] Document `oldest_message_id`, `newest_message_id`, `is_complete` in Session History response\n- [ ] Document delta sync behavior and algorithm summary\n- [ ] Document error cases (stale last_message_id treated as not provided)\n\n## Technical Approach\n- File to modify: `STANDARDS.md`\n- Sections to update:\n  1. Subscribe Message section - add last_message_id field\n  2. Session History Response section - add new fields\n  3. Add new \"Delta Sync\" subsection explaining behavior\n\n## Dependencies\n- Should be done after: All implementation tasks (to document final behavior)\n\n## Verification\n- [ ] All new fields documented with correct types and descriptions\n- [ ] Examples show both with and without last_message_id\n- [ ] Error cases documented\n- [ ] Documentation matches implemented behavior\n\n## Acceptance Criteria\n- Protocol documentation accurately reflects implementation\n- New developers can understand delta sync from STANDARDS.md alone","status":"open","priority":2,"issue_type":"task","created_at":"2025-12-31T17:10:38.95168-06:00","updated_at":"2025-12-31T17:10:38.95168-06:00","source_repo":".","dependencies":[{"issue_id":"voice-code-message-too-long-hfn.7","depends_on_id":"voice-code-message-too-long-hfn.5","type":"blocks","created_at":"2025-12-31T17:10:44.994082-06:00","created_by":"travisbrown"},{"issue_id":"voice-code-message-too-long-hfn.7","depends_on_id":"voice-code-message-too-long-hfn.6","type":"blocks","created_at":"2025-12-31T17:10:45.39163-06:00","created_by":"travisbrown"}]}
{"id":"voice-code-priority-queue-0z7","content_hash":"ab0a52a9690811ba5fe88ab7bb76e5e6920e3eff9ad67031694fd754710369a8","title":"removeFromPriorityQueue resets priority to 10 losing user's preference","description":"**Design decision:** Current reset behavior is intentional.\n\n**Rationale for resetting:**\n1. Clean separation between queue states\n2. priority field only meaningful when isInPriorityQueue=true\n3. Prevents confusion about stale priority values\n4. Consistent with 'remove = clean slate' mental model\n\n**Counter-argument (preserve):**\n- User preference shouldn't be lost\n- Re-adding should restore previous state\n\n**Current behavior documented:**\n- CDBackendSession+PriorityQueue.swift line 53: session.priority = 10\n- Comment: 'Reset to default'\n\n**Recommendation:** Keep as P3 product decision. Current behavior is explicit and documented. Change only if user feedback indicates preference preservation is expected.","status":"open","priority":4,"issue_type":"task","created_at":"2025-12-09T22:13:10.317041-06:00","updated_at":"2025-12-10T09:56:26.529348-06:00","source_repo":".","labels":["code-quality"]}
{"id":"voice-code-priority-queue-130","content_hash":"cbdbdc635d70ba58696f9282357bbe7d79addb4fdfde1cb9d35cff45c132fcdf","title":"Handle concurrent priority changes from multiple sessions","description":"If user has two sessions open in split view or changes priority rapidly, concurrent changePriority calls could interleave. Both sessions fetch same maxOrder, both set same priorityOrder+1.0, violating FIFO order. Fix: Use atomic counter or serialize priority changes with DispatchQueue.","status":"closed","priority":2,"issue_type":"bug","created_at":"2025-12-09T21:04:00.982816-06:00","updated_at":"2025-12-10T09:36:12.575846-06:00","closed_at":"2025-12-10T09:36:12.575846-06:00","source_repo":"."}
{"id":"voice-code-priority-queue-19k","content_hash":"b251deac079bae66eee32755035d8a61829af29c952e6440e170f31bd7168374","title":"ConversationView priority queue CoreData saves block main thread","description":"**Analysis:** Minimal impact for current operations.\n\n**Current state:**\n- All priority queue operations now go through CDBackendSession+PriorityQueue.swift\n- Each operation saves 2-4 scalar properties (Bool, Int32, Double, Date?)\n- SQLite writes for scalar properties are very fast (~1-5ms)\n\n**When this matters:**\n- Very slow storage (not typical on iOS)\n- Large pending transaction (not applicable - we save immediately)\n- Concurrent saves (single viewContext prevents this)\n\n**Measurement needed:**\nProfile actual save time in production before optimizing. Typical iOS device with SSD will complete in \u003c5ms.\n\n**If optimization needed:**\n```swift\n// Use perform instead of synchronous save\nviewContext.perform {\n    try? viewContext.save()\n}\n```\n\n**Recommendation:** Downgrade to P4. Premature optimization without evidence of actual jank.","status":"open","priority":4,"issue_type":"bug","created_at":"2025-12-09T21:56:08.657828-06:00","updated_at":"2025-12-10T09:53:13.422143-06:00","source_repo":".","labels":["threading"]}
{"id":"voice-code-priority-queue-1rc","content_hash":"a840df81372d7150cc1cd9db5248f8b41afc1eeb77b999dbeee165327135d481","title":"Auto-add calls addToPriorityQueue every prompt send even if already queued","description":"ConversationView line 584-586 calls addToPriorityQueue on every prompt send. Function is idempotent (returns early if already queued) but still does guard check, function call overhead. Consider: if !session.isInPriorityQueue check before calling. Micro-optimization, not critical. Trade-off: simpler code vs. tiny performance gain.","status":"open","priority":3,"issue_type":"task","created_at":"2025-12-09T21:22:47.319839-06:00","updated_at":"2025-12-09T21:22:47.319839-06:00","source_repo":".","labels":["performance"]}
{"id":"voice-code-priority-queue-1xg","content_hash":"41434f57feb84e7401da9a2431693e0aa547025576e085ffbd246b815790e378","title":"No error reporting or crash analytics for production priority queue failures","description":"**File:** All priority queue implementation files\n\n**Issue:** No error reporting or crash analytics integration to track priority queue failures in production. When users encounter bugs, developers have no visibility.\n\n**Missing Instrumentation:**\n\n1. **Crash Reporting:**\n```swift\n// When CoreData save fails\ndo {\n    try viewContext.save()\n} catch {\n    // ‚ùå Only logs locally, doesn't report to crash service\n    logger.error(\"Save failed: \\(error)\")\n    \n    // ‚úÖ Should report to analytics\n    CrashReporter.recordError(error, context: [\n        \"operation\": \"add_to_priority_queue\",\n        \"session_id\": session.id.uuidString,\n        \"priority\": session.priority\n    ])\n}\n```\n\n2. **Performance Monitoring:**\n```swift\n// Track slow cache updates\nprivate func updateCachedPriorityQueueSessions() {\n    let startTime = Date()\n    \n    // ... update logic ...\n    \n    let duration = Date().timeIntervalSince(startTime)\n    if duration \u003e 0.5 {\n        PerformanceMonitor.recordSlowOperation(\n            \"priority_queue_cache_update\",\n            duration: duration,\n            metadata: [\"session_count\": sessions.count]\n        )\n    }\n}\n```\n\n3. **Error Aggregation:**\n```swift\n// Track patterns of errors\nenum PriorityQueueError: Error {\n    case fetchMaxOrderFailed(priority: Int32)\n    case saveContextFailed(operation: String)\n    case invalidPriorityOrder(value: Double)\n    case concurrentModification\n}\n\n// Report to error tracking service\nErrorTracker.record(PriorityQueueError.fetchMaxOrderFailed(priority: priority))\n```\n\n4. **User Journey Tracking:**\n```swift\n// Track user flow through feature\nAnalytics.trackEvent(\"priority_queue_session_added\", properties: [\n    \"priority\": priority,\n    \"source\": \"conversation_view\",\n    \"auto_add\": true\n])\n```\n\n**Benefits:**\n- Detect production issues before user reports\n- Measure error rates and impact\n- Prioritize bug fixes based on frequency\n- Monitor performance degradation\n- Track adoption and usage patterns\n\n**Integration Options:**\n- Sentry for crash reporting\n- Firebase Crashlytics\n- New Relic for performance\n- Custom analytics backend\n\n**Privacy Considerations:**\n- Don't send session content or names\n- Hash session IDs before sending\n- Aggregate metrics, not individual events\n- Allow user opt-out\n\n**Example Integration:**\n```swift\n#if canImport(Sentry)\nimport Sentry\n\nprivate func addToPriorityQueue(_ session: CDBackendSession) {\n    let transaction = SentrySDK.startTransaction(\n        name: \"add_to_priority_queue\",\n        operation: \"db.coredata\"\n    )\n    \n    defer { transaction.finish() }\n    \n    // ... implementation ...\n    \n    do {\n        try viewContext.save()\n    } catch {\n        SentrySDK.capture(error: error) { scope in\n            scope.setContext(value: [\n                \"priority\": session.priority,\n                \"operation\": \"add_to_priority_queue\"\n            ], key: \"priority_queue\")\n        }\n        throw error\n    }\n}\n#endif\n```\n\n**Related:** voice-code-priority-queue-dbc [P4] tracks analytics for feature usage.","status":"open","priority":4,"issue_type":"bug","created_at":"2025-12-09T22:17:31.883696-06:00","updated_at":"2025-12-09T22:17:31.883696-06:00","source_repo":".","labels":["monitoring"]}
{"id":"voice-code-priority-queue-25d","content_hash":"938a115b9c402a3a8e31d167a8e8251811e28a86e40d781005518e749ec0470f","title":"Section header capitalization inconsistent with iOS guidelines","description":"DirectoryListView line 213: header text 'Priority Queue' uses title case. iOS Human Interface Guidelines recommend sentence case for section headers. Should be 'Priority queue'. Also affects 'Queue' (line 192) - should be 'Queue' (already correct). Very minor style issue. Check consistency across app.","status":"open","priority":4,"issue_type":"task","created_at":"2025-12-09T21:23:21.877705-06:00","updated_at":"2025-12-09T21:23:21.877705-06:00","source_repo":".","labels":["ux"]}
{"id":"voice-code-priority-queue-29g","content_hash":"c586fc4455ab2971cedfdc42102e574a860134eaa05d004db4dc4fdc18fe7a9e","title":"Add isAppActive check to updateCachedPriorityQueueSessions","description":"DirectoryListView.updateCachedPriorityQueueSessions() missing isAppActive guard check (line 464). updateCachedQueuedSessions has it (line 429). Without this check, priority queue updates can happen in background, triggering iOS watchdog kill (0x8BADF00D). Fix: Add guard isAppActive check at start of function.","status":"closed","priority":0,"issue_type":"bug","created_at":"2025-12-09T20:58:47.488095-06:00","updated_at":"2025-12-09T22:24:02.141282-06:00","closed_at":"2025-12-09T22:24:02.141282-06:00","source_repo":"."}
{"id":"voice-code-priority-queue-2e6","content_hash":"43990683db109230fc52700b0ce4f24af2178897e85088f07313730a8fd27bd3","title":"Future: Localization Support for Priority Queue","description":"Extract hardcoded strings to NSLocalizedString for internationalization support.\n\nSTATUS: Future enhancement (post-MVP)\nDesign doc acknowledges: \"Initial implementation uses hardcoded English. Localization task added for future sprint.\"\n\nFILES TO MODIFY:\n- ios/VoiceCode/Views/DirectoryListView.swift\n- ios/VoiceCode/Views/ConversationView.swift\n- ios/VoiceCode/Views/SettingsView.swift\n\nSTRINGS TO LOCALIZE (from Design Section 12):\n\nSettings Strings:\n- NSLocalizedString(\"priority_queue_section_header\", comment: \"Settings section header\")\n  // \"Priority Queue\"\n\n- NSLocalizedString(\"priority_queue_toggle_title\", comment: \"Toggle switch label\")\n  // \"Enable Priority Queue\"\n\n- NSLocalizedString(\"priority_queue_description\", comment: \"Feature description\")\n  // \"Automatically track sessions in priority-based queue...\"\n\nUI Strings:\n- NSLocalizedString(\"priority_queue_list_header\", comment: \"DirectoryListView section\")\n  // \"Priority Queue\"\n\n- NSLocalizedString(\"priority_label\", comment: \"Session info modal label\")\n  // \"Priority\"\n\n- NSLocalizedString(\"priority_locked_message\", comment: \"Lock indicator in modal\")\n  // \"Priority locked while processing\"\n\n- NSLocalizedString(\"remove_from_queue\", comment: \"Swipe action label\")\n  // \"Remove\"\n\nError Strings (if implemented):\n- NSLocalizedString(\"priority_queue_save_error\", comment: \"Error message\")\n  // \"Failed to update priority queue\"\n\nAccessibility Strings:\n- NSLocalizedString(\"priority_badge_hint\", comment: \"VoiceOver hint\")\n  // \"Priority ranges from -100 (most urgent) to 100 (least urgent). Lower numbers are higher priority.\"\n\n- NSLocalizedString(\"remove_from_queue_label\", comment: \"Button accessibility\")\n  // \"Remove from priority queue\"\n\nIMPLEMENTATION STEPS:\n1. Create Localizable.strings file for English (en)\n2. Add all strings from design Section 12\n3. Replace hardcoded strings with NSLocalizedString calls\n4. Create additional Localizable.strings for target languages\n5. Test with language switcher in Settings\n\nPRIORITY BADGE FORMAT:\n- Positive priorities: \"P10\", \"P5\", \"P100\"\n- Negative priorities: \"P-5\", \"P-10\"\n- Zero: \"P0\"\n\nNote: Badge format likely doesn't need localization (numbers universal)\n\nACCEPTANCE CRITERIA:\n‚úÖ Localizable.strings created\n‚úÖ All strings from design Section 12 added\n‚úÖ Hardcoded strings replaced with NSLocalizedString\n‚úÖ Tested with at least one non-English language\n‚úÖ Priority badge format works in all languages\n‚úÖ No hardcoded English text remains\n\nTESTING:\n1. Settings ‚Üí General ‚Üí Language \u0026 Region\n2. Add language (e.g., Spanish, French)\n3. Change iPhone language\n4. Launch app\n5. Verify all priority queue UI shows translated strings\n6. Test VoiceOver with translated strings\n\nFUTURE CONSIDERATION:\n- RTL language support (Arabic, Hebrew)\n- Number formatting for priorities (locale-specific)","status":"open","priority":4,"issue_type":"task","created_at":"2025-12-08T22:03:40.220655-06:00","updated_at":"2025-12-08T22:03:40.220655-06:00","source_repo":"."}
{"id":"voice-code-priority-queue-2h5","content_hash":"ae7731940d4763256f2670d6358b0849eaa82ba1bcc96617f80d8a782fac0468","title":"SessionInfoView loadGitBranch may update @State from background thread","description":"**File:** SessionInfoView.swift:157-161\n\n**Issue:** loadGitBranch() is async and updates @State (isLoadingBranch, gitBranch) but doesn't explicitly dispatch to MainActor. GitBranchDetector.detectBranch() might execute on background thread.\n\n**Impact:** If GitBranchDetector updates UI state from background thread, could cause SwiftUI state corruption or AttributeGraph crashes.\n\n**Evidence:**\n```swift\n// SessionInfoView.swift:157-161\nprivate func loadGitBranch() async {\n    isLoadingBranch = true  // ‚ö†Ô∏è May run on background thread\n    gitBranch = await GitBranchDetector.detectBranch(workingDirectory: session.workingDirectory)\n    isLoadingBranch = false  // ‚ö†Ô∏è May run on background thread\n}\n```\n\n**Verification Needed:** Check if GitBranchDetector.detectBranch() is annotated with @MainActor or explicitly dispatches to main thread.\n\n**Fix (if needed):**\n```swift\n@MainActor\nprivate func loadGitBranch() async {\n    isLoadingBranch = true\n    gitBranch = await GitBranchDetector.detectBranch(workingDirectory: session.workingDirectory)\n    isLoadingBranch = false\n}\n```\n\nOr use Task with explicit MainActor:\n```swift\nTask { @MainActor in\n    isLoadingBranch = true\n    gitBranch = await GitBranchDetector.detectBranch(...)\n    isLoadingBranch = false\n}\n```","status":"open","priority":3,"issue_type":"bug","created_at":"2025-12-09T21:45:25.519648-06:00","updated_at":"2025-12-09T21:45:25.519648-06:00","source_repo":".","labels":["threading"]}
{"id":"voice-code-priority-queue-2k4","content_hash":"9c4b87a481a0698e08b29f89b6d2bb9538dc5e0f3ebdf46d637e2ae5bb08ed36","title":"fetchMaxPriorityOrder default value 0.0 matches schema default creating subtle assumption","description":"**File:** DirectoryListView.swift:546-551, ConversationView.swift:962-967, SessionInfoView.swift:262-267\n\n**Issue:** fetchMaxPriorityOrder() returns 0.0 when no sessions exist in priority group. CoreData schema default for priorityOrder is also 0.0. This creates subtle assumption that priorityOrder=0.0 means \"not in queue\" but schema doesn't enforce this.\n\n**Impact:** Low risk currently due to isInPriorityQueue filter, but could cause bugs if filter is removed during refactoring.\n\n**Fix:** Change default to -1.0 or use nullable Double? to distinguish \"never assigned\" from \"first in group\".","status":"closed","priority":2,"issue_type":"bug","created_at":"2025-12-09T21:37:19.70659-06:00","updated_at":"2025-12-10T09:37:30.291267-06:00","closed_at":"2025-12-10T09:37:30.291267-06:00","source_repo":".","labels":["data-integrity"]}
{"id":"voice-code-priority-queue-2la","content_hash":"671e228c73eab78f6fa1b0427a5c8ffdc7452676289e4e8e5cdf866c9b7d08b2","title":"Add NotificationCenter sync for priority changes between views","description":"When priority changes in SessionInfoView, DirectoryListView cache doesn't update until navigation event. User sees stale priority order. Fix: Post notification when priority changes, add .onReceive listener in DirectoryListView to trigger updateCachedPriorityQueueSessions().","status":"closed","priority":0,"issue_type":"bug","created_at":"2025-12-09T20:58:56.793321-06:00","updated_at":"2025-12-09T22:24:02.141108-06:00","closed_at":"2025-12-09T22:24:02.141108-06:00","source_repo":"."}
{"id":"voice-code-priority-queue-2uc","content_hash":"1dcb8e76324f09e28f27ccdd8b313edbfe6102c2a73a057472dc1426093cde56","title":"Consider alternate UI feedback for priority changes","description":"SessionInfoView shows toast 'Priority changed to 5' but doesn't show effect on queue position. Consider showing 'Moved to position 3 in Medium priority' or animating change in DirectoryListView. Would improve user understanding of priority system.","status":"open","priority":3,"issue_type":"task","created_at":"2025-12-09T21:05:16.3383-06:00","updated_at":"2025-12-09T21:05:16.3383-06:00","source_repo":".","labels":["ux"]}
{"id":"voice-code-priority-queue-2vd","content_hash":"1514b2ea5c712c61503933775d6d4dbc3e15be2856d158b72a002c62318007d3","title":"Consider rate limiting or debouncing changePriority in SessionInfoView","description":"SessionInfoView Picker calls changePriority on every segment change. If user rapidly taps between segments, triggers multiple CoreData saves and log messages. Consider debouncing with DispatchWorkItem or only save on sheet dismiss. Low priority - segmented picker changes are discrete, not continuous like slider.","status":"open","priority":3,"issue_type":"task","created_at":"2025-12-09T21:18:24.340491-06:00","updated_at":"2025-12-09T21:18:24.340491-06:00","source_repo":".","labels":["performance"]}
{"id":"voice-code-priority-queue-2wj","content_hash":"9fb3b71f5edf609558a398ce1d2f8956472c9f09bd66fc6cb88cb262c90c2894","title":"ConversationView auto-add has no opt-out mechanism for specific sessions","description":"**File:** ConversationView.swift:583-586\n\n**Issue:** Auto-add to priority queue happens in sendPromptText() for ALL sessions, but some sessions might be explicitly marked as \"don't auto-add\" by user. No way to opt-out of auto-add for specific sessions.\n\n**Impact:**\n- User removes session from priority queue intentionally\n- Sends another message\n- Session auto-added back to priority queue\n- User frustrated: \"I just removed this!\"\n\n**Evidence:**\n```swift\n// ConversationView.swift:583-586\nif settings.priorityQueueEnabled {\n    addToPriorityQueue(session)  // No opt-out mechanism\n}\n```\n\n**User Story:**\n1. User has 10 active sessions\n2. Enables Priority Queue feature\n3. Auto-add puts all sessions in queue\n4. User removes 5 sessions they don't want in queue\n5. Continues working on remaining 5 sessions\n6. Next message in removed session ‚Üí auto-added back! üò°\n\n**Proposed Solutions:**\n\n1. **Add \"dont auto-add\" flag:**\n```swift\n// CoreData: add property\n@NSManaged public var disableAutoAddToPriorityQueue: Bool\n\n// In sendPromptText:\nif settings.priorityQueueEnabled \u0026\u0026 !session.disableAutoAddToPriorityQueue {\n    addToPriorityQueue(session)\n}\n```\n\n2. **Remember user removals:**\n```swift\n// Only auto-add if never been in queue OR still in queue\n// Don't re-add if user explicitly removed\nif settings.priorityQueueEnabled \u0026\u0026 session.priorityQueuedAt == nil {\n    addToPriorityQueue(session)  // First time only\n}\n```\n\n3. **Add Settings toggle:** \"Auto-add sessions to Priority Queue\"\n\n4. **Make auto-add manual:** Remove auto-add entirely, require explicit button tap\n\n**Product Decision Needed:** Is auto-add intended to be permanent or one-time?","status":"closed","priority":3,"issue_type":"bug","created_at":"2025-12-09T21:56:13.564722-06:00","updated_at":"2025-12-10T09:53:31.916457-06:00","closed_at":"2025-12-10T09:53:31.916457-06:00","source_repo":".","labels":["state-consistency"]}
{"id":"voice-code-priority-queue-2wv","content_hash":"b9a29d6ebe9578a7124d17868c0d57bc9ebe2c3c5e1574998fe03a639dbdd2d7","title":"Phase 6: UI Polish - Add optional priority badges","description":"Add visual priority indicators to queue session rows (optional enhancement).\n\nFiles to modify:\n- ios/VoiceCode/Views/DirectoryListView.swift\n\nImplementation:\nAdd overlay to CDBackendSessionRowContent showing priority badge with priority number.\n\nConsider alternatives:\n- Color-coded badges (red for low numbers, green for high)\n- Icon-based indicators (exclamation mark for urgent)\n- Hide badge for default priority of 10\n\nVerification:\n1. Add sessions with different priorities\n2. Verify badges appear correctly\n3. Verify badges aligned to trailing edge\n4. Check badge does not overlap session content\n5. Test with long session names - verify layout does not break\n6. Get user feedback on visual design","status":"open","priority":4,"issue_type":"task","created_at":"2025-12-07T17:58:36.231897-06:00","updated_at":"2025-12-07T17:58:36.231897-06:00","source_repo":".","dependencies":[{"issue_id":"voice-code-priority-queue-2wv","depends_on_id":"voice-code-priority-queue-6vx","type":"blocks","created_at":"2025-12-07T17:59:47.394752-06:00","created_by":"travisbrown"}]}
{"id":"voice-code-priority-queue-326","content_hash":"98666bcf1debe7b62d693e3ca16fc7d0011b6c36ab3da92c04d28022aa6bda8c","title":"DispatchWorkItem captures without weak references risking retain cycles","description":"**File:** DirectoryListView.swift:437-461, 468-502\n\n**Issue:** DispatchWorkItems capture `[viewModel, sessions]` without weak references. If WorkItem executes after view deallocation, could cause crashes or memory leaks.\n\n**Fix:** Use `[weak viewModel, weak self]` or cancel WorkItem in onDisappear.","status":"open","priority":3,"issue_type":"bug","created_at":"2025-12-09T21:37:10.584092-06:00","updated_at":"2025-12-09T21:37:10.584092-06:00","source_repo":".","labels":["memory-safety"]}
{"id":"voice-code-priority-queue-360","content_hash":"1a1a6107ee5e061a633ae85d75318c952437c4a00bb3b5e27ea8f69138e06059","title":"DirectoryListView Priority Queue section shares isQueueExpanded with Queue section","description":"**File:** DirectoryListView.swift:198-216\n\n**Issue:** Priority Queue section uses `isExpanded: $isQueueExpanded` - same binding as regular Queue section (line 178). Both sections share expansion state.\n\n**Impact:**\n- User collapses Queue section ‚Üí Priority Queue also collapses\n- User expands Priority Queue ‚Üí regular Queue also expands\n- Confusing UX because sections appear linked\n\n**Evidence:**\n```swift\n// DirectoryListView.swift:178\nSection(isExpanded: $isQueueExpanded) {  // Queue section\n    // ...\n}\n\n// DirectoryListView.swift:199\nSection(isExpanded: $isQueueExpanded) {  // ‚ùå SAME binding\n    // ...\n}\n```\n\n**Fix:** Use separate @State variable:\n```swift\n@State private var isPriorityQueueExpanded = true\n\n// Line 199:\nSection(isExpanded: $isPriorityQueueExpanded) {\n```\n\n**Related:** voice-code-priority-queue-ft3 already tracks this exact issue.","status":"closed","priority":3,"issue_type":"bug","created_at":"2025-12-09T21:48:23.467177-06:00","updated_at":"2025-12-10T10:06:19.322454-06:00","closed_at":"2025-12-10T10:06:19.322454-06:00","source_repo":".","labels":["ux"]}
{"id":"voice-code-priority-queue-3ay","content_hash":"5b13590703f8e4dbc5045f6d4a572a99b64b133b3562b7a4faa398e123b411ee","title":"Phase 0: Prerequisites - Review existing queue implementation","description":"Study existing queue feature to understand patterns and reuse code.\n\nFILES TO REVIEW:\n\n1. ios/VoiceCode/Models/CDBackendSession.swift\n   - Study existing queue attributes: isInQueue, queuePosition, queuedAt\n   - Understand @NSManaged property pattern\n   - Review CoreData entity structure\n\n2. ios/VoiceCode/Views/DirectoryListView.swift\n   - Review existing queue section (lines 168-187)\n   - Study updateCachedQueuedSessions function (lines 402-427)\n   - Understand filtering and sorting pattern\n   - Review swipe-to-delete implementation\n\n3. ios/VoiceCode/Views/ConversationView.swift\n   - Study addToQueue function (lines 793-840)\n   - Study removeFromQueue function (lines 842-865)\n   - Understand position management logic\n   - Review toolbar button implementation\n\n4. ios/VoiceCodeTests/QueueManagementTests.swift\n   - Review test structure and setup\n   - Study in-memory CoreData stack pattern\n   - Understand test helper functions\n   - Review test coverage approach\n\n5. ios/VoiceCode/Managers/AppSettings.swift\n   - Review queueEnabled property pattern\n   - Understand UserDefaults persistence\n   - Study @Published property usage\n\n6. ios/VoiceCode/Views/SettingsView.swift\n   - Review Queue section implementation\n   - Study Toggle binding pattern\n   - Understand section structure\n\nUNDERSTANDING GOALS:\n- How CoreData migration works for new attributes\n- How queue position is managed on add/remove\n- How swipe actions trigger remove functions\n- How settings toggle controls feature visibility\n- How locked sessions are filtered from display\n- Test patterns for queue functionality\n\nREFERENCE PATTERNS TO REUSE:\n- @NSManaged property declarations\n- In-memory CoreData test setup\n- Section header/footer styling\n- Swipe action configuration\n- Settings UserDefaults pattern\n- Toolbar button conditional rendering\n\nDELIVERABLE:\n- Mental model of existing queue architecture\n- Notes on reusable patterns\n- Understanding of where priority queue differs\n- Confidence to implement without breaking existing queue\n\nTIME ESTIMATE: 30-60 minutes\n\nACCEPTANCE CRITERIA:\n‚úÖ All 6 files reviewed\n‚úÖ Existing queue behavior understood\n‚úÖ Patterns identified for reuse\n‚úÖ Differences documented (FIFO vs priority)\n‚úÖ Ready to start implementation","status":"closed","priority":0,"issue_type":"task","created_at":"2025-12-08T19:37:38.538859-06:00","updated_at":"2025-12-09T19:51:07.865982-06:00","closed_at":"2025-12-09T19:51:07.865982-06:00","source_repo":"."}
{"id":"voice-code-priority-queue-3bx","content_hash":"a9963655c00520806ee4ccbde9e1c426cfbef8def4faa22f2676150f800985f1","title":"Filter chain uses two separate filter calls instead of combining predicates","description":"DirectoryListView lines 473-477 uses .filter{}.filter{} chain. Could combine into single filter with compound predicate: .filter { $0.isInPriorityQueue \u0026\u0026 !lockedSessionIds.contains(...) }. Marginal performance gain (one pass vs two). Current code more readable. Low priority style choice.","status":"open","priority":4,"issue_type":"task","created_at":"2025-12-09T21:22:55.872722-06:00","updated_at":"2025-12-09T21:22:55.872722-06:00","source_repo":".","labels":["performance"]}
{"id":"voice-code-priority-queue-3dw","content_hash":"66a3e90c4d43d4ae2c64915a42faa6db39be7b05fc698b66f45eff87ca7084da","title":"Phase 2: Toolbar - Add remove button to ConversationView toolbar","description":"Add add/remove buttons to ConversationView toolbar for priority queue management.\n\nFILES TO MODIFY:\n- ios/VoiceCode/Views/ConversationView.swift\n\nLOCATION:\nIn toolbar section, after existing queue remove button (around line 329)\n\nCODE TO ADD (UPDATED - Both Add and Remove):\n\n// Add to Priority Queue Button\nif settings.priorityQueueEnabled \u0026\u0026 !session.isInPriorityQueue {\n    Button(action: {\n        addToPriorityQueue(session)\n    }) {\n        Image(systemName: \"line.3.horizontal.circle\")\n            .foregroundColor(.blue)\n    }\n    .accessibilityLabel(\"Add to priority queue\")\n}\n\n// Remove from Priority Queue Button\nif settings.priorityQueueEnabled \u0026\u0026 session.isInPriorityQueue {\n    Button(action: {\n        removeFromPriorityQueue(session)\n    }) {\n        Image(systemName: \"xmark.circle.fill\")\n            .foregroundColor(.orange)\n    }\n    .accessibilityLabel(\"Remove from priority queue\")\n}\n\nBUTTON BEHAVIOR:\n- Mutually exclusive: Show add OR remove, never both\n- Add button (blue): Manually adds session to queue\n  - Icon: line.3.horizontal.circle (queue symbol)\n  - Alternative to auto-add from workstation\n- Remove button (orange): Manually removes from queue\n  - Icon: xmark.circle.fill\n- Both respect priorityQueueEnabled setting\n\nUSE CASES:\n- Add button: User wants to prioritize existing session\n- Remove button: Session no longer needs prioritization\n- Alternative: Auto-add when session created on workstation\n\nVERIFICATION:\n\nUnit Tests:\n\n1. testAddButtonVisibility\n   - Session NOT in priority queue, setting enabled ‚Üí add button visible\n   - Session in priority queue ‚Üí add button hidden\n   - Setting disabled ‚Üí add button hidden\n\n2. testRemoveButtonVisibility\n   - Session in priority queue, setting enabled ‚Üí remove button visible\n   - Session NOT in queue ‚Üí remove button hidden\n   - Setting disabled ‚Üí remove button hidden\n\n3. testButtonsMutuallyExclusive\n   - Verify add and remove never both visible\n   - Toggle session in/out of queue\n   - Assert only one button visible at a time\n\n4. testAddButtonAction\n   - Tap add button\n   - Verify addToPriorityQueue called\n   - Verify session.isInPriorityQueue = true\n   - Verify button switches to remove\n\n5. testRemoveButtonAction\n   - Tap remove button\n   - Verify removeFromPriorityQueue called\n   - Verify session.isInPriorityQueue = false\n   - Verify button switches to add\n\nManual Test:\n1. Enable priority queue in settings\n2. Create session (not in queue yet)\n3. Open conversation view\n4. Verify blue add button in toolbar\n5. Tap add button\n6. Verify session appears in priority queue (Projects view)\n7. Return to conversation\n8. Verify button changed to orange remove\n9. Tap remove button\n10. Verify session removed from queue\n11. Verify button changed back to blue add\n12. Disable priority queue in settings\n13. Verify no buttons visible\n\nAccessibility Test:\n1. Enable VoiceOver\n2. Focus add button ‚Üí announces \"Add to priority queue\"\n3. Focus remove button ‚Üí announces \"Remove from priority queue\"\n\nACCEPTANCE CRITERIA:\n‚úÖ Add button appears when session NOT in priority queue\n‚úÖ Remove button appears when session IN priority queue\n‚úÖ Buttons mutually exclusive (never both visible)\n‚úÖ Add button: blue, line.3.horizontal.circle icon\n‚úÖ Remove button: orange, xmark.circle.fill icon\n‚úÖ Add button calls addToPriorityQueue correctly\n‚úÖ Remove button calls removeFromPriorityQueue correctly\n‚úÖ Both buttons respect priorityQueueEnabled setting\n‚úÖ Accessibility labels present\n‚úÖ All 5 unit tests pass\n‚úÖ Manual verification succeeds\n\nIMPLEMENTATION NOTE:\nThe add button provides manual control as an alternative to auto-add. Users can explicitly prioritize any session, not just new ones from workstation.\n\nDependencies (1):\n  [blocks] voice-code-priority-queue-63a (open): Phase 2: Add/Remove - Implement addToPriorityQueue and removeFromPriorityQueue [P1]\n\nDependents (2):\n  [blocks] voice-code-priority-queue-516 (open): Phase 2: Tests - Write unit tests for add/remove and sorting [P1]\n  [blocks] voice-code-priority-queue-euo (open): Phase 2: Integration Test - End-to-end priority queue workflow [P1]","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-07T17:56:29.313634-06:00","updated_at":"2025-12-09T20:19:50.404587-06:00","closed_at":"2025-12-09T20:19:50.404587-06:00","source_repo":".","dependencies":[{"issue_id":"voice-code-priority-queue-3dw","depends_on_id":"voice-code-priority-queue-63a","type":"blocks","created_at":"2025-12-07T17:59:21.035071-06:00","created_by":"travisbrown"}]}
{"id":"voice-code-priority-queue-3jv","content_hash":"16bd6fd6370bd4c0f51eb8b3287a81294073d14225c8145694b773bf41077417","title":"Debounced WorkItem executes on main queue blocking UI thread","description":"WorkItem executes filter/sort on main queue via DispatchQueue.main.asyncAfter. For typical session counts (5-20), impact is negligible. Only becomes issue with 100+ sessions.\n\nCurrent implementation:\n- DispatchQueue.main.asyncAfter schedules WorkItem\n- WorkItem runs filter/sort inline (async but on main thread)\n- Inner DispatchQueue.main.async updates cachedPriorityQueueSessions\n\nProposed optimization for large session counts:\n```swift\nlet workItem = DispatchWorkItem { [weak self, viewModel] in\n    guard let self = self else { return }\n    let lockedSessionIds = viewModel.lockedSessions\n    \n    // Execute filter/sort on background queue\n    DispatchQueue.global(qos: .userInitiated).async { [weak self] in\n        guard let self = self else { return }\n        let updatedSessions = self.sessions\n            .filter { $0.isInPriorityQueue }\n            .filter { ... }\n            .sorted { ... }\n        \n        // Update UI on main thread\n        DispatchQueue.main.async { [weak self] in\n            self?.cachedPriorityQueueSessions = updatedSessions\n        }\n    }\n}\n```\n\nTrade-off: Added complexity for marginal benefit with typical usage. Recommend implementing only if profiling shows UI jank with real-world data.","status":"open","priority":3,"issue_type":"bug","created_at":"2025-12-09T21:28:07.160789-06:00","updated_at":"2025-12-09T22:41:55.693643-06:00","source_repo":".","labels":["performance"]}
{"id":"voice-code-priority-queue-3mx","content_hash":"21fe2dff3fe3ab6e14d44ae62909b159743bd2061e64d300dace206b7b8f5f49","title":"No debug logging or instrumentation to help diagnose priority queue issues","description":"**File:** All priority queue implementation files\n\n**Issue:** No debug logging or instrumentation to help developers diagnose priority queue issues. When bugs occur, developers have minimal visibility into state.\n\n**Missing Debug Tools:**\n\n1. **State Dump Function:**\n```swift\n// Proposed: PriorityQueueDebugger.swift\nclass PriorityQueueDebugger {\n    static func dumpState(sessions: [CDBackendSession]) {\n        print(\"\\n=== Priority Queue State ===\")\n        print(\"Total sessions: \\(sessions.count)\")\n        \n        let inQueue = sessions.filter { $0.isInPriorityQueue }\n        print(\"In priority queue: \\(inQueue.count)\")\n        \n        for session in inQueue.sorted(by: { /* 3-level sort */ }) {\n            print(\"  [\\(session.priority)] order=\\(session.priorityOrder) id=\\(session.id.uuidString.prefix(8))\")\n        }\n        \n        print(\"==========================\\n\")\n    }\n}\n```\n\n2. **Cache Validation:**\n```swift\nstatic func validateCache(cached: [CDBackendSession], expected: [CDBackendSession]) -\u003e Bool {\n    guard cached.count == expected.count else {\n        print(\"‚ùå Cache count mismatch: cached=\\(cached.count) expected=\\(expected.count)\")\n        return false\n    }\n    \n    for (index, session) in cached.enumerated() {\n        guard session.id == expected[index].id else {\n            print(\"‚ùå Cache order mismatch at index \\(index)\")\n            return false\n        }\n    }\n    \n    return true\n}\n```\n\n3. **Performance Timing:**\n```swift\nstatic func measureCacheUpdate(_ block: () -\u003e Void) {\n    let start = Date()\n    block()\n    let duration = Date().timeIntervalSince(start)\n    if duration \u003e 0.1 {\n        print(\"‚ö†Ô∏è Slow cache update: \\(Int(duration * 1000))ms\")\n    }\n}\n```\n\n4. **Consistency Checks:**\n```swift\nstatic func validatePriorityOrder(sessions: [CDBackendSession]) {\n    let inQueue = sessions.filter { $0.isInPriorityQueue }\n    \n    for session in inQueue {\n        // Check priorityOrder is positive\n        if session.priorityOrder \u003c= 0 {\n            print(\"‚ùå Invalid priorityOrder: \\(session.priorityOrder) for session \\(session.id)\")\n        }\n        \n        // Check priority is in valid set\n        if ![1, 5, 10].contains(session.priority) {\n            print(\"‚ö†Ô∏è Unexpected priority: \\(session.priority) for session \\(session.id)\")\n        }\n        \n        // Check priorityQueuedAt is set\n        if session.priorityQueuedAt == nil {\n            print(\"‚ùå Missing priorityQueuedAt for session \\(session.id)\")\n        }\n    }\n}\n```\n\n5. **Event Tracing:**\n```swift\nstatic func trace(_ event: String, session: CDBackendSession) {\n    #if DEBUG\n    let timestamp = DateFormatter.localizedString(from: Date(), dateStyle: .none, timeStyle: .medium)\n    print(\"[\\(timestamp)] \\(event) - session=\\(session.id.uuidString.prefix(8)) priority=\\(session.priority) order=\\(session.priorityOrder)\")\n    #endif\n}\n\n// Usage:\nPriorityQueueDebugger.trace(\"ADD\", session: session)\nPriorityQueueDebugger.trace(\"REMOVE\", session: session)\nPriorityQueueDebugger.trace(\"CHANGE_PRIORITY\", session: session)\n```\n\n**Use Cases:**\n- Developer debugging \"why isn't my session showing?\"\n- QA reproducing \"sort order is wrong\" bugs\n- Performance profiling cache update latency\n- Automated testing validation\n\n**Integration:**\n```swift\n// In DEBUG builds only\n#if DEBUG\nprivate func addToPriorityQueue(_ session: CDBackendSession) {\n    PriorityQueueDebugger.trace(\"ADD_START\", session: session)\n    \n    guard !session.isInPriorityQueue else {\n        PriorityQueueDebugger.trace(\"ADD_SKIP_DUPLICATE\", session: session)\n        return\n    }\n    \n    // ... implementation ...\n    \n    PriorityQueueDebugger.trace(\"ADD_COMPLETE\", session: session)\n}\n#endif\n```\n\n**Benefits:**\n- Faster debugging cycles\n- Better QA bug reports\n- Easier code reviews\n- Self-documenting state\n\n**Related:** Existing codebase uses print() and logger but lacks structured debugging tools.","status":"open","priority":4,"issue_type":"bug","created_at":"2025-12-09T22:13:08.7631-06:00","updated_at":"2025-12-09T22:13:08.7631-06:00","source_repo":".","labels":["developer-experience"]}
{"id":"voice-code-priority-queue-3y1","content_hash":"2896a6ba88da78bc2a5d3cea8f4276419e6c76ad1caee298a8979afb0eda9f9a","title":"SessionInfoView exportSession shows success confirmation even on failure","description":"**File:** SessionInfoView.swift:206-208\n\n**Issue:** exportSession() uses print() for error logging instead of OSLog logger, and error is only logged - user sees \"Conversation exported\" confirmation even if export failed.\n\n**Impact:** User thinks export succeeded but clipboard contains error message. No way to diagnose export failures from structured logs.\n\n**Evidence:**\n```swift\n// SessionInfoView.swift:205-208\n} catch {\n    print(\"‚ùå Failed to fetch messages for export: \\(error)\")\n    exportText += \"Error: Failed to export messages\\n\"\n}\n\n// Line 216 - always shows success\nshowConfirmation(\"Conversation exported\")\n```\n\n**Fix:**\n1. Add OSLog logger to SessionInfoView\n2. Use logger.error() instead of print()\n3. Show different confirmation based on success/failure:\n```swift\ndo {\n    let allMessages = try viewContext.fetch(exportFetchRequest)\n    // ... build export text ...\n    UIPasteboard.general.string = exportText\n    showConfirmation(\"Conversation exported\")\n} catch {\n    logger.error(\"Export failed: \\(error.localizedDescription)\")\n    showConfirmation(\"Export failed\")\n}\n```","status":"open","priority":3,"issue_type":"bug","created_at":"2025-12-09T21:45:12.387972-06:00","updated_at":"2025-12-09T21:45:12.387972-06:00","source_repo":".","labels":["error-handling"]}
{"id":"voice-code-priority-queue-3yf","content_hash":"9283671603febd75061e20d3a8e488703f051868ef70811924a435509d2b1056","title":"Phase 6: Manual Testing - Comprehensive end-to-end testing","description":"Comprehensive end-to-end manual testing of all priority queue features.\n\nTEST SCENARIOS:\n\n1. Auto-add from workstation (CRITICAL)\n   - Enable priority queue in iOS\n   - Start Claude CLI on workstation in project directory\n   - Send prompt via terminal\n   - Verify session appears in iOS queue within 5 seconds\n   - Verify priority=10, positioned correctly\n   - Repeat with multiple sessions\n\n2. Explicit priority changes with auto-refresh (CRITICAL)\n   - Add 3 sessions: P5, P10, P15\n   - Open P15 session info modal\n   - Change priority to P5\n   - Close modal\n   - Verify queue reorders immediately (no refresh needed)\n   - Verify session at end of P5 group\n\n3. Drag-to-reorder\n   - Add 5 sessions with different priorities\n   - Long-press session to enter edit mode\n   - Drag from P10 group to P5 group\n   - Verify priority changes to P5\n   - Verify smooth animation\n   - Verify position persists after drag\n\n4. Session locking behavior\n   - Add session to queue\n   - Send prompt to session\n   - Verify session disappears from queue (locked)\n   - Wait for response\n   - Verify session reappears in correct position\n\n5. Settings integration\n   - Toggle priority queue on/off\n   - Verify section appears/disappears\n   - Verify state persists across app restarts\n   - Add sessions while enabled\n   - Disable feature\n   - Verify section hidden but data preserved\n   - Re-enable\n   - Verify sessions reappear\n\n6. Swipe-to-delete\n   - Swipe session left\n   - Tap Remove\n   - Verify removed from queue\n   - Verify section disappears when empty\n\n7. Performance testing\n   - Add 50+ sessions to queue\n   - Test scrolling smoothness (60fps)\n   - Test drag performance\n   - Test priority change speed\n   - Verify no lag or freezing\n\n8. Edge cases\n   - Negative priorities (-5, -10)\n   - Priority 0\n   - Very large priorities (100, 1000)\n   - Long session names\n   - Sessions with no working directory\n   - Rapid priority changes\n   - Concurrent queue and priority queue use\n\nDOCUMENTATION:\n- Take screenshots of each scenario\n- Note any bugs or UX issues\n- Record performance metrics\n- Document unexpected behaviors\n- Create test report document\n\nACCEPTANCE CRITERIA:\n‚úÖ All 8 scenarios tested\n‚úÖ Auto-add works reliably (\u003c5s latency)\n‚úÖ Auto-refresh works (no manual refresh)\n‚úÖ Drag gesture smooth and intuitive\n‚úÖ No crashes or data loss\n‚úÖ Performance acceptable (60fps, \u003c5s response)\n‚úÖ Test report created with findings","status":"open","priority":4,"issue_type":"task","created_at":"2025-12-07T17:58:55.584383-06:00","updated_at":"2025-12-08T19:37:20.628569-06:00","source_repo":".","dependencies":[{"issue_id":"voice-code-priority-queue-3yf","depends_on_id":"voice-code-priority-queue-zqb","type":"blocks","created_at":"2025-12-07T17:59:48.157222-06:00","created_by":"travisbrown"},{"issue_id":"voice-code-priority-queue-3yf","depends_on_id":"voice-code-priority-queue-6ct","type":"blocks","created_at":"2025-12-07T17:59:48.542989-06:00","created_by":"travisbrown"},{"issue_id":"voice-code-priority-queue-3yf","depends_on_id":"voice-code-priority-queue-gby","type":"blocks","created_at":"2025-12-07T17:59:48.928674-06:00","created_by":"travisbrown"},{"issue_id":"voice-code-priority-queue-3yf","depends_on_id":"voice-code-priority-queue-2wv","type":"blocks","created_at":"2025-12-07T17:59:49.316026-06:00","created_by":"travisbrown"},{"issue_id":"voice-code-priority-queue-3yf","depends_on_id":"voice-code-priority-queue-878","type":"blocks","created_at":"2025-12-07T17:59:49.699646-06:00","created_by":"travisbrown"},{"issue_id":"voice-code-priority-queue-3yf","depends_on_id":"voice-code-priority-queue-zrk","type":"blocks","created_at":"2025-12-08T19:38:02.214599-06:00","created_by":"travisbrown"},{"issue_id":"voice-code-priority-queue-3yf","depends_on_id":"voice-code-priority-queue-9yb","type":"blocks","created_at":"2025-12-08T19:48:26.735169-06:00","created_by":"travisbrown"}]}
{"id":"voice-code-priority-queue-3z6","content_hash":"53057b9ffb1e023b85daf853330a5fd62cd2c981ee528f58f74ccaf24bd692cb","title":"Phase 5: Priority Calculation - Implement reorderSession logic","description":"Implement priority/priorityOrder calculation when dragging sessions to reorder priority queue.\n\nFILES TO MODIFY:\n- ios/VoiceCode/Views/DirectoryListView.swift (or ConversationView.swift)\n\nDRAG-TO-REORDER ALGORITHM (UPDATED - 5 Scenarios):\n\nThe system uses **destination index** to determine priority assignment:\n- Drop position determines which session is \"below\" the dragged session\n- Session adopts priority of the below session\n- priorityOrder calculated to maintain sort stability\n\nFUNCTION TO IMPLEMENT (UPDATED - Uses saveContext Helper):\n\nfunc reorderSession(_ session: CDBackendSession, between above: CDBackendSession?, and below: CDBackendSession?) {\n    \n    // SCENARIO 1: Dragged between two sessions\n    if let above = above, let below = below {\n        if above.priority == below.priority {\n            // Same priority: calculate midpoint\n            session.priority = above.priority\n            session.priorityOrder = (above.priorityOrder + below.priorityOrder) / 2.0\n        } else {\n            // Different priorities: adopt BELOW session's priority\n            session.priority = below.priority\n            \n            // Position at END of new priority group\n            let samePrioritySessions = fetchSessionsWithPriority(below.priority)\n            let maxOrder = samePrioritySessions.map { $0.priorityOrder }.max() ?? 0.0\n            session.priorityOrder = maxOrder + 1.0\n        }\n    }\n    \n    // SCENARIO 2: Dragged to BOTTOM of queue\n    else if let above = above {\n        session.priority = above.priority\n        session.priorityOrder = above.priorityOrder + 1.0\n    }\n    \n    // SCENARIO 3: Dragged to TOP of queue\n    else if let below = below {\n        session.priority = below.priority\n        session.priorityOrder = below.priorityOrder - 1.0\n    }\n    \n    // SCENARIO 4: Edge case (shouldn't happen)\n    else {\n        // No neighbors - do nothing or set defaults\n        return\n    }\n    \n    // Use consistent error handling from task 63a\n    saveContext()\n}\n\nHELPER FUNCTIONS REQUIRED:\n\n1. fetchSessionsWithPriority(_ priority:) - Defined in this task\n2. saveContext() - From task voice-code-priority-queue-63a\n\nHELPER FUNCTION (IMPLEMENTED IN THIS TASK):\n\nfunc fetchSessionsWithPriority(_ priority: Int32) -\u003e [CDBackendSession] {\n    let request: NSFetchRequest\u003cCDBackendSession\u003e = CDBackendSession.fetchRequest()\n    request.predicate = NSPredicate(format: \"isInPriorityQueue == YES AND priority == %d\", priority)\n    return (try? viewContext.fetch(request)) ?? []\n}\n\nDETAILED SCENARIOS WITH EXAMPLES:\n\nScenario A: Drop between sessions with SAME priority\nInput:  [P10/order:10, P10/order:30]\nAction: Drag Session X between them\nResult: Session X ‚Üí priority=10, priorityOrder=20.0\n        Final: [P10/10, P10/20, P10/30]\n\nScenario B: Drop between sessions with DIFFERENT priorities\nInput:  [P5/order:100, P5/order:200, P10/order:50, P10/order:150]\nAction: Drag P5/order:100 to index 2 (between P5/200 and P10/50)\nLogic:  below.priority = 10 (session at index 2)\n        Fetch all P10 sessions: [P10/50, P10/150]\n        maxOrder = 150\n        New priorityOrder = 150 + 1.0 = 151.0\nResult: Session ‚Üí priority=10, priorityOrder=151.0\n        Final: [P5/200, P10/50, P10/150, P10/151]\n\nScenario C: Drop to EMPTY priority group (NEW)\nInput:  [P5/order:10, P5/order:20]  (no P10 sessions exist)\nAction: Drag session to P10 priority group\nLogic:  Session adopts priority=10\n        Target group is empty, so start new group\nResult: Session X ‚Üí priority=10, priorityOrder=1.0\n        Final: [P5/10, P5/20, P10/1]\n\nImplementation Note for Scenario C:\nWhen dragging to a priority that has no existing sessions:\n- fetchSessionsWithPriority returns empty array\n- maxOrder ?? 0.0 = 0.0\n- New priorityOrder = 0.0 + 1.0 = 1.0\n- This naturally handles empty groups without special case\n\nScenario D: Drop at BOTTOM\nInput:  [P5/order:10, P10/order:20, P10/order:30]\nAction: Drag Session X to bottom (after P10/30)\nLogic:  above.priority = 10, above.priorityOrder = 30\nResult: Session X ‚Üí priority=10, priorityOrder=31.0\n        Final: [P5/10, P10/20, P10/30, P10/31]\n\nScenario E: Drop at TOP\nInput:  [P5/order:10, P10/order:20]\nAction: Drag Session X to top (before P5/10)\nLogic:  below.priority = 5, below.priorityOrder = 10\nResult: Session X ‚Üí priority=5, priorityOrder=9.0\n        Final: [P5/9, P5/10, P10/20]\n\nINTEGRATION WITH .onMove:\n\nIn DirectoryListView, connect to SwiftUI's .onMove modifier:\n\n.onMove { source, destination in\n    guard let sourceIndex = source.first else { return }\n    let session = priorityQueueSessions[sourceIndex]\n    \n    // Calculate above/below sessions based on destination\n    let above = destination \u003e 0 ? priorityQueueSessions[destination - 1] : nil\n    let below = destination \u003c priorityQueueSessions.count ? priorityQueueSessions[destination] : nil\n    \n    reorderSession(session, between: above, and: below)\n    \n    // Refresh cached sessions\n    updateCachedPriorityQueueSessions()\n}\n\nLOCKED SESSION HANDLING (from design):\n- Locked sessions filtered from display (can't be dragged)\n- If session locks mid-drag: drag completes normally, session disappears after\n- No special handling needed in reorderSession (drag completes, then filter removes it)\n\nIMPLEMENTATION STEPS:\n1. Add reorderSession function to ConversationView or DirectoryListView\n2. Add fetchSessionsWithPriority helper function\n3. Verify saveContext helper exists (from task 63a)\n4. Connect .onMove modifier in DirectoryListView priority queue section\n5. Test with known session arrangements including empty priority groups\n6. Verify priorityOrder values calculated correctly\n7. Verify queue reorders correctly after drag\n8. Check console for error logs if save fails\n\nVERIFICATION - Test Pyramid:\n\nUnit Tests (9 tests in PriorityQueueManagementTests.swift):\n\n1. testDragBetweenSamePriority\n   - Create: [P10/10, P10/30]\n   - Drag Session X between them\n   - Assert: X.priority==10, X.priorityOrder==20.0\n\n2. testDragBetweenDifferentPriorities\n   - Create: [P5/100, P10/50]\n   - Drag between them\n   - Assert: Session adopts P10 (below), order = max(P10)+1\n\n3. testDragToEmptyPriorityGroup (NEW)\n   - Create: [P5/10, P5/20] (no P10 sessions)\n   - Drag session to position that would be P10\n   - Assert: Session gets priority=10, priorityOrder=1.0\n\n4. testDragToTop\n   - Create 3 sessions\n   - Drag to index 0\n   - Assert: priority = first session's priority\n   - Assert: priorityOrder = first.order - 1.0\n\n5. testDragToBottom\n   - Create 3 sessions\n   - Drag to end\n   - Assert: priority = last session's priority\n   - Assert: priorityOrder = last.order + 1.0\n\n6. testDragWithinSamePriorityGroup\n   - All sessions P10\n   - Drag from position 0 to position 2\n   - Assert: Stays P10, order = midpoint\n\n7. testDragAcrossPriorityBoundary\n   - Create: [P5, P5, P10, P10]\n   - Drag P5 into P10 group\n   - Assert: Priority changes to P10\n   - Assert: Positioned at end of P10 group\n\n8. testDragSingleSession\n   - Only 1 session in queue\n   - Attempt drag to same position\n   - Assert: No changes (no-op or graceful handling)\n\n9. testPriorityOrderPrecision\n   - Create sessions, drag 100 times\n   - Assert: priorityOrder maintains precision\n   - Assert: No floating-point overflow\n   - Assert: Values remain sortable\n\nManual Verification:\n1. Run app on simulator\n2. Add 5 sessions with priorities: P5, P5, P10, P10, P15\n3. Long-press session to enter edit mode\n4. Drag P10 session into P5 group\n5. Verify priority changes to P5\n6. Verify positioned at end of P5 group\n7. Drag P5 session to bottom\n8. Verify priority changes to P15\n9. Drag sessions within same priority\n10. Verify order = midpoint\n11. Create gap in priorities (P5, P15, no P10)\n12. Drag P5 session to where P10 would be\n13. Verify creates new P10 group with order=1.0\n14. Check debugger:\n    po priorityQueueSessions.map { ($0.priority, $0.priorityOrder) }\n15. Verify values make sense\n16. Check console for saveContext logs if errors occur\n\nACCEPTANCE CRITERIA:\n‚úÖ reorderSession function implemented with all 5 scenarios\n‚úÖ fetchSessionsWithPriority helper function implemented\n‚úÖ Uses saveContext() helper for error handling (not inline do-catch)\n‚úÖ .onMove modifier connected in DirectoryListView\n‚úÖ Drag between same priority: midpoint calculation\n‚úÖ Drag between different priorities: adopts below priority, end of group\n‚úÖ Drag to empty priority group: creates new group with order=1.0\n‚úÖ Drag to top: becomes first in queue\n‚úÖ Drag to bottom: becomes last in queue\n‚úÖ All 9 unit tests pass\n‚úÖ priorityOrder uses Double (no integer overflow)\n‚úÖ No duplicate priorityOrder values created\n‚úÖ CoreData saves succeed (via saveContext)\n‚úÖ Manual drag test succeeds with correct reordering\n‚úÖ Edge cases handled gracefully (single session, no neighbors, empty groups)\n‚úÖ Error logging works (check console on save failure)\n\nEDGE CASES HANDLED:\n- Empty above/below (top/bottom of queue)\n- Same priority (midpoint calculation)\n- Different priorities (adopt destination, end of group)\n- Empty priority group (start new group with order=1.0)\n- Single session in queue (no-op)\n- Drag to same position (no-op)\n- Precision limits (Double sufficient for 1000+ drags)\n- Session locks mid-drag (completes drag, session filters out after)\n\nDEPENDENCIES:\n- CRITICAL: Depends on saveContext() helper from task voice-code-priority-queue-63a\n- Must be in scope (same file or accessible)\n\nRATIONALE:\nUsing destination index (below position) provides predictable, consistent behavior without calculating visual \"closeness\". Algorithm is simple, deterministic, and matches user expectations.","status":"closed","priority":4,"issue_type":"task","created_at":"2025-12-07T17:58:04.608164-06:00","updated_at":"2025-12-10T18:13:50.422419-06:00","closed_at":"2025-12-10T18:13:50.422419-06:00","source_repo":".","dependencies":[{"issue_id":"voice-code-priority-queue-3z6","depends_on_id":"voice-code-priority-queue-9h5","type":"blocks","created_at":"2025-12-07T17:59:39.475399-06:00","created_by":"travisbrown"},{"issue_id":"voice-code-priority-queue-3z6","depends_on_id":"voice-code-priority-queue-63a","type":"blocks","created_at":"2025-12-08T22:44:12.945444-06:00","created_by":"travisbrown"}]}
{"id":"voice-code-priority-queue-4f4","content_hash":"b7846236717f0debac1f581ac98f2837aefa8da499ce929d67bf27744e0e5705","title":"SettingsView Priority Queue description incorrectly mentions workstation","description":"**File:** SettingsView.swift:118-124\n\n**Issue:** Settings description text says \"Sessions updated on workstation appear automatically\" but Priority Queue is iOS-only feature. Sessions cannot be updated on workstation - they're managed in iOS app.\n\n**Impact:** Misleading documentation confuses users about feature behavior. Text implies backend integration that doesn't exist.\n\n**Evidence:**\n```swift\n// SettingsView.swift:121\nText(\"Automatically track sessions in priority-based queue. Sessions updated on workstation appear automatically. Lower priority numbers appear first.\")\n```\n\n**Actual Behavior:**\n- Sessions are auto-added to priority queue when user sends first message (ConversationView.swift:584)\n- Nothing happens on workstation - this is iOS-only feature\n- Text is copy-pasted from regular Queue description and incorrectly adapted\n\n**Correct Description:**\n```swift\nText(\"Automatically add sessions to priority-based queue when you send a message. Lower priority numbers appear first.\")\n```\n\nOr explain manual management:\n```swift\nText(\"Track sessions in priority-based queue. Sessions are added automatically when you send a message, and you can adjust priorities to control sort order. Lower numbers = higher priority.\")\n```\n\n**Related:** voice-code-priority-queue-un4 already tracks this issue.","status":"closed","priority":2,"issue_type":"bug","created_at":"2025-12-09T21:46:00.168247-06:00","updated_at":"2025-12-09T22:35:11.623431-06:00","closed_at":"2025-12-09T22:35:11.623431-06:00","source_repo":".","labels":["ux"]}
{"id":"voice-code-priority-queue-4g6","content_hash":"8f751c4e36f28fd7666a7d6e527e8736dd1ccc51f4a5e007224ab184af6da51c","title":"DirectoryListView @State sessions array is root cause of synchronization bugs","description":"**Status:** Mitigated but not fully resolved.\n\n**What was fixed:**\n- Option 2 implemented: CDBackendSession+PriorityQueue.swift posts .priorityQueueChanged notification after ALL changes\n- DirectoryListView observes .priorityQueueChanged and refreshes cache (lines 397-404)\n- Related bugs (do2, bdc, ea0) now closed\n\n**Remaining concern:**\n@State sessions array still requires manual management, but synchronization is now handled via NotificationCenter pattern. Risk of missed updates is reduced.\n\n**Future improvement:**\nRefactor to @FetchRequest would eliminate manual sync entirely, but current NotificationCenter solution is working and tested.\n\n**Recommendation:** Downgrade to P3 - architectural improvement, not a bug.","status":"open","priority":3,"issue_type":"bug","created_at":"2025-12-09T22:07:52.626549-06:00","updated_at":"2025-12-10T09:35:37.428102-06:00","source_repo":".","labels":["state-management"]}
{"id":"voice-code-priority-queue-4ln","content_hash":"7350e7cc5e82f444705e40a94a31533eeab6847150d11c3807a9f25d32858be5","title":"Extract priority queue magic numbers to constants","description":"Hard-coded values appear multiple times: 10 (default priority, 6x), 0.15 (debounce delay, 2x), 1.0 (order increment, 9x), 'priorityQueueEnabled' (UserDefaults key, 3x). Create PriorityQueueConstants enum with static properties.","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-09T21:00:12.54176-06:00","updated_at":"2025-12-10T09:41:10.57956-06:00","closed_at":"2025-12-10T09:41:10.57956-06:00","source_repo":".","labels":["refactor"]}
{"id":"voice-code-priority-queue-50ey","content_hash":"7a818996c4d03783ff6beb05a57ac259f1997a8a6973d3656acc4baf9b7909ef","title":"Auto-add fix: Remove stale turn_complete auto-add code from VoiceCodeClient","description":"Cleanup: Ensure no auto-add logic exists in turn_complete handler in VoiceCodeClient.swift. The auto-add is now handled reliably in SessionSyncManager.\n\nIMPORTANT: The stashed changes (stash@{0}) contain auto-add code for turn_complete. Do NOT apply this stash. The stash should be dropped, not applied.\n\nCurrent turn_complete handler should ONLY do:\n- Session unlock functionality (lockedSessions removal)\n- Fallback subscription if needed\n\nIt should NOT contain:\n- addSessionToPriorityQueueByBackendName calls\n- Any priority queue auto-add logic\n\nFile: ios/VoiceCode/Managers/VoiceCodeClient.swift\nLocation: case \"turn_complete\" handler (~line 504-530)\n\nReference: PRIORITY_QUEUE_AUTO_ADD_FIX.md section 'What About turn_complete?'","acceptance_criteria":"1. turn_complete handler still unlocks sessions correctly\n2. No auto-add code remains in VoiceCodeClient.swift turn_complete handler\n3. addSessionToPriorityQueueByBackendName function removed (if it exists)\n4. Code compiles without errors\n5. All tests still pass","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-10T20:07:19.395976-06:00","updated_at":"2025-12-10T20:31:30.696485-06:00","closed_at":"2025-12-10T20:31:30.696485-06:00","source_repo":".","dependencies":[{"issue_id":"voice-code-priority-queue-50ey","depends_on_id":"voice-code-priority-queue-yocj","type":"blocks","created_at":"2025-12-10T20:15:11.187104-06:00","created_by":"travisbrown"}]}
{"id":"voice-code-priority-queue-516","content_hash":"9ea5ea9382e8f4d76f05cf7133ada4190cd31dd88fc2c9267fdcec1f8ccbe590","title":"Phase 2: Tests - Write unit tests for add/remove and sorting","description":"Comprehensive unit tests for Phase 2 add/remove and sorting functionality.\n\nFILE TO MODIFY:\n- ios/VoiceCodeTests/PriorityQueueManagementTests.swift\n\nTESTS TO ADD (12 tests total):\n\nADD/REMOVE TESTS:\n1. testAddToPriorityQueue - Fields set correctly\n2. testAddIdempotent - Multiple adds don't duplicate\n3. testRemoveFromPriorityQueue - Fields reset correctly\n4. testRemoveIdempotent - Safe to remove multiple times\n5. testPriorityOrderUniqueness - No duplicate priorityOrder values\n\nSORTING TESTS:\n6. testPrioritySortingAscending - Lower priority numbers first\n7. testPriorityOrderTieBreaking - Within same priority, older first\n8. testMixedPrioritiesAndOrders - Complex sorting scenario\n9. testNegativePriorities - Negative numbers sort correctly\n10. testSortingStability - Equal elements maintain relative order\n\nFILTERING TESTS:\n11. testLockedSessionsFiltered - Locked sessions hidden\n12. testUnlockedSessionsReappear - Sessions reappear after unlock\n\nTEST APPROACH:\n- Use in-memory CoreData stack\n- Create sessions with known priority/priorityOrder values\n- Assert actual sort order matches expected\n- Mock lockedSessionIds for filtering tests\n- Verify no crashes with edge cases (empty queue, nil values)\n\nACCEPTANCE CRITERIA:\n‚úÖ All 12 tests pass\n‚úÖ Code coverage \u003e 85% for queue management code\n‚úÖ Tests run in \u003c 2 seconds\n‚úÖ No flaky tests\n‚úÖ Edge cases covered (empty, single session, many sessions)","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-07T17:56:40.515392-06:00","updated_at":"2025-12-09T20:19:50.404703-06:00","closed_at":"2025-12-09T20:19:50.404703-06:00","source_repo":".","dependencies":[{"issue_id":"voice-code-priority-queue-516","depends_on_id":"voice-code-priority-queue-6vx","type":"blocks","created_at":"2025-12-07T17:59:21.416734-06:00","created_by":"travisbrown"},{"issue_id":"voice-code-priority-queue-516","depends_on_id":"voice-code-priority-queue-3dw","type":"blocks","created_at":"2025-12-07T17:59:21.80532-06:00","created_by":"travisbrown"},{"issue_id":"voice-code-priority-queue-516","depends_on_id":"voice-code-priority-queue-euo","type":"blocks","created_at":"2025-12-08T19:34:52.176376-06:00","created_by":"travisbrown"}]}
{"id":"voice-code-priority-queue-576","content_hash":"e7c2631a839c4db90b7ff6a4426b58bedc4305f246caf085abc8a0154bc710a5","title":"SessionInfoView Priority Queue footer text is redundant with Picker labels","description":"**File:** SessionInfoView.swift:109\n\n**Issue:** Footer text says \"Lower priority number = higher importance\" but UI shows \"High (1)\" / \"Medium (5)\" / \"Low (10)\" labels which already communicate this. Footer is redundant.\n\n**Impact:** Minor - adds visual clutter without providing new information.\n\n**Evidence:**\n```swift\n// SessionInfoView.swift:108-111\n} footer: {\n    Text(\"Change priority to adjust position in queue. Lower priority number = higher importance.\")\n        .font(.caption)\n}\n```\n\n**Observation:** The Picker labels already make this clear:\n- \"High (1)\" - obviously high priority\n- \"Low (10)\" - obviously low priority\n\n**Proposed Fix:** Simplify footer to just explain the effect:\n```swift\nText(\"Sessions with higher priority appear first in the queue.\")\n    .font(.caption)\n```\n\nOr remove footer entirely since Picker labels are self-explanatory.","status":"open","priority":3,"issue_type":"task","created_at":"2025-12-09T21:45:20.714745-06:00","updated_at":"2025-12-09T21:45:20.714745-06:00","source_repo":".","labels":["ui-consistency"]}
{"id":"voice-code-priority-queue-5ds","content_hash":"f8b86255ab3415966edd52ae6defcbdee8a11af05d3b2a90238a5c1864d5c5e1","title":"SessionInfoView Priority Queue section hidden when not in queue reducing discoverability","description":"**File:** SessionInfoView.swift:72-112\n\n**Issue:** Priority Queue section only shows if `session.isInPriorityQueue == true`. User has no way to ADD session to priority queue from SessionInfoView - must navigate back and use ConversationView toolbar button.\n\n**Impact:** Poor discoverability and inconsistent UX. User opens session info expecting to manage priority queue membership but cannot.\n\n**Evidence:**\n```swift\n// SessionInfoView.swift:72\nif settings.priorityQueueEnabled \u0026\u0026 session.isInPriorityQueue {\n    Section { /* priority controls */ }\n}\n// ‚ùå No UI shown if NOT in queue\n```\n\n**Proposed Fix:** Show Priority Queue section whenever feature is enabled:\n```swift\nif settings.priorityQueueEnabled {\n    Section {\n        if session.isInPriorityQueue {\n            // Existing picker and order display\n        } else {\n            Button(\"Add to Priority Queue\") {\n                addToPriorityQueue(session)\n            }\n        }\n    }\n}\n```\n\n**Related:** voice-code-priority-queue-zp4 tracks same issue.","status":"closed","priority":2,"issue_type":"bug","created_at":"2025-12-09T21:45:10.130814-06:00","updated_at":"2025-12-10T09:47:40.426318-06:00","closed_at":"2025-12-10T09:47:40.426318-06:00","source_repo":".","labels":["ui-state"]}
{"id":"voice-code-priority-queue-5zd","content_hash":"07836057f87dbd67e7e182fd91a61367072b91a959ed6d04562e2f75d2ce1b67","title":"addToPriorityQueue relies on implicit CoreData default for priority without validation","description":"**Analysis:** CoreData schema default is reliable.\n\n**Current state:**\n- VoiceCode 2.xcdatamodel defines: priority defaultValueString='10'\n- CoreData guarantees default is applied on object creation\n- All CDBackendSession objects get priority=10 automatically\n\n**Why schema default is sufficient:**\n- CoreData applies defaults during object creation (not lazy)\n- Schema is compiled into app binary\n- Cannot be accidentally removed without breaking migration\n\n**Defensive coding trade-off:**\n- Adding validation checks adds complexity\n- Schema default is the standard CoreData pattern\n- Over-defensive code obscures actual invariants\n\n**Recommendation:** Downgrade to P4. Schema default is reliable, validation would be premature defensive coding.","status":"open","priority":4,"issue_type":"bug","created_at":"2025-12-09T22:17:30.56172-06:00","updated_at":"2025-12-10T10:06:38.619805-06:00","source_repo":".","labels":["data-integrity"]}
{"id":"voice-code-priority-queue-61z","content_hash":"819ee16a824a8e0a9721a418826dbb5db9e8092109bac48b7c2ed944b8f1908c","title":"DirectoryListView sort tiebreaker uses lexicographic UUID not chronological time","description":"**File:** DirectoryListView.swift:489\n\n**Issue:** Three-level sort uses `session1.id.uuidString \u003c session2.id.uuidString` for deterministic tiebreaker, but this is LEXICOGRAPHIC sort not chronological. UUID strings don't sort by creation time.\n\n**Impact:** \n- If two sessions have same priority (e.g., 5) and same priorityOrder (unlikely but possible due to race), sort by UUID string\n- Lexicographic sort means session with UUID \"123e4567-...\" comes before \"abc12345-...\"\n- NOT the same as \"session created first\"\n\n**Evidence:**\n```swift\n// DirectoryListView.swift:488-489\n// 3. Session ID (deterministic tiebreaker)\nreturn session1.id.uuidString \u003c session2.id.uuidString\n```\n\n**Example:**\n```\nSession A: UUID = \"f8a1b2c3-...\" (created Monday)\nSession B: UUID = \"12345678-...\" (created Tuesday)\n\nLexicographic sort: B \u003c A (\"1\" \u003c \"f\")\nChronological sort: A \u003c B (Monday \u003c Tuesday)\n```\n\n**Is This A Bug?** \n- **No** - UUIDs aren't meant to be chronologically sorted\n- Sort is deterministic and consistent, which is the goal\n- Users don't see or care about UUID order\n\n**Why This Matters:** \n- If priorityOrder collision occurs (race condition), sort order is non-intuitive\n- Documentation says \"FIFO within priority groups\" but UUID tiebreaker isn't FIFO\n\n**Proposed Fix (Optional):** Use lastModified or priorityQueuedAt for tiebreaker:\n```swift\n// 3. Queued timestamp (true FIFO)\nif let time1 = session1.priorityQueuedAt, let time2 = session2.priorityQueuedAt {\n    return time1 \u003c time2\n}\n// 4. Fallback to UUID\nreturn session1.id.uuidString \u003c session2.id.uuidString\n```\n\n**Related:** voice-code-priority-queue-8wl tracks this issue.","status":"open","priority":3,"issue_type":"bug","created_at":"2025-12-09T21:48:30.345432-06:00","updated_at":"2025-12-09T21:48:30.345432-06:00","source_repo":".","labels":["data-consistency"]}
{"id":"voice-code-priority-queue-63a","content_hash":"10167821bd931f1a0208e64cf05188248c454dacfa287b58ebf5b947fa2e0647","title":"Phase 2: Add/Remove - Implement addToPriorityQueue and removeFromPriorityQueue","description":"Implement core queue management functions and helper functions for priority queue.\n\nFILES TO MODIFY:\n- ios/VoiceCode/Views/ConversationView.swift\n\nFUNCTIONS TO IMPLEMENT:\n\n1. addToPriorityQueue(_ session: CDBackendSession)\n2. removeFromPriorityQueue(_ session: CDBackendSession)\n3. saveContext() - Helper for consistent error handling\n4. fetchMaxPriorityOrder(priority:) - Helper for changePriority\n\nIMPLEMENTATION DETAILS:\n\nFunction 1: addToPriorityQueue\nLocation: Add after existing addToQueue function (around line 793)\nLogic:\n- Guard: check if already in priority queue, return early if yes\n- Set isInPriorityQueue = true\n- Set priority = 10 (default priority level)\n- Set priorityQueuedAt = Date()\n- Calculate priorityOrder from timestamp: Date().timeIntervalSince1970\n- Use saveContext() helper to save\n- Log action for debugging\n\nPriorityOrder Calculation Note:\n- Uses Date().timeIntervalSince1970 (usually unique due to microsecond precision)\n- If collision occurs (rare), session ID tiebreaker ensures deterministic sort\n- See sorting task voice-code-priority-queue-880 for three-level sort implementation\n\nCode:\nfunc addToPriorityQueue(_ session: CDBackendSession) {\n    guard !session.isInPriorityQueue else { return }\n    \n    session.isInPriorityQueue = true\n    session.priority = 10  // Default priority\n    session.priorityQueuedAt = Date()\n    session.priorityOrder = session.priorityQueuedAt!.timeIntervalSince1970\n    \n    saveContext()\n    print(\"[PriorityQueue] Added session to priority queue: \\(session.name ?? \"unknown\")\")\n}\n\nFunction 2: removeFromPriorityQueue\nLocation: Add after addToPriorityQueue\nLogic:\n- Guard: check if in priority queue, return early if no\n- Set isInPriorityQueue = false\n- Reset priority = 10\n- Set priorityOrder = 0.0\n- Set priorityQueuedAt = nil\n- Use saveContext() helper to save\n- Log action for debugging\n\nCode:\nfunc removeFromPriorityQueue(_ session: CDBackendSession) {\n    guard session.isInPriorityQueue else { return }\n    \n    session.isInPriorityQueue = false\n    session.priority = 10\n    session.priorityOrder = 0.0\n    session.priorityQueuedAt = nil\n    \n    saveContext()\n    print(\"[PriorityQueue] Removed session from priority queue: \\(session.name ?? \"unknown\")\")\n}\n\nFunction 3: saveContext (NEW HELPER)\nLocation: Add near other queue management functions\nPurpose: Centralized error handling for CoreData saves\nLogic:\n- Try to save viewContext\n- Catch errors and log with descriptive message\n- Fail silently (don't crash app)\n\nCode:\nfunc saveContext() {\n    do {\n        try viewContext.save()\n    } catch {\n        print(\"[PriorityQueue] CoreData save failed: \\(error.localizedDescription)\")\n        // Fail silently - log error but don't crash\n        // Production: Consider analytics/error reporting\n    }\n}\n\nFunction 4: fetchMaxPriorityOrder (NEW HELPER)\nLocation: Add near other helper functions\nPurpose: Find maximum priorityOrder for sessions with given priority\nUsed by: changePriority function (Phase 3)\n\nCode:\nfunc fetchMaxPriorityOrder(priority: Int32) -\u003e Double {\n    let request: NSFetchRequest\u003cCDBackendSession\u003e = CDBackendSession.fetchRequest()\n    request.predicate = NSPredicate(\n        format: \"isInPriorityQueue == YES AND priority == %d\",\n        priority\n    )\n    let sessions = (try? viewContext.fetch(request)) ?? []\n    return sessions.map { $0.priorityOrder }.max() ?? 0.0\n}\n\nINTEGRATION WITH MESSAGE SENDING:\n\nLocation: In sendPrompt function (around line 558)\nAdd after existing queue logic:\n\n// Add to priority queue if enabled\nif settings.priorityQueueEnabled {\n    addToPriorityQueue(session)\n}\n\nIMPLEMENTATION STEPS:\n1. Open ConversationView.swift in Xcode\n2. Find existing queue functions (addToQueue, removeFromQueue)\n3. Add saveContext helper function\n4. Add fetchMaxPriorityOrder helper function\n5. Add addToPriorityQueue function (use saveContext)\n6. Add removeFromPriorityQueue function (use saveContext)\n7. Find sendPrompt function\n8. Locate existing addToQueue call\n9. Add addToPriorityQueue call after it\n10. Build project (Cmd+B)\n11. Fix any compilation errors\n12. Run app to verify no crashes\n\nVERIFICATION - Test Pyramid:\n\nUnit Tests (PriorityQueueManagementTests.swift):\n\nTest 1: testAddToPriorityQueue\n- Create test session\n- Call addToPriorityQueue\n- Assert isInPriorityQueue == true\n- Assert priority == 10\n- Assert priorityOrder \u003e 0\n- Assert priorityQueuedAt != nil\n- Assert priorityQueuedAt within last second\n\nTest 2: testAddToPriorityQueueIdempotent\n- Create session, add to priority queue\n- Note current priorityOrder and priorityQueuedAt\n- Call addToPriorityQueue again\n- Assert values unchanged (idempotent)\n\nTest 3: testRemoveFromPriorityQueue\n- Create session, add to priority queue\n- Call removeFromPriorityQueue\n- Assert isInPriorityQueue == false\n- Assert priority == 10 (reset)\n- Assert priorityOrder == 0.0\n- Assert priorityQueuedAt == nil\n\nTest 4: testRemoveFromPriorityQueueWhenNotInQueue\n- Create session (not in queue)\n- Call removeFromPriorityQueue\n- Assert no crash\n- Assert fields remain default\n\nTest 5: testPriorityOrderUniqueness\n- Create 10 sessions\n- Add all to priority queue rapidly\n- Fetch all sessions, sort by priorityOrder\n- Assert no duplicate priorityOrder values (or very rare)\n- Assert ascending order\n\nTest 6: testSaveContextErrorHandling (NEW)\n- Mock CoreData context to fail on save\n- Call addToPriorityQueue\n- Verify error logged (check console output)\n- Verify app doesn't crash\n\nTest 7: testFetchMaxPriorityOrder (NEW)\n- Create 3 sessions with priority=10, priorityOrder: 5, 15, 10\n- Call fetchMaxPriorityOrder(priority: 10)\n- Assert returns 15.0\n- Call with priority=20 (no sessions)\n- Assert returns 0.0\n\nIntegration Tests:\n\nTest 8: testAddToPriorityQueuePersistence\n- Create session, add to priority queue\n- Save context\n- Create new context, fetch session\n- Assert isInPriorityQueue still true\n- Assert all fields preserved\n\nManual Verification:\n1. Run app on simulator\n2. Create new session or use existing\n3. Send a message (voice or text)\n4. Use debugger breakpoint in addToPriorityQueue\n5. Step through function\n6. Inspect session object in debugger:\n   po session.isInPriorityQueue  // true\n   po session.priority  // 10\n   po session.priorityOrder  // large number\n7. Continue execution\n8. Check Xcode console for log message\n9. Use CoreData debugger to verify persistence\n\nACCEPTANCE CRITERIA:\n‚úÖ addToPriorityQueue function implemented\n‚úÖ removeFromPriorityQueue function implemented\n‚úÖ saveContext helper implemented with error logging\n‚úÖ fetchMaxPriorityOrder helper implemented\n‚úÖ All helpers use consistent error handling\n‚úÖ Functions integrated with sendPrompt\n‚úÖ All 8 unit tests pass\n‚úÖ CoreData saves succeed\n‚úÖ Logging statements added\n‚úÖ Error handling implemented (no crashes on save failure)\n‚úÖ Functions are idempotent (safe to call multiple times)\n‚úÖ No crashes with nil sessions\n‚úÖ priorityOrder values are unique (or tiebreaker handles collisions)\n‚úÖ PriorityOrder timestamp collision documented","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-07T17:55:48.204102-06:00","updated_at":"2025-12-09T20:05:44.390252-06:00","closed_at":"2025-12-09T20:05:44.390252-06:00","source_repo":".","dependencies":[{"issue_id":"voice-code-priority-queue-63a","depends_on_id":"voice-code-priority-queue-rd6","type":"blocks","created_at":"2025-12-07T17:59:19.890151-06:00","created_by":"travisbrown"}]}
{"id":"voice-code-priority-queue-6bx","content_hash":"1462a6a45e427db5ce0e599d971e213fde4c13fcf3fc28d564be90f476fb77e2","title":"addToPriorityQueue doesn't trigger cache update in DirectoryListView","description":"DirectoryListView.addToPriorityQueue (line 554) calls saveContext() but doesn't call updateCachedPriorityQueueSessions() unlike removeFromPriorityQueue (line 579) and changePriority (line 604). Newly added session won't appear in Priority Queue section until next cache trigger (count change, lock change, etc). Fix: Add updateCachedPriorityQueueSessions() after saveContext() on line 566.","status":"closed","priority":1,"issue_type":"bug","created_at":"2025-12-09T21:17:24.909907-06:00","updated_at":"2025-12-09T22:32:35.672985-06:00","closed_at":"2025-12-09T22:32:35.672985-06:00","source_repo":"."}
{"id":"voice-code-priority-queue-6ct","content_hash":"92091f839578d5b29af7121fcaf1248f8afb82ce9ddafcdcd1dd78325c20db20","title":"Phase 4: Tests - Verify auto-add from workstation sessions","description":"Tests for auto-add from workstation sessions.\n\nFILE TO MODIFY:\n- ios/VoiceCodeTests/PriorityQueueManagementTests.swift\n\nTESTS TO ADD:\n\n1. testAutoAddFromSessionCreated\n   - Mock session_created WebSocket message\n   - Mock settings.priorityQueueEnabled = true\n   - Call VoiceCodeClient.handleMessage\n   - Assert session added to priority queue\n   - Assert priority = 10, priorityOrder \u003e 0\n\n2. testAutoAddOnlyWhenEnabled\n   - Mock session_created message\n   - Set priorityQueueEnabled = false\n   - Call handleMessage\n   - Assert session NOT added to priority queue\n\n3. testAutoAddIdempotent\n   - Session already in priority queue\n   - Receive session_created again\n   - Assert priorityOrder unchanged (not re-added)\n\n4. testAutoAddMultipleSessions\n   - Send 5 session_created messages\n   - Assert all 5 added to priority queue\n   - Assert all have priority = 10\n   - Assert priorityOrder values unique\n\n5. testAutoAddWithDelayedNotification\n   - Simulate backend delayed notification pattern\n   - Session created but 0 messages ‚Üí not notified\n   - Session gets messages ‚Üí session_created sent\n   - Assert session added to priority queue\n\nACCEPTANCE CRITERIA:\n‚úÖ All 5 tests pass\n‚úÖ Mock WebSocket messages correctly\n‚úÖ Test both enabled and disabled states\n‚úÖ Verify idempotency\n‚úÖ Cover edge cases","status":"closed","priority":3,"issue_type":"task","created_at":"2025-12-07T17:57:43.810001-06:00","updated_at":"2025-12-10T18:34:13.977817-06:00","closed_at":"2025-12-10T18:34:13.977817-06:00","source_repo":".","dependencies":[{"issue_id":"voice-code-priority-queue-6ct","depends_on_id":"voice-code-priority-queue-7op","type":"blocks","created_at":"2025-12-07T17:59:33.996342-06:00","created_by":"travisbrown"}]}
{"id":"voice-code-priority-queue-6gi","content_hash":"0b7afc990018b86b7e189fe7d4dd1290a10419e158512d78a44a1bea9ae69494","title":"UUID comparison in sort doesn't lowercase for consistency","description":"DirectoryListView line 489 uses 'session1.id.uuidString \u003c session2.id.uuidString' without lowercasing. While UUID comparison works regardless of case (UUIDs from same source have same case), this is inconsistent with project standard (STANDARDS.md requires lowercase UUIDs). For consistency with lines 475, 82, etc., should use .lowercased(). Low priority - functionality not affected.","status":"open","priority":3,"issue_type":"bug","created_at":"2025-12-09T21:22:26.307853-06:00","updated_at":"2025-12-09T21:22:26.307853-06:00","source_repo":"."}
{"id":"voice-code-priority-queue-6iw","content_hash":"6bfac8a696e3eece92569af896a8447f93e15c1eb09d888d721c3706b110f499","title":"SessionInfoView Priority Order field shows confusing implementation detail","description":"**File:** SessionInfoView.swift:88-94\n\n**Issue:** Priority Order is displayed as floating-point number with 1 decimal place (\"1.0\", \"2.0\") but these are internal implementation details not meaningful to users.\n\n**Impact:** Confusing UI - users don't understand what \"Order: 2.0\" means or why it has a decimal. Priority order is FIFO sequencing within priority groups, but UI doesn't explain this.\n\n**Evidence:**\n```swift\n// SessionInfoView.swift:88-94\nHStack {\n    Text(\"Order\")\n        .foregroundColor(.secondary)\n    Spacer()\n    Text(String(format: \"%.1f\", session.priorityOrder))\n        .foregroundColor(.primary)\n}\n```\n\n**Proposed Fixes:**\n1. **Hide Order field entirely** (it's redundant - sort position is what matters)\n2. **Show position in queue** instead: \"Position: 3rd of 10\"\n3. **Add explanatory label**: \"Order in Priority Group: 2.0\" or \"FIFO Order: 2.0\"\n4. **Format as integer** if decimal is always .0: \"Order: 2\"\n\n**Recommendation:** Option 1 or 2 - showing internal priorityOrder adds no user value.","status":"open","priority":3,"issue_type":"bug","created_at":"2025-12-09T21:45:16.66967-06:00","updated_at":"2025-12-09T21:45:16.66967-06:00","source_repo":".","labels":["ui-polish"]}
{"id":"voice-code-priority-queue-6lp","content_hash":"23ca70822c9c70bb9830f1f5fd41ecc66ca78b3664f45ca70d0c26390bd53a3b","title":"Verify PersistenceController migration logging captures success/failure","description":"**Analysis:** CoreData automatic migration doesn't provide separate success callback.\n\n**Current state:**\n- Line 100 logs success: 'CoreData store loaded: \u003cpath\u003e'\n- Line 69 logs failure: 'CoreData failed to load: \u003cerror\u003e'\n- Lines 71-98 handle recovery attempts\n\n**Migration behavior:**\nCoreData lightweight migration is automatic and invisible:\n- If migration succeeds, loadPersistentStores completes normally (line 100)\n- If migration fails, error callback fires (line 68)\n\n**Enhancement option (low priority):**\nCould detect migration by checking model version before/after, but adds complexity for rare diagnostic need.\n\n**Recommendation:** Downgrade to P4. Current logging is sufficient for normal operation.","status":"open","priority":4,"issue_type":"task","created_at":"2025-12-09T21:12:03.381631-06:00","updated_at":"2025-12-10T09:40:02.530719-06:00","source_repo":"."}
{"id":"voice-code-priority-queue-6n6","content_hash":"a9a48be51ae8508000f4822429e75b67dd73dddaf6f5c4343d0ca05fa2732312","title":"Comment says 'Keep existing priority' but code never initializes new session priority","description":"addToPriorityQueue comment (DirectoryListView:559, ConversationView:901) says 'Keep existing priority (default 10)'. But new CDBackendSession objects get priority from CoreData default value (10). Comment implies code sets it, but doesn't. Clarify comment: 'Uses session's current priority (default 10 from CoreData schema for new sessions, or user-modified value for existing sessions)'.","status":"open","priority":3,"issue_type":"task","created_at":"2025-12-09T21:29:17.194446-06:00","updated_at":"2025-12-09T21:29:17.194446-06:00","source_repo":".","labels":["documentation"]}
{"id":"voice-code-priority-queue-6pk","content_hash":"c5370004f95e4087b7e2ff95af8c58f93a5251b73cadaccc61b277a139388e9e","title":"ConversationView priority queue buttons may not update when settings change","description":"**Analysis:** Likely not a bug - SwiftUI handles @ObservedObject updates.\n\n**Current implementation:**\n- settings is @ObservedObject AppSettings\n- AppSettings has @Published priorityQueueEnabled\n- SwiftUI re-renders when @Published properties change\n\n**Why it should work:**\n1. User toggles setting in SettingsView\n2. AppSettings.priorityQueueEnabled publishes change\n3. ConversationView re-renders due to @ObservedObject\n4. Toolbar buttons re-evaluated\n\n**When it might fail:**\n- SwiftUI toolbar caching (rare, usually fixed in iOS updates)\n- View not in hierarchy during change\n- @ObservedObject not properly configured\n\n**Verification needed:** Manual test to confirm behavior.\n\n**Recommendation:** Downgrade to P4. Likely non-issue, verify before fixing.","status":"open","priority":4,"issue_type":"bug","created_at":"2025-12-09T21:56:03.614375-06:00","updated_at":"2025-12-10T09:53:50.979273-06:00","source_repo":".","labels":["state-management"]}
{"id":"voice-code-priority-queue-6vh","content_hash":"4942c8afa2f49ebb0b1e2c53e6dcebfeed8229769a5a74ef94b0e0170465f1cf","title":"Add error logging to fetchMaxPriorityOrder instead of silent try?","description":"fetchMaxPriorityOrder in all 3 files uses 'try? viewContext.fetch(request) ?? []' which silently swallows errors. Failed fetches return empty array causing incorrect priorityOrder=1.0. Fix: Replace with do-catch and log errors with logger.error().","status":"closed","priority":1,"issue_type":"bug","created_at":"2025-12-09T20:59:39.519577-06:00","updated_at":"2025-12-09T22:32:35.673218-06:00","closed_at":"2025-12-09T22:32:35.673218-06:00","source_repo":".","labels":["code-quality"]}
{"id":"voice-code-priority-queue-6vx","content_hash":"57559de07fbf26559f9fd853ea9fbf87332f164a806e3e3a4fd6819f7c09648b","title":"Phase 2: UI - Add Priority Queue section to DirectoryListView","description":"Add Priority Queue section to DirectoryListView with swipe-to-delete functionality.\n\nFILES TO MODIFY:\n- ios/VoiceCode/Views/DirectoryListView.swift\n\nLOCATION:\nAdd section between \"Recent\" and \"Projects\" sections (around line 187)\n\nUI STRUCTURE:\n\nSection(isExpanded: $isPriorityQueueExpanded) {\n    ForEach(priorityQueueSessions) { session in\n        // Session row content\n    }\n    .swipeActions(edge: .trailing, allowsFullSwipe: true) {\n        // Remove button\n    }\n} header: {\n    Text(\"Priority Queue\")\n}\n\nCONDITIONAL RENDERING (UPDATED - With Comment):\n\nShow section only if:\n1. settings.priorityQueueEnabled == true\n2. priorityQueueSessions.isEmpty == false\n\nCode (UPDATED):\n// Only show section when enabled AND queue has sessions\n// Rationale: Avoid visual clutter when queue unused (matches existing queue behavior)\nif settings.priorityQueueEnabled \u0026\u0026 !priorityQueueSessions.isEmpty {\n    // Section content\n}\n\nIMPLEMENTATION DETAILS:\n\n1. Section Header:\n   - Text: \"Priority Queue\"\n   - Use isExpanded binding for collapsible section\n   - Default: expanded (isPriorityQueueExpanded = true)\n\n2. Session Row:\n   - Use NavigationLink(value: session.id)\n   - Use CDBackendSessionRowContent(session: session)\n   - Same display as Recent and Projects sections\n\n3. Swipe Actions:\n   - Edge: trailing\n   - Allow full swipe: true\n   - Button role: destructive\n   - Label: \"Remove\" with xmark.circle icon\n   - Action: Call removeFromPriorityQueue(session)\n\n4. Priority Badge (Optional - Phase 6):\n   - Overlay on session row\n   - Shows \"P\\(session.priority)\"\n   - Trailing alignment\n   - See task voice-code-priority-queue-2wv for implementation\n\nCOMPLETE CODE:\n\n// Only show section when enabled AND queue has sessions\n// Rationale: Avoid visual clutter when queue unused (matches existing queue behavior)\nif settings.priorityQueueEnabled \u0026\u0026 !priorityQueueSessions.isEmpty {\n    Section(isExpanded: $isPriorityQueueExpanded) {\n        ForEach(priorityQueueSessions) { session in\n            NavigationLink(value: session.id) {\n                CDBackendSessionRowContent(session: session)\n            }\n            .swipeActions(edge: .trailing, allowsFullSwipe: true) {\n                Button(role: .destructive) {\n                    removeFromPriorityQueue(session)\n                } label: {\n                    Label(\"Remove\", systemImage: \"xmark.circle\")\n                }\n            }\n        }\n    } header: {\n        Text(\"Priority Queue\")\n    }\n}\n\nEMPTY QUEUE DISPLAY BEHAVIOR (CLARIFICATION):\n- When enabled but queue is empty: Section hidden (cleaner UI)\n- User discovers feature via:\n  - Settings description text\n  - Auto-add from workstation\n  - Manual add button in toolbar\n- Alternative considered: Show \"No sessions in priority queue\" message when empty\n  - Rejected: Adds visual clutter when feature unused\n- Matches existing queue behavior (hide when empty)\n\nIMPLEMENTATION STEPS:\n1. Open DirectoryListView.swift\n2. Find Recent section (around line 168)\n3. Add Priority Queue section after Recent section\n4. Use conditional: settings.priorityQueueEnabled \u0026\u0026 !priorityQueueSessions.isEmpty\n5. Add comment explaining isEmpty check rationale\n6. Copy structure from existing queue section\n7. Update bindings to use priorityQueueSessions\n8. Update swipe action to call removeFromPriorityQueue\n9. Build project (Cmd+B)\n10. Fix any compilation errors\n\nVERIFICATION - Test Pyramid:\n\nUnit Tests:\n\n1. testPriorityQueueSectionVisibility\n   - Set priorityQueueEnabled = true\n   - Add sessions to priority queue\n   - Assert section renders\n   - Remove all sessions\n   - Assert section hidden (isEmpty check)\n\n2. testPriorityQueueSectionHiddenWhenDisabled\n   - Add sessions to priority queue\n   - Set priorityQueueEnabled = false\n   - Assert section hidden\n\n3. testSwipeActionRemovesSession\n   - Add session to priority queue\n   - Simulate swipe action\n   - Call remove button action\n   - Assert session.isInPriorityQueue == false\n\nIntegration Tests:\n\n4. testPriorityQueueSessionsOrdered\n   - Add 5 sessions with different priorities\n   - Render DirectoryListView\n   - Assert sessions appear in correct order\n   - Verify sorted by priority ascending\n\nManual Verification:\n1. Enable priority queue in settings\n2. Navigate to Projects view\n3. Verify \"Priority Queue\" section appears below \"Recent\"\n4. Add 3 sessions with different priorities\n5. Verify sessions appear in priority order\n6. Swipe session left\n7. Verify \"Remove\" button appears\n8. Tap Remove\n9. Verify session disappears from queue\n10. Remove all sessions\n11. Verify section disappears (empty queue hidden)\n12. Add session back\n13. Verify section reappears\n14. Disable priority queue in settings\n15. Verify section disappears immediately\n\nVisual Verification:\n1. Section header matches existing sections style\n2. Session rows look identical to Recent/Projects\n3. Swipe animation smooth\n4. Remove button red (destructive role)\n5. Section collapsible (tap header to expand/collapse)\n6. Works in both light and dark mode\n\nACCEPTANCE CRITERIA:\n‚úÖ Priority Queue section added to DirectoryListView\n‚úÖ Section positioned between Recent and Projects\n‚úÖ Conditional rendering: enabled \u0026\u0026 !isEmpty\n‚úÖ Empty queue rationale comment added\n‚úÖ Uses priorityQueueSessions binding\n‚úÖ Uses isPriorityQueueExpanded binding\n‚úÖ Swipe-to-delete implemented\n‚úÖ Remove button calls removeFromPriorityQueue\n‚úÖ NavigationLink navigates to conversation\n‚úÖ Section hidden when disabled\n‚úÖ Section hidden when empty (with rationale comment)\n‚úÖ All unit tests pass\n‚úÖ Manual verification succeeds\n‚úÖ UI matches existing sections style\n\nACCESSIBILITY:\n- Section header has implicit VoiceOver label\n- Swipe actions work with VoiceOver (double-tap to reveal actions)\n- Remove button label announced: \"Remove\"\n- See task voice-code-priority-queue-9yb for comprehensive accessibility\n\nDependencies (1):\n  [blocks] voice-code-priority-queue-880 (open): Phase 2: Sorting - Implement priority queue sorting logic in DirectoryListView [P1]\n\nDependents (4):\n  [blocks] voice-code-priority-queue-euo (open): Phase 2: Integration Test - End-to-end priority queue workflow [P1]\n  [blocks] voice-code-priority-queue-516 (open): Phase 2: Tests - Write unit tests for add/remove and sorting [P1]\n  [blocks] voice-code-priority-queue-9h5 (open): Phase 5: Drag to Reorder - Implement drag gesture handling [P4]\n  [blocks] voice-code-priority-queue-2wv (open): Phase 6: UI Polish - Add optional priority badges [P4]","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-07T17:56:16.263138-06:00","updated_at":"2025-12-09T20:19:50.404443-06:00","closed_at":"2025-12-09T20:19:50.404443-06:00","source_repo":".","dependencies":[{"issue_id":"voice-code-priority-queue-6vx","depends_on_id":"voice-code-priority-queue-880","type":"blocks","created_at":"2025-12-07T17:59:20.654473-06:00","created_by":"travisbrown"}]}
{"id":"voice-code-priority-queue-6yi","content_hash":"60605e672508d5c742e4937e5c0ed2632ef3f090cafd0e416c26be01c390cb41","title":"No validation that session parameter is not faulted before accessing properties","description":"addToPriorityQueue, changePriority access session.priority (lines 561, 590) without checking if session is faulted. If session passed from stale reference after context reset, accessing properties could trigger fault and return incorrect values or fault error. Add session.isFault check or refresh: if session.isFault { viewContext.refresh(session, mergeChanges: false) }. Low risk with current usage.","status":"open","priority":3,"issue_type":"bug","created_at":"2025-12-09T21:28:17.211844-06:00","updated_at":"2025-12-09T21:28:17.211844-06:00","source_repo":"."}
{"id":"voice-code-priority-queue-70z","content_hash":"720f354ac1f74b864098024ec0bf339d3e49fa35845058ed32ea26d7d91f1c06","title":"ConversationView add to priority queue button provides no visual feedback","description":"**File:** ConversationView.swift:343-348\n\n**Issue:** Add to priority queue button shows star.fill icon but provides no visual feedback when tapped. User must navigate away to see session appear in Priority Queue section.\n\n**Impact:** Unclear whether action succeeded:\n- User taps star button\n- Nothing happens visually in ConversationView\n- Must go back to DirectoryListView to verify session was added\n- Poor immediate feedback\n\n**Evidence:**\n```swift\n// ConversationView.swift:343-348\nButton(action: {\n    addToPriorityQueue(session)  // Silent action\n}) {\n    Image(systemName: \"star.fill\")\n        .foregroundColor(.purple)\n}\n```\n\nNo confirmation shown after successful add.\n\n**Proposed Enhancements:**\n\n1. **Show confirmation banner** (like copy confirmation):\n```swift\nButton(action: {\n    addToPriorityQueue(session)\n    showConfirmation(\"Added to Priority Queue\")\n}) {\n    Image(systemName: \"star.fill\")\n}\n```\n\n2. **Button icon changes** to star.slash.fill immediately (optimistic UI)\n\n3. **Haptic feedback:**\n```swift\nButton(action: {\n    let generator = UIImpactFeedbackGenerator(style: .medium)\n    generator.impactOccurred()\n    addToPriorityQueue(session)\n}) {\n    Image(systemName: \"star.fill\")\n}\n```\n\n4. **Toast notification** with undo option\n\n**Note:** Similar issue for remove button (star.slash.fill) - also no feedback.\n\n**Related:** voice-code-priority-queue-ccy [P3] tracks adding haptic feedback for priority queue operations.","status":"open","priority":4,"issue_type":"bug","created_at":"2025-12-09T21:56:12.108243-06:00","updated_at":"2025-12-09T21:56:12.108243-06:00","source_repo":".","labels":["ux"]}
{"id":"voice-code-priority-queue-72z","content_hash":"13e997709c23818f0a022baebc8c79fa98f017952ab0aba54736ffdd59c1e005","title":"Add safeguard against Double.infinity or NaN in priorityOrder","description":"priorityOrder calculated as maxOrder + 1.0. If corruption causes maxOrder to be Double.infinity or NaN (from .max() on corrupt data), all subsequent sessions get infinite/NaN order. Add validation: if maxOrder.isInfinite || maxOrder.isNaN, reset to 0.0 and log error. Defensive programming for data integrity.","status":"open","priority":3,"issue_type":"bug","created_at":"2025-12-09T21:12:12.212402-06:00","updated_at":"2025-12-09T21:12:12.212402-06:00","source_repo":"."}
{"id":"voice-code-priority-queue-7c4","content_hash":"a92a4ea9fc8dfbcabd553eaba9080e73ef23f9f61fc2668709fcf52616b37535","title":"Add validation that session.priority stays in sync with actual queue membership","description":"If session has priority=5 but isInPriorityQueue=false, it retains priority value. When re-added, uses stale priority instead of default 10. Consider resetting priority to default whenever isInPriorityQueue becomes false, or document that priority is preserved across add/remove cycles.","status":"closed","priority":2,"issue_type":"bug","created_at":"2025-12-09T21:10:52.999905-06:00","updated_at":"2025-12-10T09:37:51.939-06:00","closed_at":"2025-12-10T09:37:51.939-06:00","source_repo":"."}
{"id":"voice-code-priority-queue-7i1","content_hash":"2c51fe38d92933f209baacfa09ba9a2268b4a1006488d76bc5ae6a4c22c9ab69","title":"SessionInfoView Picker shows wrong value if changePriority validation fails","description":"**Analysis:** Partially mitigated by shared extension rollback.\n\n**Current behavior:**\n1. Picker binding get reads session.priority directly (line 76)\n2. changePriority() in shared extension does rollback on failure (lines 113-114)\n3. After rollback, Picker's get returns original value\n4. Guard session.isInPriorityQueue hides section if removed (line 72)\n\n**Remaining edge case:**\nSwiftUI may cache Picker selection in between get calls. If changePriority fails mid-execution:\n1. User taps priority 5\n2. SwiftUI updates Picker UI to show 5 selected\n3. changePriority fails and rolls back to 10\n4. Picker still shows 5 until next render\n\n**Impact:** Very minor - resolves on next SwiftUI render cycle (navigation, scroll, etc).\n\n**Recommendation:** Downgrade to P4. Edge case requires: validation failure + no UI refresh + user notices inconsistency.","status":"open","priority":4,"issue_type":"bug","created_at":"2025-12-09T21:45:24.087714-06:00","updated_at":"2025-12-10T09:46:25.828731-06:00","source_repo":".","labels":["ux"]}
{"id":"voice-code-priority-queue-7oi","content_hash":"18ac89a7561539255f3ae08c8a1654dafaabe79e480ed088eb0b2e407572a33c","title":"fetchMaxPriorityOrder returns 0.0 for both empty and error cases","description":"**File:** DirectoryListView.swift:546-551, ConversationView.swift:962-967, SessionInfoView.swift:262-267\n\n**Issue:** fetchMaxPriorityOrder() returns 0.0 as both \"no sessions found\" and \"error occurred\". Caller cannot distinguish between empty priority group vs CoreData failure.\n\n**Impact:**\n- Silent degradation on CoreData errors\n- Cannot implement proper error recovery\n- Monitoring/alerting cannot detect CoreData issues\n- priorityOrder = 0.0 + 1.0 = 1.0 could be wrong value\n\n**Evidence:**\n```swift\n// All three implementations:\nprivate func fetchMaxPriorityOrder(priority: Int32) -\u003e Double {\n    let request: NSFetchRequest\u003cCDBackendSession\u003e = CDBackendSession.fetchRequest()\n    request.predicate = NSPredicate(format: \"isInPriorityQueue == YES AND priority == %d\", priority)\n    let sessions = (try? viewContext.fetch(request)) ?? []  // ‚ùå Error returns []\n    return sessions.map { $0.priorityOrder }.max() ?? 0.0  // ‚ùå Empty also returns 0.0\n}\n```\n\n**Ambiguous Return Value:**\n- Case 1: No sessions in priority group ‚Üí returns 0.0 ‚úì (correct)\n- Case 2: CoreData fetch error ‚Üí returns 0.0 ‚ùå (should propagate error)\n- Case 3: Sessions exist but all have priorityOrder = 0.0 ‚Üí returns 0.0 ‚ö†Ô∏è (edge case)\n\n**Proposed Fix - Option 1:** Throw errors:\n```swift\nprivate func fetchMaxPriorityOrder(priority: Int32) throws -\u003e Double {\n    let request: NSFetchRequest\u003cCDBackendSession\u003e = CDBackendSession.fetchRequest()\n    request.predicate = NSPredicate(format: \"isInPriorityQueue == YES AND priority == %d\", priority)\n    let sessions = try viewContext.fetch(request)  // ‚úÖ Propagate error\n    return sessions.map { $0.priorityOrder }.max() ?? 0.0\n}\n```\n\n**Proposed Fix - Option 2:** Return Result type:\n```swift\nprivate func fetchMaxPriorityOrder(priority: Int32) -\u003e Result\u003cDouble, Error\u003e {\n    let request: NSFetchRequest\u003cCDBackendSession\u003e = CDBackendSession.fetchRequest()\n    request.predicate = NSPredicate(format: \"isInPriorityQueue == YES AND priority == %d\", priority)\n    \n    do {\n        let sessions = try viewContext.fetch(request)\n        return .success(sessions.map { $0.priorityOrder }.max() ?? 0.0)\n    } catch {\n        return .failure(error)\n    }\n}\n\n// Caller:\nswitch fetchMaxPriorityOrder(priority: session.priority) {\ncase .success(let maxOrder):\n    session.priorityOrder = maxOrder + 1.0\ncase .failure(let error):\n    logger.error(\"Failed to fetch max order: \\(error)\")\n    // Handle error appropriately\n}\n```\n\n**Related:** voice-code-priority-queue-6vh [P1] tracks adding error logging to fetchMaxPriorityOrder.","status":"closed","priority":3,"issue_type":"bug","created_at":"2025-12-09T22:07:55.400228-06:00","updated_at":"2025-12-10T09:57:24.598323-06:00","closed_at":"2025-12-10T09:57:24.598323-06:00","source_repo":".","labels":["data-validation"]}
{"id":"voice-code-priority-queue-7op","content_hash":"2f0e5072e28966d92d28bf30667eac153d9f9833c446d2e30f343a4448335268","title":"Phase 4: Backend Integration - Auto-add sessions from session_created messages","description":"Auto-add sessions to priority queue when backend sends session_created messages.\n\nFILES TO MODIFY:\n- ios/VoiceCode/Managers/VoiceCodeClient.swift\n\nIMPLEMENTATION:\nIn handleMessage function, update session_created case:\n\ncase \"session_created\":\n    // IMPORTANT: Call sessionSyncManager FIRST to create CoreData entity\n    sessionSyncManager.handleSessionCreated(json)\n    \n    // NEW: Auto-add to priority queue if enabled\n    if settings.priorityQueueEnabled,\n       let sessionId = json[\"session_id\"] as? String {\n        addSessionToPriorityQueue(sessionId: sessionId)\n    }\n\nHelper function to add (UPDATED - UUID Validation):\nprivate func addSessionToPriorityQueue(sessionId: String) {\n    // Defensive programming: validate UUID before force unwrap\n    guard let uuid = UUID(uuidString: sessionId) else {\n        print(\"[PriorityQueue] Invalid UUID format: \\(sessionId)\")\n        return  // Fail gracefully, don't crash\n    }\n    \n    viewContext.perform {\n        let request: NSFetchRequest\u003cCDBackendSession\u003e = CDBackendSession.fetchRequest()\n        request.predicate = NSPredicate(format: \"id == %@\", uuid)\n        \n        guard let session = try? viewContext.fetch(request).first else {\n            print(\"[PriorityQueue] Session not found for auto-add: \\(sessionId)\")\n            return  // Fail silently, don't crash\n        }\n        \n        // Idempotent: If already in queue, do nothing\n        guard !session.isInPriorityQueue else { return }\n        \n        session.isInPriorityQueue = true\n        session.priority = 10\n        session.priorityQueuedAt = Date()\n        session.priorityOrder = session.priorityQueuedAt!.timeIntervalSince1970\n        \n        do {\n            try viewContext.save()\n        } catch {\n            print(\"[PriorityQueue] Failed to save after auto-add: \\(error)\")\n        }\n    }\n}\n\nUUID VALIDATION (NEW REQUIREMENT):\n- Backend should always send valid UUIDs\n- Defensive programming prevents crash if invalid UUID received\n- Guard statement validates UUID format before using\n- Log error and fail gracefully (no crash)\n- Fifth design review identified this as potential crash risk\n\nRACE CONDITION MITIGATION (CRITICAL):\n- sessionSyncManager.handleSessionCreated() runs FIRST\n- This creates/updates CoreData entity\n- THEN addSessionToPriorityQueue() runs\n- Sequential execution guarantees entity exists\n- Fallback: If session not found, fail silently and log error\n\nNETWORK DISCONNECTION HANDLING (NEW):\n\nScenario:\n- WebSocket disconnected\n- Workstation session created (backend detects)\n- session_created message cannot be sent\n- WebSocket reconnects\n\nCurrent Behavior:\n- Backend sends recent_sessions on reconnection\n- SessionSyncManager creates/updates CoreData entities\n- BUT: No auto-add happens (session_created event not sent)\n\nLimitation: Sessions created during disconnect won't auto-add to priority queue.\n\nWorkaround: User can manually add missed sessions via toolbar button.\n\nFuture Enhancement Consideration:\nImplement \"catch-up\" logic:\n1. On reconnection, compare recent_sessions against local sessions\n2. Identify new sessions created during disconnect (check priorityQueuedAt == nil)\n3. Auto-add to priority queue if enabled\n\nMVP Decision: Accept limitation. Impact is low:\n- Disconnections are rare\n- Manual add available as fallback\n- Only affects sessions created during disconnect window (typically seconds)\n\nVERIFICATION:\n\nUnit Tests:\n1. testAutoAddWhenEnabled\n   - Mock session_created message\n   - Set priorityQueueEnabled = true\n   - Trigger handleMessage\n   - Assert session added to priority queue\n\n2. testAutoAddSkippedWhenDisabled\n   - Mock session_created message\n   - Set priorityQueueEnabled = false\n   - Trigger handleMessage\n   - Assert session NOT added to priority queue\n\n3. testAutoAddIdempotent\n   - Add session to priority queue manually\n   - Mock session_created for same session\n   - Trigger handleMessage\n   - Assert priority/order unchanged (not re-added)\n\n4. testAutoAddRaceConditionHandling\n   - Mock session_created before SessionSyncManager creates entity\n   - Verify sequential execution (sync manager first)\n   - Assert entity exists before auto-add attempts\n\n5. testAutoAddInvalidUUID (NEW)\n   - Mock session_created with invalid UUID string\n   - Trigger handleMessage\n   - Assert no crash\n   - Verify error logged to console\n   - Assert graceful failure\n\n6. testAutoAddMalformedUUID (NEW)\n   - Mock session_created with malformed UUID\n   - Verify guard statement catches it\n   - Assert app continues running\n   - Assert error message contains invalid UUID value\n\nIntegration Tests:\n7. testAutoAddFromWorkstation\n   - Mock WebSocket connection\n   - Send session_created message\n   - Verify session appears in priority queue within 5 seconds\n   - Verify priority = 10, priorityOrder \u003e 0\n\n8. testDisconnectDuringSessionCreation (NEW)\n   - Disconnect WebSocket\n   - Create workstation session (mock)\n   - Reconnect WebSocket\n   - Verify session NOT auto-added (limitation)\n   - Manually add session\n   - Verify manual add works\n\nManual Test:\n1. Enable priority queue in iOS\n2. Start Claude CLI on workstation\n3. Send prompt via terminal\n4. Wait 5 seconds\n5. Check iOS app - session appears in priority queue\n6. Verify priority = 10\n7. Verify positioned at end of P10 group\n8. Send another prompt to same session\n9. Verify session NOT re-added (stays at original position)\n10. Disconnect WiFi/network\n11. Create new workstation session\n12. Reconnect network\n13. Verify session appears in Projects but NOT in priority queue\n14. Manually add via toolbar button\n15. Verify manual add succeeds\n\nManual Test - Invalid UUID (NEW):\n1. Use network proxy to inject malformed session_created message\n2. Set session_id to invalid UUID format\n3. Verify app doesn't crash\n4. Check console for error log\n5. Verify other functionality continues working\n\nACCEPTANCE CRITERIA:\n‚úÖ Auto-add triggered by session_created message\n‚úÖ Only when priorityQueueEnabled = true\n‚úÖ Sequential execution: SessionSyncManager first, then auto-add\n‚úÖ Default priority 10 assigned\n‚úÖ Sessions from workstation appear in \u003c5 seconds (when connected)\n‚úÖ Idempotent: no duplicate adds\n‚úÖ UUID validation prevents crash on invalid format\n‚úÖ Graceful failure if session not found (log error, don't crash)\n‚úÖ Graceful failure if UUID invalid (log error, don't crash)\n‚úÖ Network disconnection limitation documented\n‚úÖ Manual add workaround available\n‚úÖ All unit tests pass (including UUID validation tests)\n‚úÖ Integration test passes\n‚úÖ Manual workstation test succeeds\n‚úÖ Manual invalid UUID test succeeds (no crash)\n\nKNOWN LIMITATIONS:\n‚ùå Sessions created during WebSocket disconnect won't auto-add\n‚úÖ User can manually add missed sessions\n‚úÖ Limitation documented in design doc Section 18","status":"closed","priority":3,"issue_type":"task","created_at":"2025-12-07T17:57:33.627033-06:00","updated_at":"2025-12-10T18:34:13.57179-06:00","closed_at":"2025-12-10T18:34:13.57179-06:00","source_repo":".","dependencies":[{"issue_id":"voice-code-priority-queue-7op","depends_on_id":"voice-code-priority-queue-63a","type":"blocks","created_at":"2025-12-07T17:59:33.611884-06:00","created_by":"travisbrown"}]}
{"id":"voice-code-priority-queue-7r9","content_hash":"084718f89ba6e1471264d6253a6e0aee093ece0cc3becdb8cfa9cbbd0d4cf4b4","title":"Verify CoreData schema default values for priority queue properties","description":"CDBackendSession added 4 properties but CoreData .xcdatamodeld needs default values to prevent random memory values on first access. Verify defaults: isInPriorityQueue=false, priority=10, priorityOrder=0.0, priorityQueuedAt=nil. Check VoiceCode 2.xcdatamodel.","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-09T21:00:41.190052-06:00","updated_at":"2025-12-10T09:38:27.773532-06:00","closed_at":"2025-12-10T09:38:27.773532-06:00","source_repo":"."}
{"id":"voice-code-priority-queue-7sf","content_hash":"98de77c14c6f25da5de664ec20f3bb606f0d08e8b2d40e1c70e2700fb2e8c432","title":"CoreData schema missing index on priority queue attributes causing table scans","description":"**Analysis:** Index would help fetchMaxPriorityOrder, not in-memory filtering.\n\n**Current architecture:**\n- DirectoryListView fetches ALL sessions via CDBackendSession.fetchActiveSessions()\n- Priority queue filtering done in-memory (Swift filter/sort)\n- Index on priority attributes wouldn't help in-memory operations\n\n**Where index would help:**\nfetchMaxPriorityOrder() in CDBackendSession+PriorityQueue.swift uses NSPredicate:\n```swift\nNSPredicate(format: \"isInPriorityQueue == YES AND priority == %d\", priority)\n```\nWith fetchLimit=100, full scan is limited anyway.\n\n**Impact assessment:**\n- Typical session count: 5-20 (no performance issue)\n- Power users: 50-100 (fetchLimit handles this)\n- Extreme case: 1000+ (would benefit from index)\n\n**Migration complexity:**\n- Requires new model version (VoiceCode 3)\n- Automatic migration should handle index addition\n- Risk: Migration failures on user devices\n\n**Recommendation:** Downgrade to P4. Only implement if profiling shows actual performance issue with large datasets. Current fetchLimit=100 mitigates the concern.","status":"open","priority":4,"issue_type":"task","created_at":"2025-12-09T21:47:20.74819-06:00","updated_at":"2025-12-10T09:49:26.428582-06:00","source_repo":".","labels":["data-integrity"]}
{"id":"voice-code-priority-queue-878","content_hash":"6c67c9b1025d69170000c7031dd72d0f99ce2522f0c61af136a746979fd2f26a","title":"Phase 6: UI Polish - Improve drag affordance","description":"Make drag-to-reorder feature more discoverable.\n\nFiles to modify:\n- ios/VoiceCode/Views/DirectoryListView.swift\n\nEnhancements to consider:\n1. Add drag handle icon (three horizontal lines) to session rows\n2. Show hint text when queue is first used\n3. Add subtle animation when entering edit mode\n4. Display tutorial/onboarding for drag feature\n\nImplementation options:\n- Leading accessory view with drag handle icon\n- EditButton in section header\n- Long-press gesture hint overlay\n- Tooltip or popover on first queue use\n\nVerification:\n1. New users can discover drag feature without documentation\n2. Drag handle visible and intuitive\n3. Tutorial appears once and does not annoy users\n4. Gesture feels natural and responsive","status":"open","priority":4,"issue_type":"task","created_at":"2025-12-07T17:58:45.313907-06:00","updated_at":"2025-12-07T17:58:45.313907-06:00","source_repo":".","dependencies":[{"issue_id":"voice-code-priority-queue-878","depends_on_id":"voice-code-priority-queue-9h5","type":"blocks","created_at":"2025-12-07T17:59:47.776265-06:00","created_by":"travisbrown"}]}
{"id":"voice-code-priority-queue-880","content_hash":"38e104fa20d0bed02adcc1b294827adc15863b6a6a9fa880578d7727652d8868","title":"Phase 2: Sorting - Implement priority queue sorting logic in DirectoryListView","description":"Implement sorting and filtering logic for priority queue sessions in DirectoryListView.\n\nFILES TO MODIFY:\n- ios/VoiceCode/Views/DirectoryListView.swift\n\nSTATE VARIABLES TO ADD:\n\n1. @State private var priorityQueueSessions: [CDBackendSession] = []\n2. @State private var isPriorityQueueExpanded: Bool = true\n\nLocation: Add after existing queuedSessions state variable (around line 45)\n\nFUNCTION TO IMPLEMENT:\n\nupdateCachedPriorityQueueSessions()\n\nLocation: Add after existing updateCachedQueuedSessions function (around line 427)\n\nSORTING ALGORITHM (UPDATED - Three-Level Sort):\n\nPrimary sort: priority (ascending) - lower numbers first\nSecondary sort: priorityOrder (ascending) - older first within same priority\nTertiary sort: session ID (ascending) - deterministic tiebreaker\n\nLogic:\n1. Filter sessions where isInPriorityQueue == true\n2. Filter out locked sessions (exclude if sessionId in lockedSessionIds)\n3. Sort by priority ascending, then priorityOrder ascending, then session ID ascending\n4. Update @State priorityQueueSessions array\n\nCode:\nfunc updateCachedPriorityQueueSessions() {\n    let lockedSessionIds = viewModel.lockedSessions\n    \n    let updatedSessions = sessions\n        .filter { $0.isInPriorityQueue }\n        .filter { session in\n            let sessionId = session.id.uuidString.lowercased()\n            return !lockedSessionIds.contains(sessionId)\n        }\n        .sorted { lhs, rhs in\n            // Primary: priority (ascending - lower = higher priority)\n            if lhs.priority != rhs.priority {\n                return lhs.priority \u003c rhs.priority\n            }\n            // Secondary: priorityOrder (ascending - older first)\n            if lhs.priorityOrder != rhs.priorityOrder {\n                return lhs.priorityOrder \u003c rhs.priorityOrder\n            }\n            // Tertiary: session ID (deterministic tiebreaker)\n            return lhs.id.uuidString \u003c rhs.id.uuidString\n        }\n    \n    if updatedSessions != priorityQueueSessions {\n        priorityQueueSessions = updatedSessions\n    }\n}\n\nTRIGGER POINTS:\n\nCall updateCachedPriorityQueueSessions() when:\n1. sessions changes (.onChange modifier)\n2. lockedSessions changes (.onChange modifier)\n3. priorityQueueEnabled changes (.onChange modifier)\n4. View appears (.onAppear modifier)\n\nImplementation:\n.onChange(of: sessions) { _ in\n    updateCachedQueuedSessions()\n    updateCachedPriorityQueueSessions()  // ADD THIS\n}\n.onChange(of: viewModel.lockedSessions) { _ in\n    updateCachedQueuedSessions()\n    updateCachedPriorityQueueSessions()  // ADD THIS\n}\n.onChange(of: settings.priorityQueueEnabled) { _ in\n    updateCachedPriorityQueueSessions()  // ADD THIS\n}\n\nPERFORMANCE NOTES (NEW):\n- Array holds references to CoreData objects (not copies)\n- Expected size: 10-100 sessions (typical usage)\n- Performance target: \u003c1ms for 100 sessions, \u003c10ms for 1000 sessions\n- Stress tested in voice-code-priority-queue-zrk task\n- Optimization only if performance issues emerge in testing\n\nIMPLEMENTATION STEPS:\n1. Open DirectoryListView.swift\n2. Find existing state variables section\n3. Add priorityQueueSessions and isPriorityQueueExpanded\n4. Find updateCachedQueuedSessions function\n5. Add updateCachedPriorityQueueSessions after it with THREE-LEVEL sort\n6. Find .onChange(of: sessions) modifier\n7. Add call to updateCachedPriorityQueueSessions\n8. Repeat for other onChange modifiers\n9. Build project (Cmd+B)\n10. Fix any compilation errors\n\nVERIFICATION - Test Pyramid:\n\nUnit Tests (PriorityQueueManagementTests.swift):\n\nTest 1: testPrioritySortingAscending\n- Create sessions with priorities: 15, 5, 10\n- Add all to priority queue\n- Fetch sorted sessions\n- Assert order: [P5, P10, P15]\n\nTest 2: testPriorityOrderTieBreaking\n- Create 3 sessions, all priority=10\n- Set priorityOrder: 100, 50, 200\n- Add to priority queue\n- Fetch sorted sessions\n- Assert order by priorityOrder: [50, 100, 200]\n\nTest 3: testSessionIdTiebreaker (NEW)\n- Create 2 sessions, both priority=10, both priorityOrder=1.0\n- Add to priority queue\n- Fetch sorted\n- Assert order by session ID (alphabetical)\n\nTest 4: testMixedPrioritiesAndOrders\n- Create sessions: P5/order:100, P5/order:50, P10/order:25, P10/order:75\n- Add all to priority queue\n- Fetch sorted\n- Assert order: [P5/50, P5/100, P10/25, P10/75]\n\nTest 5: testLockedSessionsFiltered\n- Create 3 sessions, add to priority queue\n- Mock lockedSessionIds with one session ID\n- Call updateCachedPriorityQueueSessions\n- Assert locked session not in result\n- Assert 2 sessions in result\n\nTest 6: testNonPriorityQueueSessionsFiltered\n- Create 5 sessions\n- Add 3 to priority queue, leave 2 out\n- Call update function\n- Assert only 3 sessions in result\n\nTest 7: testNegativePriorities\n- Create sessions with priorities: -5, 0, 10\n- Add to priority queue\n- Assert order: [-5, 0, 10]\n\nTest 8: testEmptyPriorityQueue\n- Create sessions, none in priority queue\n- Call update function\n- Assert priorityQueueSessions.isEmpty == true\n\nIntegration Tests:\n\nTest 9: testSortingReactsToPriorityChanges\n- Create 3 sessions in priority queue\n- Change priority of one session\n- Verify sorted order updates correctly\n\nTest 10: testLockedSessionDisappears\n- Add session to priority queue\n- Lock session (add to lockedSessionIds)\n- Verify session not in priorityQueueSessions\n- Unlock session\n- Verify session reappears\n\nManual Verification:\n1. Run app, enable priority queue\n2. Create 5 sessions with different priorities\n3. Use debugger to inspect priorityQueueSessions array:\n   po priorityQueueSessions.map { ($0.priority, $0.priorityOrder, $0.id.uuidString) }\n4. Verify order matches expected (priority ‚Üí order ‚Üí ID)\n5. Send message to one session (locks it)\n6. Verify session disappears from array\n7. Wait for response\n8. Verify session reappears\n\nACCEPTANCE CRITERIA:\n‚úÖ priorityQueueSessions state variable added\n‚úÖ isPriorityQueueExpanded state variable added\n‚úÖ updateCachedPriorityQueueSessions function implemented\n‚úÖ Sorting logic correct (priority ‚Üí priorityOrder ‚Üí session ID)\n‚úÖ Session ID tiebreaker ensures deterministic sorting\n‚úÖ Locked sessions filtered out\n‚úÖ Non-queue sessions filtered out\n‚úÖ Function called on all relevant state changes\n‚úÖ All 10 unit tests pass\n‚úÖ Sorting performance acceptable for 100+ sessions (\u003c1ms)\n‚úÖ No UI flickering when sorting\n‚úÖ Negative priorities handled correctly","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-07T17:56:06.605776-06:00","updated_at":"2025-12-09T20:19:50.403804-06:00","closed_at":"2025-12-09T20:19:50.403804-06:00","source_repo":".","dependencies":[{"issue_id":"voice-code-priority-queue-880","depends_on_id":"voice-code-priority-queue-63a","type":"blocks","created_at":"2025-12-07T17:59:20.273422-06:00","created_by":"travisbrown"}]}
{"id":"voice-code-priority-queue-887","content_hash":"213cda8f2f5be0b01ea6dcff283a4beea942a72e9943f3e9fc0413cefd657c03","title":"CoreData schema priority attribute has no validation constraint","description":"**File:** VoiceCode 2.xcdatamodel/contents:16-17\n\n**Issue:** priority attribute allows ANY Int32 value (-2,147,483,648 to 2,147,483,647) but UI only offers 1, 5, 10. Schema has no validation constraint.\n\n**Impact:** \n- Code could set invalid priority values (e.g., -1, 100, 999)\n- Sort order would still work but UI would show unexpected values\n- Picker would display session.priority even if not in {1,5,10}\n\n**Evidence:**\n```xml\n\u003c!-- VoiceCode 2.xcdatamodel/contents:16 --\u003e\n\u003cattribute name=\"priority\" attributeType=\"Integer 32\" defaultValueString=\"10\" usesScalarValueType=\"YES\"/\u003e\n\u003c!-- ‚ùå No validation rule --\u003e\n```\n\n**Proposed Fix (Schema-Level):**\nCoreData doesn't support CHECK constraints, so validation must be in code.\n\n**Proposed Fix (Code-Level):**\nAdd validation in changePriority():\n```swift\nprivate func changePriority(_ session: CDBackendSession, newPriority: Int32) {\n    // Validate priority value\n    guard [1, 5, 10].contains(newPriority) else {\n        logger.error(\"Invalid priority value: \\(newPriority)\")\n        return\n    }\n    // ... existing code ...\n}\n```\n\n**Related:** voice-code-priority-queue-i7s tracks adding bounds checking for priority values in UI.","status":"open","priority":3,"issue_type":"bug","created_at":"2025-12-09T21:47:22.187064-06:00","updated_at":"2025-12-09T21:47:22.187064-06:00","source_repo":".","labels":["data-validation"]}
{"id":"voice-code-priority-queue-8r0","content_hash":"edc785179351314151c55f563edc22c87740658b505fbd40770d908749fb0a38","title":"Handle CoreData faulting when accessing session.priority in sorted","description":"**Analysis:** Not a bug - CoreData faulting is normal behavior.\n\n**How it works:**\n- CoreData automatically fires faults when properties are accessed\n- Faulting is transparent to application code\n- Batch faulting happens when multiple objects accessed in sequence\n\n**Performance impact:**\n- With fetchLimit=100, at most 100 sessions fetched\n- Scalar properties (Int32, Double) are small\n- Modern iOS handles this efficiently\n\n**When optimization matters:**\n- 1000+ sessions (beyond fetchLimit)\n- Slow storage (not applicable to iOS)\n- Visible UI lag during sort (not observed)\n\n**If optimization needed:**\n```swift\nrequest.relationshipKeyPathsForPrefetching = [\"priority\", \"priorityOrder\"]\n```\n\n**Recommendation:** Downgrade to P4. Only optimize if profiling shows actual performance issue.","status":"open","priority":4,"issue_type":"bug","created_at":"2025-12-09T21:04:16.68698-06:00","updated_at":"2025-12-10T09:37:12.96678-06:00","source_repo":"."}
{"id":"voice-code-priority-queue-8wl","content_hash":"8d9a8fe5d554aa28436a2f65d4e762eacbcab0f65babeb7ec3eead3f4be70f6e","title":"Sorting by UUID string is lexicographic not chronologic for tiebreaker","description":"DirectoryListView line 489 uses 'session1.id.uuidString \u003c session2.id.uuidString' as tiebreaker. UUID string comparison is lexicographic (alphabetic), not time-based. UUIDs contain timestamp but string comparison doesn't respect it. Better tiebreaker: session.createdAt or session.lastModified. Current works but doesn't reflect insertion order as comment implies. Low priority - functionally fine.","status":"open","priority":4,"issue_type":"task","created_at":"2025-12-09T21:29:27.809251-06:00","updated_at":"2025-12-09T21:29:27.809251-06:00","source_repo":"."}
{"id":"voice-code-priority-queue-92p","content_hash":"a08347361b560cc2c1968f90e767994d9c4fba91a86ddaaa30d3038cfce89531","title":"Add documentation comments to complex priority queue functions","description":"**Partial fix:** CDBackendSession+PriorityQueue.swift has doc comments on all public functions:\n- Line 12: addToPriorityQueue - describes FIFO ordering\n- Line 39: removeFromPriorityQueue - describes reset behavior\n- Line 77: changePriority - describes reorder within priority level\n- Lines 120-126: fetchMaxPriorityOrder - detailed parameter docs\n\n**Remaining:** DirectoryListView cache update functions could use better inline comments explaining debounce pattern. Consider P4 for future polish.","status":"open","priority":4,"issue_type":"task","created_at":"2025-12-09T21:00:33.013255-06:00","updated_at":"2025-12-10T09:38:49.721409-06:00","source_repo":".","labels":["documentation"]}
{"id":"voice-code-priority-queue-94kw","content_hash":"54275b50d3495dc9120415294c9085050944d8ef12c19ff8a312dcd8dd756a18","title":"No user-facing documentation explains Priority Queue feature usage","description":"**File:** All priority queue files\n\n**Task:** No user-facing documentation exists explaining Priority Queue feature, how it works, or how to use it effectively.\n\n**Missing Documentation:**\n\n1. **Feature Overview:**\n```markdown\n# Priority Queue Feature\n\n## What is Priority Queue?\n\nThe Priority Queue feature allows you to organize your Claude sessions by priority level, ensuring your most important work is always at the top of the list.\n\n## How It Works\n\n- **Three Priority Levels:**\n  - High (1): Your most urgent sessions appear first\n  - Medium (5): Standard priority for regular work\n  - Low (10): Less urgent sessions appear last\n\n- **Automatic Adding:**\n  - When enabled, new sessions are automatically added to the queue\n  - Sessions appear in the Priority Queue section of the Projects view\n\n- **FIFO Within Priority:**\n  - Sessions with the same priority are sorted by when they were added\n  - Oldest sessions appear first within each priority level\n\n## Getting Started\n\n1. Enable Priority Queue in Settings\n2. Send a message in any session (auto-added)\n3. Adjust priority in Session Info (tap ‚ìò icon)\n4. Sessions appear in Priority Queue section, sorted by priority\n\n## Managing Your Queue\n\n- **Add Session:** Tap ‚≠ê in toolbar\n- **Remove Session:** Swipe left on session in Priority Queue section\n- **Change Priority:** Open Session Info ‚Üí tap Priority picker\n- **View Details:** Tap session to see priority and queue position\n```\n\n2. **FAQ:**\n```markdown\n## Frequently Asked Questions\n\n**Q: What's the difference between Queue and Priority Queue?**\nA: Queue is FIFO (first in, first out). Priority Queue sorts by priority level first, then FIFO within each level.\n\n**Q: Can I use both Queue and Priority Queue?**\nA: Yes, but most users prefer one or the other to avoid confusion.\n\n**Q: Why did my session disappear from Priority Queue?**\nA: Sessions disappear from the list when locked (processing a message). They reappear when unlocked.\n\n**Q: How do I change the default priority?**\nA: Currently, all new sessions start at Medium (10). You can change priority after adding to queue.\n\n**Q: Can I disable auto-add?**\nA: Not currently. If you remove a session, it will be re-added when you send the next message.\n\n**Q: What happens if I disable Priority Queue?**\nA: Sessions remain in the queue with their priorities preserved. Re-enabling the feature shows them again.\n```\n\n3. **Settings Help Text:**\nExpand the existing Settings description (SettingsView.swift:121):\n```swift\nText(\"\"\"\n    Organize sessions by priority level. New sessions are automatically added when you send a message.     \n    ‚Ä¢ High (1): Most urgent work\n    ‚Ä¢ Medium (5): Standard priority  \n    ‚Ä¢ Low (10): Less urgent tasks\n    \n    Sessions are sorted by priority, then by when they were added. Tap the session info (‚ìò) button to change priority.\n    \"\"\")\n    .font(.caption)\n    .foregroundColor(.secondary)\n```\n\n4. **In-App Help:**\nAdd help button to Priority Queue section:\n```swift\nSection(header:\n    HStack {\n        Text(\"Priority Queue\")\n        Spacer()\n        Button(action: { showPriorityQueueHelp = true }) {\n            Image(systemName: \"questionmark.circle\")\n                .foregroundColor(.secondary)\n        }\n    }\n) { /* section content */ }\n.sheet(isPresented: ) {\n    PriorityQueueHelpView()\n}\n```\n\n**Benefits:**\n- Reduces user confusion\n- Decreases support requests\n- Improves feature adoption\n- Documents expected behavior\n- Helps users troubleshoot issues\n\n**Implementation:**\n- Add PRIORITY_QUEUE_USER_GUIDE.md\n- Add help button in UI\n- Expand Settings descriptions\n- Create tutorial/walkthrough for first use","status":"open","priority":4,"issue_type":"task","created_at":"2025-12-09T22:17:44.085873-06:00","updated_at":"2025-12-09T22:17:44.085873-06:00","source_repo":".","labels":["documentation"]}
{"id":"voice-code-priority-queue-9gi","content_hash":"233d179ed562bfc7d40d1d6e1c13d385ee8fdecf299f6d855f2864aa978170b7","title":"ConversationView uses print instead of logger for priority queue operations","description":"**File:** ConversationView.swift:896-967\n\n**Issue:** ConversationView priority queue functions use print() for logging while DirectoryListView and SessionInfoView use OSLog logger.\n\n**Impact:** Inconsistent logging makes debugging difficult - need to check two different log sources.\n\n**Fix:** Replace all print() with logger calls. ConversationView already has logger defined at line 8.","status":"open","priority":3,"issue_type":"bug","created_at":"2025-12-09T21:37:20.998552-06:00","updated_at":"2025-12-09T21:37:20.998552-06:00","source_repo":".","labels":["ui-consistency"]}
{"id":"voice-code-priority-queue-9h5","content_hash":"5fda54661e86634f4f0e090079371565a1f576581acaad06010a4225e550090d","title":"Phase 5: Drag to Reorder - Implement drag gesture handling","description":"Implement drag gesture for reordering sessions in priority queue.\n\nFILES TO MODIFY:\n- ios/VoiceCode/Views/DirectoryListView.swift\n\nIMPLEMENTATION:\nAdd .onMove modifier to ForEach in priority queue section:\n\nForEach(priorityQueueSessions) { session in\n    // session row\n}\n.onMove { source, destination in\n    reorderPriorityQueue(from: source, to: destination)\n}\n\nEDIT MODE REQUIREMENT (iOS/SwiftUI):\nSwiftUI's .onMove modifier requires the List to be in edit mode for drag handles to appear.\n\n**Option 1: EditButton in Toolbar/Navigation**\n```swift\n.toolbar {\n    EditButton()  // System button toggles edit mode\n}\n```\n\n**Option 2: Manual Edit Mode (Environment)**\n```swift\n@Environment(\\.editMode) private var editMode\n\n// Toggle edit mode programmatically\nButton(\"Edit\") {\n    editMode?.wrappedValue = editMode?.wrappedValue == .active ? .inactive : .active\n}\n```\n\n**Option 3: Long-Press Gesture (Alternative)**\nIf edit mode UX is undesirable, could implement custom long-press drag gesture.\n\n**Recommended for MVP:** Use EditButton (simplest, standard iOS behavior)\n\nNote: User long-presses session row to reveal drag handles, then drags.\n\nFunction to implement:\nfunc reorderPriorityQueue(from source: IndexSet, to destination: Int) {\n    guard let sourceIndex = source.first else { return }\n    let session = priorityQueueSessions[sourceIndex]\n    \n    // Calculate above/below sessions\n    let above = destination \u003e 0 ? priorityQueueSessions[destination - 1] : nil\n    let below = destination \u003c priorityQueueSessions.count ? priorityQueueSessions[destination] : nil\n    \n    reorderSession(session, between: above, and: below)\n}\n\nINTEGRATION NOTES:\n- reorderSession function defined in task voice-code-priority-queue-3z6\n- Must be accessible from DirectoryListView\n- Consider adding as extension or shared helper\n\nVERIFICATION:\nManual Test:\n1. Add 5 sessions to priority queue\n2. Tap Edit button (or long-press session)\n3. Verify drag handles appear (‚â° icon on right)\n4. Drag session to new position\n5. Verify position updates\n6. Verify priority/priorityOrder calculated correctly\n7. Release drag\n8. Verify new order persists\n9. Tap Done to exit edit mode\n\nIntegration Test:\n- Simulate drag from index 2 to index 0\n- Verify session moves to top\n- Assert priority and priorityOrder updated\n\nACCEPTANCE CRITERIA:\n‚úÖ .onMove modifier added to ForEach\n‚úÖ Edit mode enabled (EditButton or manual)\n‚úÖ Drag gesture works smoothly\n‚úÖ Drag handles appear when in edit mode\n‚úÖ reorderPriorityQueue function implemented\n‚úÖ Calls reorderSession with correct params\n‚úÖ Manual drag test succeeds\n‚úÖ No UI glitches during drag\n‚úÖ Edit mode toggle works (enter/exit)\n‚úÖ Drag handles visible in edit mode\n‚úÖ Normal tap navigation works when not in edit mode","status":"closed","priority":4,"issue_type":"task","created_at":"2025-12-07T17:57:54.132305-06:00","updated_at":"2025-12-10T18:13:44.484619-06:00","closed_at":"2025-12-10T18:13:44.484619-06:00","source_repo":".","dependencies":[{"issue_id":"voice-code-priority-queue-9h5","depends_on_id":"voice-code-priority-queue-6vx","type":"blocks","created_at":"2025-12-07T17:59:39.09415-06:00","created_by":"travisbrown"}]}
{"id":"voice-code-priority-queue-9n8","content_hash":"ee70d7692fa62bc303746d6ee383cd05ae6c30092e362c97b3b7db62a4a27854","title":"SettingsView Priority Queue toggle lacks warning about auto-add behavior","description":"**File:** SettingsView.swift:118-124\n\n**Task:** Priority Queue Settings toggle has no warning that enabling it will auto-add sessions to queue. User might enable feature and be surprised that sessions start appearing in Priority Queue automatically.\n\n**Impact:** Unexpected behavior - users expect toggles to just show/hide UI sections, not trigger automatic actions.\n\n**Current Behavior:**\n1. User enables Priority Queue toggle\n2. Sends a message in any session\n3. Session is auto-added to Priority Queue (ConversationView.swift:584)\n4. User didn't explicitly choose to add that session\n\n**Proposed Enhancement:** Add footer warning or confirmation:\n```swift\nSection(header: Text(\"Priority Queue\")) {\n    Toggle(\"Enable Priority Queue\", isOn: $settings.priorityQueueEnabled)\n    \n    Text(\"When enabled, sessions are automatically added to the priority queue when you send a message. You can adjust priorities and remove sessions manually.\")\n        .font(.caption)\n        .foregroundColor(.secondary)\n        \n    if settings.priorityQueueEnabled {\n        Text(\"‚ö†Ô∏è Sessions will be auto-added to queue when you send messages\")\n            .font(.caption2)\n            .foregroundColor(.orange)\n    }\n}\n```\n\nOr use confirmation dialog on first enable:\n```swift\n.onChange(of: settings.priorityQueueEnabled) { wasEnabled, isEnabled in\n    if isEnabled \u0026\u0026 !hasShownPriorityQueueWarning {\n        showPriorityQueueWarningDialog = true\n    }\n}\n```","status":"open","priority":3,"issue_type":"task","created_at":"2025-12-09T21:46:05.134934-06:00","updated_at":"2025-12-09T21:46:05.134934-06:00","source_repo":".","labels":["ux"]}
{"id":"voice-code-priority-queue-9u1","content_hash":"7c00658b99ac82fdaa4755215abfaac1a6d04702a842dfe8f1f8ffdb186a94f0","title":"ConversationView auto-add checks isInPriorityQueue on every message send","description":"**File:** ConversationView.swift:583-586\n\n**Issue:** Auto-add to priority queue happens inside sendPromptText() which is called from BOTH voice and text input paths. If user sends message via voice, then quickly sends another via text, both trigger auto-add for same session.\n\n**Impact:** Idempotent guard (line 898) prevents duplicate adds, but wastes CPU cycles checking repeatedly. Every message send checks isInPriorityQueue even after first message.\n\n**Evidence:**\n```swift\n// ConversationView.swift:567-586\nprivate func sendPromptText(_ text: String) {\n    // ... validation ...\n    \n    // Add to queue if enabled\n    if settings.queueEnabled {\n        addToQueue(session)\n    }\n    \n    // Add to priority queue if enabled\n    if settings.priorityQueueEnabled {\n        addToPriorityQueue(session)  // Called on EVERY message send\n    }\n    // ...\n}\n\n// Line 896-898\nprivate func addToPriorityQueue(_ session: CDBackendSession) {\n    guard !session.isInPriorityQueue else { return }  // Idempotent guard\n    // ...\n}\n```\n\n**Why This Wastes Resources:**\n- First message: session.isInPriorityQueue = false ‚Üí add to queue ‚úì\n- Second message: session.isInPriorityQueue = true ‚Üí guard returns early ‚úì\n- Third message: guard returns early ‚úì\n- Every subsequent message: guard returns early ‚úì\n\n**Proposed Optimization:** Check before calling:\n```swift\n// Only auto-add if NOT already in queue\nif settings.priorityQueueEnabled \u0026\u0026 !session.isInPriorityQueue {\n    addToPriorityQueue(session)\n}\n```\n\nOr set flag after first add to skip check:\n```swift\nif settings.priorityQueueEnabled \u0026\u0026 session.messageCount == 0 {\n    addToPriorityQueue(session)  // Only for first message\n}\n```\n\n**Related:** voice-code-priority-queue-1rc tracks this issue.","status":"closed","priority":2,"issue_type":"bug","created_at":"2025-12-09T21:55:58.728726-06:00","updated_at":"2025-12-09T22:34:47.614585-06:00","closed_at":"2025-12-09T22:34:47.614585-06:00","source_repo":".","labels":["state-management"]}
{"id":"voice-code-priority-queue-9wb","content_hash":"3f085d1bacfd6af0fd2d538cadb39f1def7ce106cd750a8dfe38a6dd8929165a","title":"Verify NSPredicate format string type safety","description":"NSPredicate uses string format 'priority == %d' with Int32. Should use typed predicate or verify %d is correct format specifier for Int32. Modern approach: Use NSPredicate(format:argumentArray:) or keypaths. Check lines: DirectoryListView:548, ConversationView:964, SessionInfoView:264.","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-09T21:04:32.84556-06:00","updated_at":"2025-12-09T22:44:18.406734-06:00","closed_at":"2025-12-09T22:44:18.406734-06:00","source_repo":".","labels":["code-quality"]}
{"id":"voice-code-priority-queue-9yb","content_hash":"1826ad30a21bc3725cf83cffa130898c4d6b639539c36d1e3799d5ee24900a6a","title":"Phase 6: Accessibility - Add VoiceOver and accessibility support","description":"Add comprehensive accessibility support for priority queue feature.\n\nFILES TO MODIFY:\n- ios/VoiceCode/Views/DirectoryListView.swift (priority badges, section)\n- ios/VoiceCode/Views/ConversationView.swift (remove button, priority editor)\n\nACCESSIBILITY REQUIREMENTS:\n\n1. Priority Badges (DirectoryListView):\n   Text(\"P\\(session.priority)\")\n       .accessibilityLabel(\"Priority \\(session.priority)\")\n       .accessibilityHint(\"Lower numbers are higher priority\")\n\n2. Remove from Queue Button (ConversationView):\n   Button { removeFromPriorityQueue(session) }\n       .accessibilityLabel(\"Remove from priority queue\")\n       .accessibilityHint(\"Removes this session from the priority queue\")\n\n3. Priority Queue Section Header:\n   Section(header: Text(\"Priority Queue\"))\n       .accessibilityLabel(\"Priority Queue section\")\n       .accessibilityHint(\"Sessions ordered by priority, drag to reorder\")\n\n4. Drag Handle (if added in Phase 6):\n   Image(systemName: \"line.3.horizontal\")\n       .accessibilityLabel(\"Reorder handle\")\n       .accessibilityHint(\"Drag to change priority order\")\n\n5. Priority Stepper (Session Info Modal):\n   Stepper has built-in accessibility\n   Optional enhancement:\n       .accessibilityHint(\"Lower numbers appear first in queue\")\n\n6. Swipe Actions:\n   SwiftUI provides automatic VoiceOver support for swipe actions\n   Ensure label is descriptive: Label(\"Remove\", systemImage: \"xmark.circle\")\n\nCONTRAST RATIO REQUIREMENTS (WCAG AA):\n\nElements requiring 4.5:1 contrast ratio minimum:\n- Priority badge text vs background\n- \"Priority Queue\" section header\n- Lock message text (\"Priority locked while processing\")\n- Stepper value display\n- Remove button icon\n- Add button icon\n\nTool: Accessibility Inspector ‚Üí Color Contrast Calculator\n\nDYNAMIC TYPE SUPPORT:\n\nAll text uses standard fonts that scale:\n- .caption2 for badges (scales automatically)\n- .secondary for labels (scales automatically)\n- Verify layout doesn't break at largest text size (Accessibility Inspector)\n\nTest at accessibility size: Settings ‚Üí Accessibility ‚Üí Display \u0026 Text Size ‚Üí Larger Text ‚Üí Maximum\n\nVERIFICATION:\n\nManual Testing with VoiceOver:\n1. Enable VoiceOver (Cmd+F5 in simulator, triple-click home on device)\n2. Navigate to Projects view\n3. Swipe to Priority Queue section\n4. Verify section announced: \"Priority Queue section, Sessions ordered by priority\"\n5. Swipe to first session in queue\n6. Verify priority badge announced: \"Priority 5, Lower numbers are higher priority\"\n7. Swipe to remove button\n8. Verify announced: \"Remove from priority queue\"\n9. Open session info modal\n10. Navigate to Priority stepper\n11. Verify value announced: \"Priority 10\"\n12. Double-tap to activate stepper\n13. Swipe up/down to change value\n14. Verify new value announced\n\nAccessibility Inspector Testing:\n1. Open Accessibility Inspector (Xcode ‚Üí Open Developer Tool ‚Üí Accessibility Inspector)\n2. Select simulator\n3. Inspect Priority Queue section\n4. Verify Label, Hint, Traits set correctly\n5. Inspect priority badges\n6. Verify readable labels\n7. Run Audit (Accessibility Inspector ‚Üí Audit button)\n8. Check for issues/warnings\n9. Verify contrast ratios:\n   - Priority badge: [ratio]\n   - Section header: [ratio]\n   - Lock message: [ratio]\n   - Buttons: [ratio]\n10. All should be ‚â• 4.5:1\n\nDynamic Type Testing:\n1. Settings ‚Üí Accessibility ‚Üí Display \u0026 Text Size ‚Üí Larger Text\n2. Drag slider to maximum\n3. Run app\n4. Navigate to Priority Queue\n5. Verify badges don't overflow\n6. Verify text remains readable\n7. Verify buttons still tappable\n8. Verify no text truncation with \"...\" (unless intentional)\n9. Verify stepper controls remain usable\n\nACCESSIBILITY AUDIT CHECKLIST:\n\nUI Element | Requirement | Status\n-----------|-------------|-------\nPriority badge | Label, hint, contrast ‚â•4.5:1 | [ ]\nSection header | Label, readable | [ ]\nRemove button | Label, hint, contrast ‚â•4.5:1 | [ ]\nAdd button | Label, hint, contrast ‚â•4.5:1 | [ ]\nPriority stepper | Built-in support, hint | [ ]\nLock message | Contrast ‚â•4.5:1, readable | [ ]\nSwipe actions | Descriptive labels | [ ]\nDrag handles | Label, hint (if custom) | [ ]\nDynamic Type | Scales without breaking | [ ]\nVoiceOver nav | Logical order, clear labels | [ ]\n\nACCEPTANCE CRITERIA:\n‚úÖ All UI elements have accessibility labels\n‚úÖ Priority badges announce priority number and meaning\n‚úÖ Remove button has clear action label\n‚úÖ Stepper has descriptive hint\n‚úÖ VoiceOver navigation works smoothly\n‚úÖ Dynamic Type scales without breaking layout\n‚úÖ Contrast ratios meet WCAG AA standards (‚â•4.5:1)\n‚úÖ Manual VoiceOver testing passes all scenarios\n‚úÖ Accessibility Inspector shows no warnings\n‚úÖ Accessibility audit checklist complete\n‚úÖ All contrast ratios measured and documented\n\nNOTE: Drag-to-reorder accessibility handled by alternative (priority stepper in modal) since drag gestures have limited VoiceOver support.","status":"open","priority":4,"issue_type":"task","created_at":"2025-12-08T19:48:20.054295-06:00","updated_at":"2025-12-08T22:35:02.113595-06:00","source_repo":".","dependencies":[{"issue_id":"voice-code-priority-queue-9yb","depends_on_id":"voice-code-priority-queue-2wv","type":"blocks","created_at":"2025-12-08T19:48:26.340794-06:00","created_by":"travisbrown"}]}
{"id":"voice-code-priority-queue-a8d","content_hash":"41ef972b1db5f404ae1375aeb75da18dcaa9043ef0148813053e8206822456fd","title":"Add validation that priorityOrder increment doesn't overflow","description":"addToPriorityQueue sets priorityOrder = maxOrder + 1.0 (DirectoryListView:562, ConversationView:904). If maxOrder approaches Double.max (1.7e308), adding 1.0 could overflow. Extremely unlikely but defensive: if maxOrder \u003e Double.greatestFiniteMagnitude - 100.0, trigger compaction or log warning. Edge case for very long-running apps.","status":"open","priority":4,"issue_type":"bug","created_at":"2025-12-09T21:18:07.411284-06:00","updated_at":"2025-12-09T21:18:07.411284-06:00","source_repo":"."}
{"id":"voice-code-priority-queue-ai5","content_hash":"c774d4f21067dc33d2ea54003143f49b015d167d1ee0c5d0557c67b50815aace","title":"Priority Queue has no keyboard shortcuts for accessibility","description":"**File:** DirectoryListView.swift:199, ConversationView.swift:331-350\n\n**Issue:** Priority Queue feature has no keyboard shortcuts, making it inaccessible for users who prefer keyboard navigation or need assistive technologies.\n\n**Impact:**\n- Power users cannot quickly add/remove sessions with keyboard\n- iPad users with keyboard cannot access priority queue efficiently\n- Reduces productivity for keyboard-heavy workflows\n\n**Missing Shortcuts:**\n\n1. **Add to Priority Queue:**\n   - Suggestion: Cmd+Shift+P (Priority)\n   - Or: Cmd+Option+Q (Queue)\n\n2. **Remove from Priority Queue:**\n   - Suggestion: Cmd+Shift+R (Remove)\n\n3. **Change Priority:**\n   - Suggestion: Cmd+1, Cmd+2, Cmd+3 for High/Medium/Low\n   - Or: Cmd+[/Cmd+] to increase/decrease priority\n\n4. **Navigate Priority Queue:**\n   - Suggestion: Cmd+Option+‚Üë/‚Üì to move between sessions\n\n**Proposed Implementation:**\n```swift\n// DirectoryListView.swift\n.keyboardShortcut(\"p\", modifiers: [.command, .shift])\n.onKeyPress(.keyboardShortcut(.upArrow, modifiers: [.command, .option])) {\n    navigateToPreviousSession()\n}\n\n// ConversationView.swift\nButton(action: { addToPriorityQueue(session) }) {\n    Image(systemName: \"star.fill\")\n}\n.keyboardShortcut(\"p\", modifiers: [.command, .shift])\n\n// SessionInfoView.swift\nPicker(\"Priority\", selection: ...) { ... }\n.keyboardShortcut(\"1\", modifiers: [.command]) // High\n.keyboardShortcut(\"2\", modifiers: [.command]) // Medium\n.keyboardShortcut(\"3\", modifiers: [.command]) // Low\n```\n\n**Design Considerations:**\n- Don't conflict with system shortcuts\n- Consistent across all three views\n- Discoverable (show in menus or help)\n- Customizable in future\n\n**Priority:** P4 - enhancement not critical bug, but improves accessibility and productivity.\n\n**Related:** voice-code-priority-queue-9yb [P4] tracks broader accessibility audit.","status":"open","priority":4,"issue_type":"bug","created_at":"2025-12-09T22:08:00.176857-06:00","updated_at":"2025-12-09T22:08:00.176857-06:00","source_repo":".","labels":["future-enhancement"]}
{"id":"voice-code-priority-queue-b0o","content_hash":"54c89de9dfb5dbc8432365ae9871f3cf28050f0f36f792536d53d4792f2fc6ba","title":"SessionInfoView Priority Picker missing accessibility labels","description":"**File:** SessionInfoView.swift:75-85\n\n**Issue:** Priority Picker has no accessibility label or hint. VoiceOver users hear \"Priority\" but don't know what each segment does until selecting it.\n\n**Impact:** Screen reader users can't understand priority values without trial and error.\n\n**Evidence:**\n```swift\nPicker(\"Priority\", selection: ...) {\n    Text(\"High (1)\").tag(Int32(1))\n    Text(\"Medium (5)\").tag(Int32(5))\n    Text(\"Low (10)\").tag(Int32(10))\n}\n.pickerStyle(.segmented)\n// ‚ùå No .accessibilityLabel() or .accessibilityHint()\n```\n\n**Fix:** Add accessibility modifiers:\n```swift\n.accessibilityLabel(\"Priority level\")\n.accessibilityHint(\"Double tap to change session priority. Lower numbers have higher priority.\")\n```","status":"open","priority":3,"issue_type":"bug","created_at":"2025-12-09T21:45:08.49766-06:00","updated_at":"2025-12-09T21:45:08.49766-06:00","source_repo":".","labels":["accessibility"]}
{"id":"voice-code-priority-queue-b3w","content_hash":"bdfede04d33886d44403d6aaa530733571096bd3296693568857288a5500397f","title":"ConversationView priority queue functions duplicated across 3 files","description":"**File:** ConversationView.swift:896-967\n\n**Issue:** Priority queue functions (addToPriorityQueue, removeFromPriorityQueue, changePriority, fetchMaxPriorityOrder) are duplicated identically in THREE files with only logging differences.\n\n**Files:**\n1. ConversationView.swift:896-967 (uses print)\n2. DirectoryListView.swift:536-606 (uses logger)\n3. SessionInfoView.swift:234-267 (uses print)\n\n**Impact:**\n- Code maintenance burden: bug fixes need 3x changes\n- Inconsistent logging (print vs logger)\n- 200+ lines of duplicated code\n- Risk of divergence if one copy is updated but others aren't\n\n**Evidence:**\nAll three files have nearly identical implementations:\n```swift\nprivate func addToPriorityQueue(_ session: CDBackendSession) {\n    guard !session.isInPriorityQueue else { return }\n    session.isInPriorityQueue = true\n    let maxOrder = fetchMaxPriorityOrder(priority: session.priority)\n    session.priorityOrder = maxOrder + 1.0\n    session.priorityQueuedAt = Date()\n    // Save logic (varies slightly)\n}\n```\n\n**Proposed Fix:** Extract to shared extension or manager:\n```swift\n// PriorityQueueManager.swift (new file)\nclass PriorityQueueManager {\n    static func addToPriorityQueue(_ session: CDBackendSession, context: NSManagedObjectContext) {\n        guard !session.isInPriorityQueue else { return }\n        session.isInPriorityQueue = true\n        let maxOrder = fetchMaxPriorityOrder(priority: session.priority, context: context)\n        session.priorityOrder = maxOrder + 1.0\n        session.priorityQueuedAt = Date()\n        try? context.save()\n    }\n    // ... other methods ...\n}\n```\n\nOr extension on CDBackendSession:\n```swift\nextension CDBackendSession {\n    func addToPriorityQueue(context: NSManagedObjectContext) {\n        guard !isInPriorityQueue else { return }\n        // ...\n    }\n}\n```\n\n**Related:** voice-code-priority-queue-wl1 [P0] already tracks this critical refactoring need.","status":"closed","priority":3,"issue_type":"bug","created_at":"2025-12-09T21:56:00.368082-06:00","updated_at":"2025-12-10T09:52:31.793284-06:00","closed_at":"2025-12-10T09:52:31.793284-06:00","source_repo":".","labels":["code-quality"]}
{"id":"voice-code-priority-queue-b4t","content_hash":"e894d4707732b821d7830117f47625f71e32ed56b8bd6a0d2c9e130b19745706","title":"Priority Queue section hides completely when empty instead of showing placeholder","description":"DirectoryListView line 198 uses 'if settings.priorityQueueEnabled \u0026\u0026 \\!priorityQueueSessions.isEmpty'. When enabled but empty, entire section disappears. User might think feature disabled. Consider showing section with placeholder: 'No sessions in priority queue. Add sessions using star button or they'll be added automatically when you send a prompt.' Helps discovery.","status":"open","priority":3,"issue_type":"task","created_at":"2025-12-09T21:23:05.081851-06:00","updated_at":"2025-12-09T21:23:05.081851-06:00","source_repo":".","labels":["ux"]}
{"id":"voice-code-priority-queue-b4x","content_hash":"0ba2f4e9d0e37d4ff752939b3fab86ee1c4617d6dcea31e8fc636046c367f8da","title":"ConversationView auto-add races with first message save","description":"**File:** ConversationView.swift:583-586\n\n**Issue:** Auto-add to priority queue happens BEFORE the prompt message is sent to backend and saved to CoreData. If message send fails or user force-quits during transmission, session is marked as in priority queue but has no conversation history.\n\n**Impact:** Creates ghost sessions in priority queue with messageCount=0.\n\n**Fix:** Move auto-add logic to after receiving successful backend response.","status":"closed","priority":2,"issue_type":"bug","created_at":"2025-12-09T21:37:08.254142-06:00","updated_at":"2025-12-09T22:34:47.613985-06:00","closed_at":"2025-12-09T22:34:47.613985-06:00","source_repo":".","labels":["data-integrity"]}
{"id":"voice-code-priority-queue-b6f","content_hash":"7f2191b4a439f16f83065b842994b9bf53f32a6182fea1b0ae7ab392ed41fa14","title":"CoreData priorityOrder uses Double but values are always integers","description":"**File:** VoiceCode 2.xcdatamodel/contents:17\n\n**Task:** priorityOrder attribute uses Double but values are always integers + 1.0 increments (1.0, 2.0, 3.0). Consider using Int32 for simpler data model.\n\n**Current Implementation:**\n```xml\n\u003cattribute name=\"priorityOrder\" attributeType=\"Double\" defaultValueString=\"0\" usesScalarValueType=\"YES\"/\u003e\n```\n\n**Usage Pattern:**\n```swift\n// DirectoryListView.swift:562\nsession.priorityOrder = maxOrder + 1.0  // Always whole numbers\n```\n\n**Why Double Was Chosen:**\n- Allows future enhancements like decimal ordering (1.5 to insert between 1 and 2)\n- Consistent with floating-point arithmetic patterns\n- Flexible for future priority reordering algorithms\n\n**Advantages of Double:**\n- ‚úÖ Future-proof for fractional ordering\n- ‚úÖ Can represent very large sequences without overflow\n- ‚úÖ Allows drag-to-reorder with midpoint calculation\n\n**Disadvantages of Double:**\n- ‚ùå Floating-point precision issues (unlikely but possible)\n- ‚ùå More complex than needed for current FIFO behavior\n- ‚ùå String formatting shows .0 suffix (\"1.0\" vs \"1\")\n\n**Recommendation:** Keep Double for future flexibility, but document the rationale in code comments or design notes.\n\n**Related:** voice-code-priority-queue-u07 suggests adding priorityOrder compaction/normalization.","status":"open","priority":3,"issue_type":"task","created_at":"2025-12-09T21:47:24.036487-06:00","updated_at":"2025-12-09T21:47:24.036487-06:00","source_repo":".","labels":["data-modeling"]}
{"id":"voice-code-priority-queue-bc9","content_hash":"ce90b4459540bef1f2b66eb2ffa55e6f1e1543bccd200cbd5b4f533d9260f21a","title":"Document or enforce relationship between priorityOrder and priority groups","description":"priorityOrder is scoped per priority level (priority=1 has orders 1.0,2.0,3.0 while priority=5 also has 1.0,2.0,3.0). This is correct but subtle. Add doc comments explaining: 'priorityOrder provides FIFO ordering WITHIN a priority level, not globally'. Prevents future confusion.","status":"open","priority":3,"issue_type":"task","created_at":"2025-12-09T21:11:37.948449-06:00","updated_at":"2025-12-09T21:11:37.948449-06:00","source_repo":".","labels":["documentation"]}
{"id":"voice-code-priority-queue-bdc","content_hash":"fa329ba61eca406a342dd8ab2bf7f1a8657bc40ddcf2dbe978dff639decd7ce8","title":"SessionInfoView changePriority doesn't refresh DirectoryListView cache","description":"**File:** SessionInfoView.swift:234-260\n\n**Issue:** SessionInfoView.changePriority() saves to CoreData but does NOT trigger DirectoryListView to refresh its cached priority queue sessions. Picker shows new priority but Priority Queue section shows old sort order.\n\n**Fix:** Post NotificationCenter notification after priority change or use @FetchRequest instead of @State cache.","status":"closed","priority":1,"issue_type":"bug","created_at":"2025-12-09T21:37:12.458362-06:00","updated_at":"2025-12-09T22:32:35.672256-06:00","closed_at":"2025-12-09T22:32:35.672256-06:00","source_repo":".","labels":["data-integrity"]}
{"id":"voice-code-priority-queue-bhx","content_hash":"4654d596d0713eeaadd86e0e8daa791f561a572afc12b17936d79a3abcf35e74","title":"Verify Picker behavior with session.priority changes during display","description":"SessionInfoView Picker uses Binding with get/set (lines 75-79). If session.priority changes externally (another view, background sync) while picker displayed, Binding get: returns new value but picker doesn't automatically update selection. SwiftUI should handle but verify picker reflects changes. Test: Open SessionInfoView, have another client change priority, verify picker updates.","status":"open","priority":3,"issue_type":"bug","created_at":"2025-12-09T21:18:16.215055-06:00","updated_at":"2025-12-09T21:18:16.215055-06:00","source_repo":"."}
{"id":"voice-code-priority-queue-bip","content_hash":"3e6d2c9ef728f4e2d9c51750d713e43ce744f5d08c61f88aa5de1c92e87cba60","title":"DirectoryListView could optimize three cache updates into single pass","description":"**File:** DirectoryListView.swift:401-425, 427-462, 464-502\n\n**Task:** Three separate cache update functions (directories, queued sessions, priority queue sessions) are called sequentially, each performing independent CoreData operations. Could be optimized with single combined query.\n\n**Current Implementation:**\n```swift\n.onChange(of: sessions.count) { _ in\n    updateCachedDirectories()           // Query 1: Group by workingDirectory\n    updateCachedQueuedSessions()        // Query 2: Filter isInQueue\n    updateCachedPriorityQueueSessions() // Query 3: Filter isInPriorityQueue\n}\n```\n\n**Performance Characteristics:**\n- Three separate filter/map/reduce operations\n- Three separate iterations over sessions array\n- Three separate debounced WorkItems scheduled\n\n**Proposed Optimization - Option 1:** Single pass with multi-output:\n```swift\nprivate func updateAllCaches() {\n    cacheUpdateWorkItem?.cancel()\n    \n    let workItem = DispatchWorkItem { [sessions, viewModel] in\n        let lockedSessionIds = viewModel.lockedSessions\n        \n        // Single iteration - build all three caches\n        var directories: [String: [CDBackendSession]] = [:]\n        var queuedSessions: [CDBackendSession] = []\n        var priorityQueueSessions: [CDBackendSession] = []\n        \n        for session in sessions {\n            // Directory grouping\n            directories[session.workingDirectory, default: []].append(session)\n            \n            // Queue filtering\n            if session.isInQueue \u0026\u0026 !lockedSessionIds.contains(session.id.uuidString.lowercased()) {\n                queuedSessions.append(session)\n            }\n            \n            // Priority queue filtering\n            if session.isInPriorityQueue \u0026\u0026 !lockedSessionIds.contains(session.id.uuidString.lowercased()) {\n                priorityQueueSessions.append(session)\n            }\n        }\n        \n        // Sort and transform\n        let sortedQueuedSessions = queuedSessions.sorted { $0.queuePosition \u003c $1.queuePosition }\n        let sortedPriorityQueueSessions = priorityQueueSessions.sorted { /* three-level sort */ }\n        let directoryInfos = directories.map { /* transform to DirectoryInfo */ }.sorted { /* by lastModified */ }\n        \n        DispatchQueue.main.async {\n            self.cachedDirectories = directoryInfos\n            self.cachedQueuedSessions = sortedQueuedSessions\n            self.cachedPriorityQueueSessions = sortedPriorityQueueSessions\n        }\n    }\n    \n    cacheUpdateWorkItem = workItem\n    DispatchQueue.main.asyncAfter(deadline: .now() + 0.15, execute: workItem)\n}\n```\n\n**Performance Gains:**\n- Single iteration instead of 3\n- Single debounce instead of 3\n- Single memory allocation for WorkItem\n- Better CPU cache locality\n\n**Trade-offs:**\n- More complex code\n- All-or-nothing update (can't update just one cache)\n- Harder to maintain\n\n**Benchmark Needed:**\nTest with 100+ sessions to verify performance improvement justifies complexity.\n\n**Related:** voice-code-priority-queue-kjc [P2] tracks redundant cache updates on onChange.","status":"open","priority":3,"issue_type":"task","created_at":"2025-12-09T22:08:01.623836-06:00","updated_at":"2025-12-09T22:08:01.623836-06:00","source_repo":".","labels":["performance"]}
{"id":"voice-code-priority-queue-bm5","content_hash":"38719dcff4d24cc8fe25a4f2b9c5ebc143e41ca7cbfaf4ae4e26fbbc60f34c33","title":"Consider user feedback when auto-add silently adds to priority queue","description":"ConversationView auto-adds session to priority queue on sendPromptText (line 584-586) with no visual feedback. User doesn't know session was added. Compare to regular Queue which also auto-adds silently. Consider: 1) Brief toast 'Added to Priority Queue', 2) Subtle animation on toolbar star icon, 3) Keep silent for consistency. Needs UX decision.","status":"open","priority":3,"issue_type":"task","created_at":"2025-12-09T21:17:50.170231-06:00","updated_at":"2025-12-09T21:17:50.170231-06:00","source_repo":".","labels":["ux"]}
{"id":"voice-code-priority-queue-bqu","content_hash":"7a1cbc44724d982854f131cc575cb98f589b371170f0acb51fde3ab2e50cdaa6","title":"ConversationView priority queue toolbar buttons missing accessibility labels","description":"**File:** ConversationView.swift:331-350\n\n**Issue:** Priority queue toolbar buttons have no accessibility labels or hints. VoiceOver users hear only \"Button\" with no context about what button does.\n\n**Impact:** Screen reader users cannot:\n- Know which button adds vs removes from priority queue\n- Understand difference between Queue and Priority Queue buttons\n- Navigate toolbar efficiently with VoiceOver\n\n**Evidence:**\n```swift\n// ConversationView.swift:335-340\nButton(action: {\n    removeFromPriorityQueue(session)\n}) {\n    Image(systemName: \"star.slash.fill\")\n        .foregroundColor(.purple)\n}\n// ‚ùå No .accessibilityLabel() or .accessibilityHint()\n\n// ConversationView.swift:343-348\nButton(action: {\n    addToPriorityQueue(session)\n}) {\n    Image(systemName: \"star.fill\")\n        .foregroundColor(.purple)\n}\n// ‚ùå No .accessibilityLabel() or .accessibilityHint()\n```\n\n**Current VoiceOver Experience:**\n- Focus button: \"Button\" (no context)\n- Double-tap: Action executes but user doesn't know what it did\n\n**Proposed Fix:**\n```swift\nButton(action: { removeFromPriorityQueue(session) }) {\n    Image(systemName: \"star.slash.fill\")\n        .foregroundColor(.purple)\n}\n.accessibilityLabel(\"Remove from Priority Queue\")\n.accessibilityHint(\"Removes this session from the priority queue\")\n\nButton(action: { addToPriorityQueue(session) }) {\n    Image(systemName: \"star.fill\")\n        .foregroundColor(.purple)\n}\n.accessibilityLabel(\"Add to Priority Queue\")\n.accessibilityHint(\"Adds this session to the priority queue for quick access\")\n```\n\n**Related:**\n- voice-code-priority-queue-dpl [P2] tracks broader accessibility audit\n- voice-code-priority-queue-b0o [P3] tracks SessionInfoView Picker accessibility","status":"closed","priority":2,"issue_type":"bug","created_at":"2025-12-09T21:56:10.367303-06:00","updated_at":"2025-12-09T22:36:29.488183-06:00","closed_at":"2025-12-09T22:36:29.488183-06:00","source_repo":".","labels":["accessibility"]}
{"id":"voice-code-priority-queue-c2p8","content_hash":"1ae3e2fbed3c926e6721cfaafadefefe062c5df41f3f9076f19006c360a613e8","title":"Multiple onChange triggers create race conditions in cache updates","description":"**File:** DirectoryListView.swift:359-363, 364-367, 384-396\n\n**Issue:** Three separate onChange triggers can all fire simultaneously, causing race condition where updateCachedPriorityQueueSessions() is called from multiple code paths concurrently.\n\n**Impact:**\n- onChange(of: sessions.count) triggers update\n- onChange(of: viewModel.lockedSessions) triggers update\n- onReceive(.sessionListDidUpdate) triggers update\n- All three can fire at once during batch operations\n- Multiple WorkItems created, all canceled except last\n- Unnecessary CPU cycles from redundant updates\n\n**Evidence:**\n```swift\n// DirectoryListView.swift:359-367\n.onChange(of: sessions.count) { _ in\n    updateCachedDirectories()\n    updateCachedQueuedSessions()\n    updateCachedPriorityQueueSessions()  // ‚Üê Called\n}\n.onChange(of: viewModel.lockedSessions) { _ in\n    updateCachedQueuedSessions()\n    updateCachedPriorityQueueSessions()  // ‚Üê Called again\n}\n\n// Line 384-396\n.onReceive(NotificationCenter.default.publisher(for: .sessionListDidUpdate)) { _ in\n    // ...\n    sessions = try CDBackendSession.fetchActiveSessions(context: viewContext)\n    updateCachedDirectories()\n    updateCachedQueuedSessions()\n    updateCachedPriorityQueueSessions()  // ‚Üê Called third time\n}\n```\n\n**Race Condition Scenario:**\n1. NotificationCenter fires .sessionListDidUpdate\n2. Starts fetching sessions (line 389)\n3. While fetching, sessions.count changes (triggers onChange)\n4. Both paths call updateCachedPriorityQueueSessions()\n5. WorkItems race, both execute\n\n**Debouncing Helps But Doesn't Eliminate:**\n- Each call cancels previous WorkItem ‚úì\n- But still creates unnecessary WorkItems\n- Still wastes CPU cycles\n- Still creates memory pressure\n\n**Proposed Fix - Centralized Update:**\n```swift\n// Add single update trigger\n@State private var needsCacheUpdate = false\n\nprivate func requestCacheUpdate() {\n    needsCacheUpdate = true\n}\n\n// Single onChange handler\n.onChange(of: needsCacheUpdate) { _ in\n    guard needsCacheUpdate else { return }\n    needsCacheUpdate = false\n    \n    updateCachedDirectories()\n    updateCachedQueuedSessions()\n    updateCachedPriorityQueueSessions()\n}\n\n// Replace all triggers with:\n.onChange(of: sessions.count) { _ in requestCacheUpdate() }\n.onChange(of: viewModel.lockedSessions) { _ in requestCacheUpdate() }\n.onReceive(...) { _ in\n    sessions = try CDBackendSession.fetchActiveSessions(...)\n    requestCacheUpdate()\n}\n```\n\nOr use Combine to merge triggers:\n```swift\nprivate let cacheUpdateTrigger = PassthroughSubject\u003cVoid, Never\u003e()\n\n// In body:\n.onReceive(cacheUpdateTrigger.debounce(for: .milliseconds(150), scheduler: DispatchQueue.main)) { _ in\n    updateAllCaches()\n}\n\n// Trigger from multiple places:\n.onChange(of: sessions.count) { _ in cacheUpdateTrigger.send() }\n.onChange(of: viewModel.lockedSessions) { _ in cacheUpdateTrigger.send() }\n```\n\n**Related:** voice-code-priority-queue-kjc [P2] tracks redundant cache updates.","status":"open","priority":3,"issue_type":"bug","created_at":"2025-12-09T22:17:38.396369-06:00","updated_at":"2025-12-09T22:17:38.396369-06:00","source_repo":".","labels":["concurrency"]}
{"id":"voice-code-priority-queue-ccy","content_hash":"0e1be37a868010c145728e9f72d5253a7bb92c6d65bb7da49265d946d30c3aa9","title":"Add haptic feedback for priority queue operations","description":"Queue operations (removeFromQueue) don't provide haptic feedback. Priority queue add/remove in DirectoryListView should trigger UINotificationFeedbackGenerator for consistency with other destructive actions. Improves user confidence that action succeeded.","status":"open","priority":3,"issue_type":"task","created_at":"2025-12-09T21:11:44.79201-06:00","updated_at":"2025-12-09T21:11:44.79201-06:00","source_repo":".","labels":["ux"]}
{"id":"voice-code-priority-queue-ci2","content_hash":"8ac0ba444634482164901f16ab0729e301fa35560b7c6cb902c8ee08dad80736","title":"SessionInfoView Picker allows rapid changes creating save race condition","description":"**File:** SessionInfoView.swift:74-85\n\n**Issue:** Priority Picker allows rapid changes without waiting for CoreData save to complete. Multiple concurrent changePriority() calls race, making final priority value non-deterministic.\n\n**Fix:** Add @State isSavingPriority flag and disable Picker during save, or debounce changes.","status":"open","priority":3,"issue_type":"bug","created_at":"2025-12-09T21:37:16.064892-06:00","updated_at":"2025-12-09T21:37:16.064892-06:00","source_repo":".","labels":["ui-state"]}
{"id":"voice-code-priority-queue-cjf","content_hash":"2f2d71a689318627ba3484874c808fc4e8f6712dcdd2a39565b3a139c11058a9","title":"addToPriorityQueue mutates three properties without atomic rollback on save failure","description":"**File:** DirectoryListView.swift:554-567, ConversationView.swift:896-913\n\n**Issue:** When addToPriorityQueue() fails to save to CoreData, session object remains in inconsistent state. The function sets THREE properties optimistically but only ONE is conditionally reverted (none actually).\n\n**Impact:** Silent state corruption on save failures:\n- session.isInPriorityQueue = true (in memory)\n- session.priorityOrder = maxOrder + 1.0 (in memory)\n- session.priorityQueuedAt = Date() (in memory)\n- CoreData save fails\n- Properties remain set in memory but not persisted\n- Next view refresh loads old values from disk ‚Üí confusion\n\n**Evidence:**\n```swift\n// DirectoryListView.swift:558-566\nsession.isInPriorityQueue = true  // Mutate 1\n// Keep existing priority (default 10, or user-set value)\n// Set priorityOrder to end of priority group\nlet maxOrder = fetchMaxPriorityOrder(priority: session.priority)\nsession.priorityOrder = maxOrder + 1.0  // Mutate 2\nsession.priorityQueuedAt = Date()  // Mutate 3\n\nsaveContext()  // Can fail silently\nlogger.info(\"‚úÖ [PriorityQueue] Added session to priority queue (priority=\\(session.priority), order=\\(session.priorityOrder))\")\n```\n\nsaveContext() helper swallows errors (logs but doesn't return status).\n\n**Correct Pattern:**\n```swift\n// Save old values for rollback\nlet oldIsInQueue = session.isInPriorityQueue\nlet oldPriorityOrder = session.priorityOrder\nlet oldQueuedAt = session.priorityQueuedAt\n\nsession.isInPriorityQueue = true\nlet maxOrder = fetchMaxPriorityOrder(priority: session.priority)\nsession.priorityOrder = maxOrder + 1.0\nsession.priorityQueuedAt = Date()\n\ndo {\n    try viewContext.save()\n    logger.info(\"‚úÖ Added to priority queue\")\n} catch {\n    // Rollback ALL mutations\n    session.isInPriorityQueue = oldIsInQueue\n    session.priorityOrder = oldPriorityOrder\n    session.priorityQueuedAt = oldQueuedAt\n    logger.error(\"‚ùå Failed to add: \\(error.localizedDescription)\")\n}\n```\n\n**Why This Matters:**\n- Disk full scenarios\n- Database corruption\n- Constraint violations\n- Concurrent modification conflicts\n\n**Related:**\n- voice-code-priority-queue-cjo [P2]: changePriority rollback\n- voice-code-priority-queue-v4w [P2]: SessionInfoView rollback\n- voice-code-priority-queue-nxy [P3]: ConversationView rollback","status":"closed","priority":2,"issue_type":"bug","created_at":"2025-12-09T22:12:58.647578-06:00","updated_at":"2025-12-09T22:34:39.546386-06:00","closed_at":"2025-12-09T22:34:39.546386-06:00","source_repo":".","labels":["state-consistency"]}
{"id":"voice-code-priority-queue-cjo","content_hash":"be4e8ddf7125cadb8ddc3abca776a21494aca6b282eb496b86956d8f4686f385","title":"Add rollback on changePriority failure","description":"changePriority modifies session.priority and session.priorityOrder before save. If save fails, session object left in inconsistent state (new priority, old order). SwiftUI will display wrong values. Fix: Save old values, restore on catch, or use NSManagedObjectContext.rollback().","status":"closed","priority":2,"issue_type":"bug","created_at":"2025-12-09T21:04:39.466592-06:00","updated_at":"2025-12-09T22:40:52.569136-06:00","closed_at":"2025-12-09T22:40:52.569136-06:00","source_repo":"."}
{"id":"voice-code-priority-queue-das","content_hash":"0ac08b4835cd28b565abd8ada46d6381f9ce0b67cdb5674e1c016d3dcebc4bc0","title":"NSPredicate uses string format instead of type-safe parameterized predicates","description":"**File:** DirectoryListView.swift:547-549, ConversationView.swift:963-965, SessionInfoView.swift:263-265\n\n**Issue:** NSPredicate constructed using string format with user-controlled priority value. While Int32 type provides some safety, predicate injection is theoretically possible if priority value is manipulated.\n\n**Impact:**\n- Low risk because priority is Int32 (type-safe)\n- But violates secure coding practices\n- Could be exploited if CoreData implementation changes\n- Sets bad precedent for other predicates\n\n**Evidence:**\n```swift\n// DirectoryListView.swift:548\nrequest.predicate = NSPredicate(format: \"isInPriorityQueue == YES AND priority == %d\", priority)\n// ‚ùå String interpolation-based predicate\n```\n\n**Why This Is Low Risk:**\n- priority is Int32, not String\n- %d format specifier expects integer\n- No string concatenation or injection points\n- CoreData validates types\n\n**Why This Matters:**\n- Establishes pattern for predicate construction\n- Other code might copy this pattern with String values\n- Defense in depth principle\n\n**Secure Alternatives:**\n\n1. **Type-safe predicate builder:**\n```swift\nlet predicate = NSCompoundPredicate(andPredicateWithSubpredicates: [\n    NSPredicate(format: \"isInPriorityQueue == YES\"),\n    NSPredicate(format: \"priority == %@\", NSNumber(value: priority))\n])\n```\n\n2. **Parameterized predicate:**\n```swift\nlet predicateTemplate = NSPredicate(format: \"isInPriorityQueue == YES AND priority == \")\nlet predicate = predicateTemplate.withSubstitutionVariables([\"PRIORITY\": priority])\n```\n\n3. **Key path predicate (Swift 5.9+):**\n```swift\nrequest.predicate = #Predicate\u003cCDBackendSession\u003e { session in\n    session.isInPriorityQueue \u0026\u0026 session.priority == priority\n}\n```\n\n**Best Practice:**\nUse parameterized predicates or type-safe builders for all CoreData queries, even with Int values.\n\n**Note:** Existing codebase uses string-format predicates throughout (e.g., DirectoryListView.swift:516, 879), so this is consistent with current patterns. Should be addressed in broader security audit.\n\n**Related:** voice-code-priority-queue-9wb [P2] tracks NSPredicate format string type safety verification.","status":"closed","priority":3,"issue_type":"bug","created_at":"2025-12-09T22:13:07.311653-06:00","updated_at":"2025-12-10T10:01:45.224503-06:00","closed_at":"2025-12-10T10:01:45.224503-06:00","source_repo":".","labels":["security"]}
{"id":"voice-code-priority-queue-dbc","content_hash":"3a0222ebaebeee59841a8b5d64681c84d70beeef0bbcb486245fc70aeb246c91","title":"No analytics tracking priority queue feature usage or performance","description":"**File:** All priority queue implementation files\n\n**Task:** No analytics or telemetry tracking priority queue feature usage. Cannot measure adoption, effectiveness, or user behavior patterns.\n\n**Missing Metrics:**\n\n1. **Feature Adoption:**\n   - How many users enable Priority Queue?\n   - Percentage of users with feature enabled\n   - Time to first enable after app install\n\n2. **Session Management:**\n   - Average sessions in priority queue per user\n   - Distribution of priority values (1, 5, 10)\n   - How often users change priorities\n   - Add vs remove actions per session\n\n3. **User Behavior:**\n   - How often do users interact with Priority Queue section?\n   - Do users use toolbar buttons or section swipe actions?\n   - How long do sessions stay in priority queue?\n   - Do users remove sessions or let them accumulate?\n\n4. **Performance Impact:**\n   - Cache update latency percentiles (p50, p95, p99)\n   - CoreData save duration for priority queue operations\n   - Memory usage with large priority queues\n\n5. **Feature Conflicts:**\n   - How many users enable BOTH Queue and Priority Queue?\n   - Do users understand the difference?\n   - Which feature is used more?\n\n**Proposed Implementation:**\n```swift\n// Analytics wrapper\nclass PriorityQueueAnalytics {\n    static func trackEnabled() {\n        Analytics.track(\"priority_queue_enabled\")\n    }\n    \n    static func trackSessionAdded(priority: Int32) {\n        Analytics.track(\"priority_queue_session_added\", properties: [\n            \"priority\": priority\n        ])\n    }\n    \n    static func trackPriorityChanged(from: Int32, to: Int32) {\n        Analytics.track(\"priority_queue_priority_changed\", properties: [\n            \"from_priority\": from,\n            \"to_priority\": to\n        ])\n    }\n    \n    static func trackCacheUpdateDuration(_ duration: TimeInterval) {\n        Analytics.track(\"priority_queue_cache_update\", properties: [\n            \"duration_ms\": Int(duration * 1000)\n        ])\n    }\n}\n\n// Usage in code:\nprivate func addToPriorityQueue(_ session: CDBackendSession) {\n    guard !session.isInPriorityQueue else { return }\n    \n    session.isInPriorityQueue = true\n    // ...\n    \n    PriorityQueueAnalytics.trackSessionAdded(priority: session.priority)\n}\n```\n\n**Privacy Considerations:**\n- Don't track session content or names\n- Don't track working directory paths\n- Aggregate metrics only\n- Allow opt-out\n\n**Benefits:**\n- Measure feature success\n- Identify UX pain points\n- Inform future improvements\n- Justify development investment\n\n**Related:** voice-code-priority-queue-wp1 [P4] tracks adding telemetry/analytics.","status":"open","priority":4,"issue_type":"task","created_at":"2025-12-09T22:08:04.840995-06:00","updated_at":"2025-12-09T22:08:04.840995-06:00","source_repo":".","labels":["analytics"]}
{"id":"voice-code-priority-queue-de9","content_hash":"e4bee8f131b6e48e120aff5f732b5b6fe0473d83c6fa90c4b4e1e1ab29b347fb","title":"AppSettings priorityQueueEnabled doesn't write default value to UserDefaults on first launch","description":"**File:** AppSettings.swift:62-66\n\n**Issue:** priorityQueueEnabled @Published property uses didSet to save to UserDefaults, but init (line 255) loads with `as? Bool ?? false`. If UserDefaults returns nil, default is false, but there's no code to SET the default in UserDefaults.\n\n**Impact:** First launch behavior is inconsistent:\n- queueEnabled has explicit `object(forKey:)` check and defaults to false (line 254)\n- priorityQueueEnabled uses same pattern (line 255)\n- Both work correctly but neither writes default to UserDefaults on first launch\n\n**Current Pattern:**\n```swift\n// AppSettings.swift:62-66\n@Published var priorityQueueEnabled: Bool {\n    didSet {\n        UserDefaults.standard.set(priorityQueueEnabled, forKey: \"priorityQueueEnabled\")\n    }\n}\n\n// Init (line 255):\nself.priorityQueueEnabled = UserDefaults.standard.object(forKey: \"priorityQueueEnabled\") as? Bool ?? false\n```\n\n**Result:** UserDefaults has no \"priorityQueueEnabled\" key until user toggles the setting at least once.\n\n**Not a Bug But Inconsistent With Other Settings:**\nCompare to selectedVoiceIdentifier (lines 241-246) which DOES write default on first launch.\n\n**Proposed Fix (Optional):** Explicitly set default if missing:\n```swift\nif UserDefaults.standard.object(forKey: \"priorityQueueEnabled\") == nil {\n    UserDefaults.standard.set(false, forKey: \"priorityQueueEnabled\")\n}\nself.priorityQueueEnabled = UserDefaults.standard.bool(forKey: \"priorityQueueEnabled\")\n```\n\n**Note:** Current code works fine - this is a consistency/code quality issue not a functional bug.","status":"closed","priority":3,"issue_type":"bug","created_at":"2025-12-09T21:46:32.483232-06:00","updated_at":"2025-12-10T09:56:44.102223-06:00","closed_at":"2025-12-10T09:56:44.102223-06:00","source_repo":".","labels":["code-quality"]}
{"id":"voice-code-priority-queue-df9","content_hash":"5f082144e6fa68cfb86f8595aa56a132a6e50c18f3c8d6d1a92a91eaadde99e1","title":"Inconsistent error handling between DirectoryListView and ConversationView","description":"DirectoryListView.saveContext() uses do-catch with logger.error (lines 537-542). ConversationView addToPriorityQueue/removeFromPriorityQueue use do-catch with print (lines 907-912, 925-930). Inconsistent patterns. Should unify error handling approach - either all use logger or all use print. Recommend logger for consistency.","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-09T21:17:41.36805-06:00","updated_at":"2025-12-09T22:36:03.105815-06:00","closed_at":"2025-12-09T22:36:03.105815-06:00","source_repo":".","labels":["code-quality"]}
{"id":"voice-code-priority-queue-dfm","content_hash":"d16b86c2fa8ac7b2a83fadb29712c029bdc00cba3bc6b77b39ec705d68b7361a","title":"Sessions array snapshot in WorkItem may contain deleted objects","description":"updateCachedPriorityQueueSessions captures sessions array (line 468). If session deleted between capture and WorkItem execution (150ms+ delay), filtering accesses deleted object properties. CoreData returns nil for deleted objects but .isInPriorityQueue throws. Add: .filter { !session.isDeleted } before .filter { isInPriorityQueue }. Or check session.managedObjectContext != nil.","status":"open","priority":3,"issue_type":"bug","created_at":"2025-12-09T21:28:55.871607-06:00","updated_at":"2025-12-09T21:28:55.871607-06:00","source_repo":"."}
{"id":"voice-code-priority-queue-dhi","content_hash":"0d658f52f9660f590cdfc3e481d8c493d97a85db6607d761ee9f7b41e7cdc664","title":"SessionInfoView fetchMaxPriorityOrder silently ignores CoreData fetch errors","description":"**File:** SessionInfoView.swift:262-267\n\n**Issue:** fetchMaxPriorityOrder() has no error handling or logging. Silent try? means fetch failures are invisible, and returns 0.0 which is indistinguishable from \"no sessions in priority group\".\n\n**Impact:** \n- CoreData fetch errors (disk full, constraint violations) are silently ignored\n- Developer can't diagnose why priorityOrder calculation is wrong\n- 0.0 return value is ambiguous (error vs empty)\n\n**Evidence:**\n```swift\n// SessionInfoView.swift:265-266\nlet sessions = (try? viewContext.fetch(request)) ?? []\nreturn sessions.map { $0.priorityOrder }.max() ?? 0.0\n```\n\n**Fix:** Add error logging:\n```swift\nlet sessions: [CDBackendSession]\ndo {\n    sessions = try viewContext.fetch(request)\n} catch {\n    logger.error(\"Failed to fetch max priority order for priority \\(priority): \\(error.localizedDescription)\")\n    return 0.0\n}\nreturn sessions.map { $0.priorityOrder }.max() ?? 0.0\n```\n\n**Related:** voice-code-priority-queue-6vh tracks same issue for all three implementations.","status":"closed","priority":2,"issue_type":"bug","created_at":"2025-12-09T21:45:19.372456-06:00","updated_at":"2025-12-09T22:36:03.10532-06:00","closed_at":"2025-12-09T22:36:03.10532-06:00","source_repo":".","labels":["data-validation"]}
{"id":"voice-code-priority-queue-dns","content_hash":"f9ed3d037b76677bcf6b3ad028c351bc63cdde65176c9a5b4c1fd603677ce59e","title":"Priority queue code has zero documentation explaining design decisions","description":"**File:** All priority queue source files\n\n**Issue:** Priority queue implementation has ZERO code comments explaining design decisions, algorithms, or edge cases. Future maintainers must reverse-engineer intent.\n\n**Missing Documentation:**\n\n1. **Why priorityOrder is Double not Int:**\n   - No comment explaining future-proofing for fractional ordering\n   - No comment explaining drag-to-reorder midpoint calculation\n\n2. **Why three-level sort:**\n   - No comment explaining priority ‚Üí priorityOrder ‚Üí UUID hierarchy\n   - No comment explaining why UUID is lexicographic not chronological\n\n3. **Why debouncing is 150ms:**\n   - No comment explaining why this specific value\n   - No comment explaining optimization trade-off\n\n4. **Why auto-add happens on every send:**\n   - No comment explaining idempotent design\n   - No comment explaining why not first-message-only\n\n5. **Why isInPriorityQueue separate from queue:**\n   - No comment explaining relationship between Queue and Priority Queue\n   - No comment explaining whether features are mutually exclusive\n\n**Example of Good Documentation:**\n```swift\n/// Adds session to priority queue using FIFO ordering within priority groups.\n///\n/// **Algorithm:**\n/// 1. Fetch maximum priorityOrder for sessions with same priority\n/// 2. Assign priorityOrder = max + 1.0 (ensures FIFO within priority level)\n/// 3. Sort uses three-level hierarchy: priority ASC ‚Üí priorityOrder ASC ‚Üí UUID lexicographic\n///\n/// **Why Double for priorityOrder:**\n/// Allows future drag-to-reorder feature to insert sessions between existing ones\n/// by calculating midpoint (e.g., insert between 1.0 and 2.0 ‚Üí 1.5)\n///\n/// **Edge Cases:**\n/// - If no sessions in priority group, maxOrder = 0.0 ‚Üí new session gets 1.0\n/// - If CoreData fetch fails, returns 0.0 as fallback (see fetchMaxPriorityOrder)\n/// - Idempotent: calling multiple times has no effect (guard on isInPriorityQueue)\n///\n/// - Parameter session: Session to add to priority queue\n/// - Throws: CoreData save errors are logged but not propagated\nprivate func addToPriorityQueue(_ session: CDBackendSession) {\n    // ...\n}\n```\n\n**Current State:**\n```swift\n// DirectoryListView.swift:554\nprivate func addToPriorityQueue(_ session: CDBackendSession) {\n    // ‚ùå ZERO documentation\n    guard !session.isInPriorityQueue else { return }\n    // ...\n}\n```\n\n**Proposed Standards:**\n- Every priority queue function has doc comment\n- Complex algorithms have inline comments\n- Edge cases documented with examples\n- Design decisions explained (why not what)\n\n**Benefits:**\n- Easier onboarding for new developers\n- Prevents accidental breaking of subtle invariants\n- Documents assumptions for future refactoring\n- Explains \"why\" not just \"what\"","status":"closed","priority":3,"issue_type":"bug","created_at":"2025-12-09T22:07:58.378379-06:00","updated_at":"2025-12-10T10:01:28.730863-06:00","closed_at":"2025-12-10T10:01:28.730863-06:00","source_repo":".","labels":["documentation"]}
{"id":"voice-code-priority-queue-do2","content_hash":"21be9281190fce0941824a3416046f3eb64ed1f1a23d3332b006837c95c75188","title":"Priority changes don't trigger DirectoryListView updates via CoreData observation","description":"DirectoryListView uses @State var sessions array, not @FetchRequest. When session.priority changes in SessionInfoView, DirectoryListView doesn't observe the CoreData change. Cache only updates on sessions.count change or notification. Critical: Priority changes won't reflect in list until user navigates away. Fix: Use @FetchRequest or add KVO observation for session property changes.","status":"closed","priority":0,"issue_type":"bug","created_at":"2025-12-09T21:10:44.997442-06:00","updated_at":"2025-12-09T22:24:02.141528-06:00","closed_at":"2025-12-09T22:24:02.141528-06:00","source_repo":"."}
{"id":"voice-code-priority-queue-dpl","content_hash":"edb507581f8a478cc8181fbe69ff4c8616f975e7d1647589ae5ff60ca7987be6","title":"Add accessibility labels to priority queue UI","description":"**Partial fix:** Toolbar buttons in ConversationView now have accessibility labels/hints (fixed in voice-code-priority-queue-bqu).\n\n**Remaining items:**\n1. SettingsView Priority Queue Toggle - needs accessibilityLabel\n2. SessionInfoView Priority Picker - needs accessibilityLabel for VoiceOver\n\n**Status:** Downgrade to P3 since critical toolbar buttons are done.","status":"open","priority":3,"issue_type":"task","created_at":"2025-12-09T21:00:26.168291-06:00","updated_at":"2025-12-10T09:35:17.959545-06:00","source_repo":".","labels":["accessibility"]}
{"id":"voice-code-priority-queue-e7z","content_hash":"1218a57067fec830cd49f5074b98fc210c4e69dc4de5d9402afa661135ddbc05","title":"Verify CoreData automatic migration with detailed logging","description":"**File:** PersistenceController.swift:61-65\n\n**Task:** Add logging to confirm CoreData automatic migration succeeded and verify existing sessions retain data after migration from VoiceCode.xcdatamodel to VoiceCode 2.xcdatamodel.\n\n**Why:** No way to diagnose migration issues from logs - can't tell if load failure was migration error or corrupt store.","status":"open","priority":3,"issue_type":"task","created_at":"2025-12-09T21:37:17.541687-06:00","updated_at":"2025-12-09T21:37:17.541687-06:00","source_repo":".","labels":["data-validation"]}
{"id":"voice-code-priority-queue-ea0","content_hash":"db99973b01c05d27a9f3c59b0c3247c16916776049702c9bbeb3574ae2f56378","title":"DirectoryListView addToPriorityQueue missing updateCachedPriorityQueueSessions call","description":"**File:** DirectoryListView.swift:554-567\n\n**Issue:** addToPriorityQueue() calls saveContext() but does NOT call updateCachedPriorityQueueSessions(), unlike removeFromPriorityQueue() which does (line 579). This creates inconsistency where removals update the UI cache but additions don't.\n\n**Impact:** When user adds a session to priority queue via DirectoryListView's context menu or buttons, the Priority Queue section won't show the new session until the next cache update trigger.\n\n**Fix:** Add `updateCachedPriorityQueueSessions()` call after `saveContext()` in addToPriorityQueue() at line 565.","status":"closed","priority":2,"issue_type":"bug","created_at":"2025-12-09T21:37:06.798346-06:00","updated_at":"2025-12-09T22:34:39.547273-06:00","closed_at":"2025-12-09T22:34:39.547273-06:00","source_repo":".","labels":["code-quality"]}
{"id":"voice-code-priority-queue-ed4","content_hash":"394fe1f69522523d37c3574c87fd9c5048daa9983d4500ba95d716ab584153df","title":"DirectoryListView updateCachedPriorityQueueSessions may access sessions during mutation","description":"**File:** DirectoryListView.swift:464-502\n\n**Issue:** updateCachedPriorityQueueSessions() reads from sessions array and viewModel.lockedSessions but doesn't lock or synchronize access. If sessions array is mutated during filter/sort operations, could cause crashes or undefined behavior.\n\n**Impact:** Race condition if:\n1. NotificationCenter fires .sessionListDidUpdate (line 384)\n2. Triggers sessions refetch (line 389)\n3. sessions array replaced mid-iteration\n4. updateCachedPriorityQueueSessions WorkItem executes with stale snapshot\n\n**Evidence:**\n```swift\n// DirectoryListView.swift:437-442, 468-477\nlet workItem = DispatchWorkItem { [viewModel, sessions] in\n    let lockedSessionIds = viewModel.lockedSessions\n    \n    let updatedSessions = sessions  // ‚ùå Snapshot taken but not immutable\n        .filter { $0.isInPriorityQueue }  // If sessions mutates during iteration?\n        .filter { ... }\n        .sorted { ... }\n}\n```\n\n**Scenario:**\n1. sessions = [A, B, C]\n2. WorkItem captures [viewModel, sessions] in closure\n3. Before WorkItem executes (150ms debounce), NotificationCenter fires\n4. sessions = [A, B, D] (C removed, D added)\n5. WorkItem executes with OLD sessions array [A, B, C]\n6. Result: Cache shows stale session C\n\n**Not Necessarily a Crash:** Swift arrays are value types, so capture list makes a copy. BUT @State wrapper may have reference semantics.\n\n**Verification Needed:** Test if sessions capture is value (safe) or reference (unsafe).\n\n**Fix (If Needed):**\n```swift\nlet sessionSnapshot = sessions.map { $0 }  // Explicit copy\nlet workItem = DispatchWorkItem { [viewModel, sessionSnapshot] in\n    let updatedSessions = sessionSnapshot\n        .filter { ... }\n}\n```","status":"closed","priority":2,"issue_type":"bug","created_at":"2025-12-09T21:48:22.047625-06:00","updated_at":"2025-12-10T09:36:29.873626-06:00","closed_at":"2025-12-10T09:36:29.873626-06:00","source_repo":".","labels":["concurrency"]}
{"id":"voice-code-priority-queue-egf","content_hash":"1b777634b8ea1a875882fe147c28586024f5bf2ea13ad6d3b38cf8af0951ae3b","title":"Phase 6: Bug Fixes - Address issues found during testing","description":"Fix any bugs or issues discovered during manual and automated testing.\n\nCommon issues to watch for:\n1. Race conditions with CoreData saves\n2. UI flickering during reorder\n3. Incorrect sorting after priority changes\n4. Memory leaks with large queues\n5. Crash when removing locked sessions\n6. Settings not persisting correctly\n7. Auto-add duplicating sessions\n8. Drag gesture conflicts with swipe-to-delete\n\nProcess:\n1. Review test reports from Phase 6 manual testing\n2. Reproduce each reported bug\n3. Write failing unit test for each bug\n4. Fix bug and verify test passes\n5. Verify fix does not introduce regressions\n6. Update documentation if behavior clarified\n\nVerification:\n1. All reported bugs fixed and verified\n2. All unit tests pass\n3. Manual re-test of affected scenarios\n4. No new bugs introduced\n5. Code reviewed for edge cases","status":"open","priority":4,"issue_type":"task","created_at":"2025-12-07T17:59:05.335013-06:00","updated_at":"2025-12-07T17:59:05.335013-06:00","source_repo":".","dependencies":[{"issue_id":"voice-code-priority-queue-egf","depends_on_id":"voice-code-priority-queue-3yf","type":"blocks","created_at":"2025-12-07T17:59:50.086356-06:00","created_by":"travisbrown"}]}
{"id":"voice-code-priority-queue-ekf","content_hash":"04aedc884b4f02da8684a1491a04fdc164e75c7e4e12f5b49f79a01ced3e9b22","title":"Picker Binding doesn't handle CoreData save failure gracefully","description":"SessionInfoView Picker Binding (line 75-79) calls changePriority which may fail to save. On failure, Picker shows new value but DB has old value - UI/data mismatch. Picker should: 1) Optimistically show new value, 2) Revert on save failure, 3) Show error alert. Current: shows toast on success but silent on failure (print only). User thinks priority changed but didn't.","status":"open","priority":3,"issue_type":"bug","created_at":"2025-12-09T21:28:46.571468-06:00","updated_at":"2025-12-09T21:28:46.571468-06:00","source_repo":"."}
{"id":"voice-code-priority-queue-euo","content_hash":"b1a2cff4ec545cb920cb22cfcbb62bbda3e7d08435967b69ddadbd5ad518a5d5","title":"Phase 2: Integration Test - End-to-end priority queue workflow","description":"Write integration test that validates complete add-to-queue workflow from message send to UI display.\n\nFILE TO CREATE:\n- ios/VoiceCodeTests/PriorityQueueIntegrationTests.swift\n\nTEST COVERAGE:\n\nTest 1: testCompleteAddWorkflow\nScenario: User sends message, session added to priority queue, appears in DirectoryListView\nSteps:\n1. Mock settings.priorityQueueEnabled = true\n2. Create test session\n3. Simulate sending message (trigger addToPriorityQueue)\n4. Assert session.isInPriorityQueue == true\n5. Assert session.priority == 10\n6. Call updateCachedPriorityQueueSessions\n7. Assert session appears in priorityQueueSessions array\n8. Verify sorted position correct\n\nTest 2: testCompleteRemoveWorkflow\nScenario: User removes session from queue via swipe action\nSteps:\n1. Add session to priority queue\n2. Verify in priorityQueueSessions array\n3. Call removeFromPriorityQueue\n4. Assert session.isInPriorityQueue == false\n5. Call updateCachedPriorityQueueSessions\n6. Assert session NOT in priorityQueueSessions array\n\nTest 3: testSessionLockingWorkflow\nScenario: Session locks when processing, disappears from queue, reappears after unlock\nSteps:\n1. Add session to priority queue\n2. Verify in priorityQueueSessions\n3. Simulate locking (add to lockedSessionIds)\n4. Call updateCachedPriorityQueueSessions\n5. Assert session NOT in priorityQueueSessions\n6. Simulate unlock (remove from lockedSessionIds)\n7. Call updateCachedPriorityQueueSessions\n8. Assert session back in priorityQueueSessions\n\nTest 4: testMultipleSessionsSorting\nScenario: Multiple sessions with different priorities sort correctly\nSteps:\n1. Create 10 sessions with random priorities (0-20)\n2. Add all to priority queue\n3. Call updateCachedPriorityQueueSessions\n4. Assert sessions sorted by priority ascending\n5. Within same priority, assert sorted by priorityOrder\n\nTest 5: testPersistenceAcrossContexts\nScenario: Priority queue state persists when app restarts\nSteps:\n1. Add sessions to priority queue\n2. Save CoreData context\n3. Create new persistent container\n4. Fetch sessions from new context\n5. Assert isInPriorityQueue preserved\n6. Assert priority and priorityOrder preserved\n7. Verify sort order maintained\n\nACCEPTANCE CRITERIA:\n‚úÖ All 5 integration tests pass\n‚úÖ Tests use real CoreData stack (not mocked)\n‚úÖ Tests validate full workflows end-to-end\n‚úÖ Tests catch integration bugs unit tests might miss\n‚úÖ Test execution time \u003c 5 seconds total","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-08T19:34:46.056899-06:00","updated_at":"2025-12-09T20:23:05.203279-06:00","closed_at":"2025-12-09T20:23:05.203279-06:00","source_repo":".","dependencies":[{"issue_id":"voice-code-priority-queue-euo","depends_on_id":"voice-code-priority-queue-6vx","type":"blocks","created_at":"2025-12-08T19:34:51.366113-06:00","created_by":"travisbrown"},{"issue_id":"voice-code-priority-queue-euo","depends_on_id":"voice-code-priority-queue-3dw","type":"blocks","created_at":"2025-12-08T19:34:51.764832-06:00","created_by":"travisbrown"}]}
{"id":"voice-code-priority-queue-f3l","content_hash":"d67ef455b1e0308650883dbc70c95bc8471572f489c3c16b2f63b152c25cf3d3","title":"addToPriorityQueue proceeds with fetch failure using potentially incorrect priorityOrder","description":"**Analysis:** Current behavior is acceptable fallback.\n\n**What happens on fetch failure:**\n1. fetchMaxPriorityOrder catches error, logs it, returns 0.0\n2. addToPriorityQueue sets priorityOrder = 0.0 + 1.0 = 1.0\n3. Session becomes first in its priority group\n\n**Why this is acceptable:**\n- Session IS added to queue (user's intent fulfilled)\n- priorityOrder collision is handled by session ID tiebreaker\n- Error is logged for debugging (Logger.priorityQueue.error)\n- CoreData failures are rare in practice\n\n**Worst case:**\n- Two sessions with same priorityOrder\n- Sort uses session ID as tiebreaker (deterministic)\n- FIFO slightly violated but functionally correct\n\n**Recommendation:** Downgrade to P4. Defensive coding improvement, not a functional bug.","status":"open","priority":4,"issue_type":"bug","created_at":"2025-12-09T22:13:13.63992-06:00","updated_at":"2025-12-10T09:57:15.140824-06:00","source_repo":".","labels":["reliability"]}
{"id":"voice-code-priority-queue-ft3","content_hash":"4e29d305ba8bc2983934c02882dcab9fec52662103d44900e743c267ec1c0dbf","title":"Fix shared expansion state between Queue and Priority Queue","description":"DirectoryListView line 199 uses isQueueExpanded for Priority Queue section, but line 178 uses same state for Queue section. Bug: Collapsing one section collapses both. Fix: Add separate @State var isPriorityQueueExpanded.","status":"closed","priority":0,"issue_type":"bug","created_at":"2025-12-09T20:59:02.287064-06:00","updated_at":"2025-12-09T22:24:02.141414-06:00","closed_at":"2025-12-09T22:24:02.141414-06:00","source_repo":"."}
{"id":"voice-code-priority-queue-gby","content_hash":"4804c8e451aad917ac0430759c62d66762e45c78ecf3d22b697b668c1063db67","title":"Phase 5: Tests - Drag-to-reorder unit tests","description":"Comprehensive unit tests for drag-to-reorder functionality.\n\nFILE TO MODIFY:\n- ios/VoiceCodeTests/PriorityQueueManagementTests.swift\n\nTESTS TO ADD (8 tests):\n\n1. testDragBetweenSamePriority\n   - Sessions: P10/order:50, P10/order:100\n   - Drag new session between them\n   - Assert priority=10, priorityOrder=75 (midpoint)\n\n2. testDragBetweenDifferentPriorities\n   - Sessions: P5/order:100, P10/order:50\n   - Drag between them\n   - Assert adopts destination priority (P10)\n   - Assert positioned correctly in P10 group\n\n3. testDragToTop\n   - 3 sessions in queue\n   - Drag session to top (above=nil, below=first)\n   - Assert priority = below.priority\n   - Assert priorityOrder \u003c below.priorityOrder\n\n4. testDragToBottom\n   - 3 sessions in queue\n   - Drag to bottom (above=last, below=nil)\n   - Assert priority = above.priority\n   - Assert priorityOrder \u003e above.priorityOrder\n\n5. testDragWithinSamePriorityGroup\n   - All sessions P10\n   - Drag from position 0 to position 2\n   - Assert stays P10\n   - Assert priorityOrder between neighbors\n\n6. testDragAcrossPriorityBoundary\n   - Sessions: P5, P5, P10, P10\n   - Drag P5 session into P10 group\n   - Assert priority changes to P10\n   - Assert positioned correctly\n\n7. testDragSingleSession\n   - Only 1 session in queue\n   - Drag to same position\n   - Assert no changes (no-op)\n\n8. testPriorityOrderPrecision\n   - Create many sessions, drag repeatedly\n   - Assert priorityOrder maintains precision\n   - Assert no floating-point errors after 100 drags\n\nACCEPTANCE CRITERIA:\n‚úÖ All 8 tests pass\n‚úÖ Tests cover all scenarios in reorderSession\n‚úÖ Edge cases handled correctly\n‚úÖ No flaky tests\n‚úÖ Test execution \u003c 3 seconds","status":"closed","priority":4,"issue_type":"task","created_at":"2025-12-07T17:58:14.18533-06:00","updated_at":"2025-12-10T18:13:50.83346-06:00","closed_at":"2025-12-10T18:13:50.83346-06:00","source_repo":".","dependencies":[{"issue_id":"voice-code-priority-queue-gby","depends_on_id":"voice-code-priority-queue-3z6","type":"blocks","created_at":"2025-12-07T17:59:39.861857-06:00","created_by":"travisbrown"}]}
{"id":"voice-code-priority-queue-gg8y","content_hash":"74b5cf40e7219975010f504e1ae1cfd6dd461b7595988428ca0a449ade6b29be","title":"Auto-add fix: Run existing test suite to verify no regressions","description":"After implementing the session_updated auto-add, run the existing PriorityQueueManagementTests (104 tests) to ensure no regressions were introduced.\n\nCommand: xcodebuild test -scheme VoiceCode -destination 'platform=iOS Simulator,name=iPhone 15' -only-testing:VoiceCodeTests/PriorityQueueManagementTests\n\nAll 104 existing tests must pass before proceeding with new tests.","acceptance_criteria":"All 104 existing PriorityQueueManagementTests pass with no failures or skips","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-10T20:10:36.05652-06:00","updated_at":"2025-12-10T20:30:03.057942-06:00","closed_at":"2025-12-10T20:30:03.057942-06:00","source_repo":".","dependencies":[{"issue_id":"voice-code-priority-queue-gg8y","depends_on_id":"voice-code-priority-queue-sru9","type":"blocks","created_at":"2025-12-10T20:10:42.624493-06:00","created_by":"travisbrown"}]}
{"id":"voice-code-priority-queue-glo","content_hash":"0a972ed4c26c616617762347023fbc611a48ace21ab3cae994f40d0b4bf1c243","title":"Review Section header text consistency across Queue and Priority Queue","description":"Queue section header: 'Queue'. Priority Queue section header: 'Priority Queue'. Consider consistency: either both short ('Queue' / 'Priority') or both descriptive ('Task Queue' / 'Priority Queue'). Also affects Settings section headers. Minor UX polish.","status":"open","priority":4,"issue_type":"task","created_at":"2025-12-09T21:12:19.87675-06:00","updated_at":"2025-12-09T21:12:19.87675-06:00","source_repo":".","labels":["ux"]}
{"id":"voice-code-priority-queue-gms","content_hash":"245e82d2344f72e12cb4d665ce3c7930e86054ee3184e911cc234f395fe518c7","title":"Document that addToPriorityQueue preserves existing priority value","description":"addToPriorityQueue comment says 'Keep existing priority (default 10, or user-set value)' (DirectoryListView:559, ConversationView:901). This means if session previously had priority=1 and was removed, re-adding keeps priority=1. Behavior correct but subtle. Add doc explaining use case: allows temporary queue removal without losing priority preference.","status":"open","priority":3,"issue_type":"task","created_at":"2025-12-09T21:17:58.251156-06:00","updated_at":"2025-12-09T21:17:58.251156-06:00","source_repo":".","labels":["documentation"]}
{"id":"voice-code-priority-queue-hby","content_hash":"c4d435e1154247bc439c63f9be7d1e10ec7c6d6bd22e64abf19f9427689a690e","title":"SessionInfoView Priority Picker labels not localization-ready","description":"**File:** SessionInfoView.swift:81-83\n\n**Issue:** Priority Picker labels hardcode English text (\"High\", \"Medium\", \"Low\") and numeric values in parentheses. Not localization-ready.\n\n**Impact:** Non-English users see English priority labels. Numeric values (1, 5, 10) are shown but may not be culturally intuitive.\n\n**Evidence:**\n```swift\nText(\"High (1)\").tag(Int32(1))\nText(\"Medium (5)\").tag(Int32(5))\nText(\"Low (10)\").tag(Int32(10))\n```\n\n**Fix (when adding localization):**\n```swift\nText(LocalizedStringKey(\"priority.high\")).tag(Int32(1))\nText(LocalizedStringKey(\"priority.medium\")).tag(Int32(5))\nText(LocalizedStringKey(\"priority.low\")).tag(Int32(10))\n```\n\nOr use SF Symbols for universal meaning:\n```swift\nLabel(\"High\", systemImage: \"exclamationmark.3\").tag(Int32(1))\nLabel(\"Medium\", systemImage: \"exclamationmark.2\").tag(Int32(5))\nLabel(\"Low\", systemImage: \"exclamationmark\").tag(Int32(10))\n```\n\n**Note:** Low priority for now - no localization infrastructure exists yet. Related to voice-code-priority-queue-2e6.","status":"open","priority":3,"issue_type":"bug","created_at":"2025-12-09T21:45:22.356385-06:00","updated_at":"2025-12-09T21:45:22.356385-06:00","source_repo":".","labels":["localization"]}
{"id":"voice-code-priority-queue-hcm","content_hash":"c2afd983397ab74683a983676325083b234e10f0b997d2ba4ffd4439f72ba8d5","title":"Consider showing priority badge in CDBackendSessionRowContent","description":"Sessions in priority queue don't show their priority level in row. Consider adding colored badge (High=red, Med=yellow, Low=blue) or priority number to CDBackendSessionRowContent. Would make priority visible without opening SessionInfoView. Optional feature for better scanability.","status":"open","priority":3,"issue_type":"task","created_at":"2025-12-09T21:11:55.286564-06:00","updated_at":"2025-12-09T21:11:55.286564-06:00","source_repo":".","labels":["ux"]}
{"id":"voice-code-priority-queue-hd3r","content_hash":"d8247de9d580d2548581308e109b8aea0b69901142013ae3118f868887982303","title":"Priority levels hardcoded in multiple places preventing easy addition of new levels","description":"**File:** DirectoryListView.swift:478-490, SessionInfoView.swift:81-83\n\n**Issue:** Priority levels are hardcoded as {1, 5, 10} in multiple places. Adding new priority levels (e.g., Critical = 0, Very Low = 20) requires code changes in 10+ locations.\n\n**Impact:**\n- Cannot add new priority levels without code changes\n- Hardcoded values scattered across codebase\n- UI Picker must be manually updated\n- Sort logic assumes current values\n\n**Hardcoded Locations:**\n\n1. **SessionInfoView.swift:81-83** - Picker options:\n```swift\nText(\"High (1)\").tag(Int32(1))\nText(\"Medium (5)\").tag(Int32(5))\nText(\"Low (10)\").tag(Int32(10))\n```\n\n2. **CoreData schema** - Default value:\n```xml\n\u003cattribute name=\"priority\" ... defaultValueString=\"10\" /\u003e\n```\n\n3. **removeFromPriorityQueue** - Reset value:\n```swift\nsession.priority = 10  // Hardcoded default\n```\n\n4. **Validation logic** (proposed but not implemented):\n```swift\nguard [1, 5, 10].contains(priority) else { ... }\n```\n\n**Proposed Refactor:**\n```swift\n// NEW FILE: PriorityLevel.swift\nenum PriorityLevel: Int32, CaseIterable {\n    case high = 1\n    case medium = 5\n    case low = 10\n    \n    var displayName: String {\n        switch self {\n        case .high: return \"High\"\n        case .medium: return \"Medium\"\n        case .low: return \"Low\"\n        }\n    }\n    \n    var sortOrder: Int32 {\n        rawValue  // Lower number = higher priority\n    }\n    \n    static let : PriorityLevel = .medium\n    \n    static var allCases: [PriorityLevel] {\n        [.high, .medium, .low]\n    }\n}\n\n// SessionInfoView.swift - Dynamic picker:\nPicker(\"Priority\", selection: Binding(\n    get: { PriorityLevel(rawValue: session.priority) ?? .default },\n    set: { changePriority(session, newPriority: /bin/zsh.rawValue) }\n)) {\n    ForEach(PriorityLevel.allCases, id: \\.self) { level in\n        Text(\"\\(level.displayName) (\\(level.rawValue))\").tag(level)\n    }\n}\n\n// removeFromPriorityQueue:\nsession.priority = PriorityLevel.default.rawValue\n\n// Validation:\nguard PriorityLevel(rawValue: priority) != nil else {\n    logger.error(\"Invalid priority: \\(priority)\")\n    return\n}\n```\n\n**Benefits of Enum:**\n- ‚úÖ Single source of truth\n- ‚úÖ Type-safe priority values\n- ‚úÖ Easy to add new levels\n- ‚úÖ Compile-time validation\n- ‚úÖ Centralized display names\n- ‚úÖ Testable in isolation\n\n**Future Use Cases:**\nAdding \"Critical\" priority (0):\n```swift\nenum PriorityLevel: Int32 {\n    case critical = 0  // ‚úÖ Just add one line\n    case high = 1\n    case medium = 5\n    case low = 10\n}\n// UI automatically updates, no other code changes needed\n```\n\n**Related:** voice-code-priority-queue-vs1 [P2] tracks creating Priority enum for type safety.","status":"open","priority":4,"issue_type":"bug","created_at":"2025-12-09T22:17:36.94693-06:00","updated_at":"2025-12-09T22:17:36.94693-06:00","source_repo":".","labels":["future-proofing"]}
{"id":"voice-code-priority-queue-hpz","content_hash":"4325852a650233a9c2f1a71f8c63a8a45346030e28da63d685d50df7d3b2881d","title":"Phase 3: Priority Change Logic - Implement changePriority function","description":"Implement changePriority function with automatic queue reordering.\n\nFILES TO MODIFY:\n- ios/VoiceCode/Views/ConversationView.swift\n\nFUNCTION TO IMPLEMENT (UPDATED - Uses Helper):\n\nfunc changePriority(_ session: CDBackendSession, newPriority: Int32) {\n    session.priority = newPriority\n    \n    // Move to end of new priority group\n    // Use helper function from task voice-code-priority-queue-63a\n    let maxOrder = fetchMaxPriorityOrder(priority: newPriority)\n    session.priorityOrder = maxOrder + 1.0\n    \n    // Use consistent error handling\n    saveContext()\n}\n\nHELPER FUNCTIONS REQUIRED:\nThis function depends on helper functions implemented in task voice-code-priority-queue-63a:\n1. fetchMaxPriorityOrder(priority:) - Find max priorityOrder for given priority\n2. saveContext() - Consistent CoreData error handling\n\nOriginal Implementation (DEPRECATED - Use helpers instead):\nfunc changePriority(_ session: CDBackendSession, newPriority: Int32) {\n    session.priority = newPriority\n    \n    // Calculate new priorityOrder: move to end of new priority group\n    let request: NSFetchRequest\u003cCDBackendSession\u003e = CDBackendSession.fetchRequest()\n    request.predicate = NSPredicate(format: \"isInPriorityQueue == YES AND priority == %d\", newPriority)\n    request.sortDescriptors = [NSSortDescriptor(key: \"priorityOrder\", ascending: false)]\n    request.fetchLimit = 1\n    \n    let maxOrder = (try? viewContext.fetch(request).first?.priorityOrder) ?? 0.0\n    session.priorityOrder = maxOrder + 1.0\n    \n    try? viewContext.save()  // DON'T DO THIS - use saveContext() helper\n}\n\nIMPLEMENTATION RATIONALE:\n- Use fetchMaxPriorityOrder() helper for consistent fetch logic\n- Use saveContext() for consistent error handling (no silent failures with try?)\n- Simplified implementation: 5 lines vs 11 lines\n- Better maintainability: logic centralized in helpers\n\nVERIFICATION - Test Pyramid:\n\nUnit Tests:\n1. testChangePriority - Priority updates correctly\n2. testChangePriorityMovesToEnd - New priorityOrder calculated correctly\n3. testChangePriorityToSamePriority - Handles edge case (no-op or recalculate)\n4. testChangePriorityWithNegatives - Negative priorities work\n5. testChangePriorityUsesHelper (NEW)\n   - Mock/spy on fetchMaxPriorityOrder call\n   - Verify helper is called with correct priority value\n   - Verify saveContext is called\n\nIntegration Test:\n6. testAutoRefreshAfterPriorityChange\n   - Change priority\n   - Verify DirectoryListView priorityQueueSessions updates\n   - No manual refresh needed (CoreData observation)\n\nManual Test:\n1. Create 3 sessions: P5, P10, P15\n2. Change P15 to P5\n3. Verify queue reorders immediately\n4. Session appears after original P5 session\n5. Check console for saveContext logging (if errors)\n\nEDGE CASES:\n- Change to same priority: Moves to end of same group (order recalculated)\n- Change to empty priority group: maxOrder returns 0.0, new order = 1.0\n- Multiple rapid changes: Last change wins (no locking)\n\nIMPLEMENTATION STEPS:\n1. Open ConversationView.swift\n2. Locate after addToPriorityQueue/removeFromPriorityQueue functions\n3. Verify fetchMaxPriorityOrder helper exists (from task 63a)\n4. Verify saveContext helper exists (from task 63a)\n5. Implement changePriority using helpers\n6. Build project (Cmd+B)\n7. Run unit tests\n8. Verify no try? viewContext.save() calls (use saveContext instead)\n\nACCEPTANCE CRITERIA:\n‚úÖ Function implemented correctly using helpers\n‚úÖ Calls fetchMaxPriorityOrder(priority: newPriority)\n‚úÖ Calls saveContext() for error handling\n‚úÖ Moves to end of new priority group\n‚úÖ No inline CoreData fetch logic (uses helper)\n‚úÖ No try? viewContext.save() (uses saveContext helper)\n‚úÖ All 6 unit tests pass (including helper usage test)\n‚úÖ Auto-refresh works (no manual refresh needed)\n‚úÖ No race conditions or data loss\n‚úÖ Console logs errors if save fails (via saveContext)\n\nDEPENDENCIES:\n- CRITICAL: Depends on helper functions in task voice-code-priority-queue-63a\n- Must implement task 63a BEFORE this task\n- Helpers must be in scope (same file or accessible)","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-07T17:57:00.425372-06:00","updated_at":"2025-12-09T20:27:53.132016-06:00","closed_at":"2025-12-09T20:27:53.132016-06:00","source_repo":".","dependencies":[{"issue_id":"voice-code-priority-queue-hpz","depends_on_id":"voice-code-priority-queue-qhd","type":"blocks","created_at":"2025-12-07T17:59:28.191517-06:00","created_by":"travisbrown"},{"issue_id":"voice-code-priority-queue-hpz","depends_on_id":"voice-code-priority-queue-63a","type":"blocks","created_at":"2025-12-08T22:44:08.196085-06:00","created_by":"travisbrown"}]}
{"id":"voice-code-priority-queue-i7s","content_hash":"edd9d49d7d85d9f90a1cd5c52ad0228af99fc3ec7428a791c9e9d03c48d79b2e","title":"Add bounds checking for priority values in UI","description":"SessionInfoView Picker only offers 1,5,10 but session.priority could be any Int32 value if set programmatically or from corrupted data. Picker binding would fail. Fix: Add validation in changePriority to clamp values to valid range, or add 'Custom' option in picker.","status":"closed","priority":2,"issue_type":"bug","created_at":"2025-12-09T21:04:09.707917-06:00","updated_at":"2025-12-10T09:41:42.253304-06:00","closed_at":"2025-12-10T09:41:42.253304-06:00","source_repo":"."}
{"id":"voice-code-priority-queue-j0f","content_hash":"be63c13e3fa29d01a08ecff1f5b5147c038b144b4466007c25587675e0d1e874","title":"Review Settings description clarity for priority queue feature","description":"SettingsView line 121 says 'Sessions updated on workstation appear automatically' - unclear phrasing. Better: 'Sessions are auto-added when you send prompts. Manage priority from session info.' Also clarify relationship between Queue and Priority Queue features.","status":"open","priority":3,"issue_type":"task","created_at":"2025-12-09T21:05:24.683859-06:00","updated_at":"2025-12-09T21:05:24.683859-06:00","source_repo":".","labels":["documentation"]}
{"id":"voice-code-priority-queue-jd6","content_hash":"b11a8428ecaeff95bc7795a547aa99bb659a085971e984e43328a56bf1c98ea7","title":"ConversationView toolbar shows both queue remove buttons when features overlap","description":"**File:** ConversationView.swift:322-329, 331-354\n\n**Issue:** Queue and Priority Queue toolbar buttons can both be visible simultaneously when both features enabled and session is in BOTH queues.\n\n**Current State:**\nAccessibility labels added (lines 341-342, 351-352) help VoiceOver users, but visual confusion remains.\n\n**Recommended Solution:**\nUse Menu to group queue operations:\n```swift\nif settings.queueEnabled || settings.priorityQueueEnabled {\n    Menu {\n        if settings.queueEnabled {\n            if session.isInQueue {\n                Button(action: { removeFromQueue(session) }) {\n                    Label(\"Remove from Queue\", systemImage: \"xmark.circle.fill\")\n                }\n            } else {\n                Button(action: { addToQueue(session) }) {\n                    Label(\"Add to Queue\", systemImage: \"plus.circle.fill\")\n                }\n            }\n        }\n        \n        if settings.priorityQueueEnabled {\n            if session.isInPriorityQueue {\n                Button(action: { removeFromPriorityQueue(session) }) {\n                    Label(\"Remove from Priority Queue\", systemImage: \"star.slash.fill\")\n                }\n            } else {\n                Button(action: { addToPriorityQueue(session) }) {\n                    Label(\"Add to Priority Queue\", systemImage: \"star.fill\")\n                }\n            }\n        }\n    } label: {\n        Image(systemName: \"line.3.horizontal.circle\")\n            .foregroundColor(.blue)\n    }\n    .accessibilityLabel(\"Queue Actions\")\n}\n```\n\nBenefits:\n- Single button for all queue operations\n- Clear text labels in menu\n- Scales if more queue types added\n- Reduces toolbar clutter\n\nDrawback: One extra tap for common operations\n\nAlternative: Keep separate buttons but use distinct icons (not both X-style icons).","status":"open","priority":3,"issue_type":"bug","created_at":"2025-12-09T21:56:05.233471-06:00","updated_at":"2025-12-09T22:42:14.414784-06:00","source_repo":".","labels":["state-consistency"]}
{"id":"voice-code-priority-queue-jd9","content_hash":"0e1b8145c8d45d5bfad7c14984283bb0c08e6a98d9905f44665dbb29ee31e162","title":"Verify behavior when Picker displays session.priority not in 1,5,10","description":"**Merged with voice-code-priority-queue-i7s.**\n\n**Issue:** SessionInfoView Picker only has tags 1,5,10. If session.priority is 7 (or any other value), SwiftUI Picker behavior is undefined - may show blank segment.\n\n**How it could happen:**\n- Data corruption\n- Future API setting non-standard values\n- Database migration issue\n\n**Defensive fix options:**\n\n1. **Clamp on read:**\n```swift\nvar normalizedPriority: Int32 {\n    switch session.priority {\n    case ...2: return 1\n    case 3...7: return 5\n    default: return 10\n    }\n}\n```\n\n2. **Show custom option:**\n```swift\nif ![1, 5, 10].contains(session.priority) {\n    Text(\"Custom (\\(session.priority))\").tag(session.priority)\n}\n```\n\n3. **Auto-correct on change:**\n```swift\n.onAppear {\n    if ![1, 5, 10].contains(session.priority) {\n        session.priority = 10  // Normalize to valid\n    }\n}\n```\n\n**Recommendation:** Low probability issue. Downgrade to P3 since all creation paths use valid values.","status":"open","priority":3,"issue_type":"bug","created_at":"2025-12-09T21:11:01.571653-06:00","updated_at":"2025-12-10T09:41:56.029765-06:00","source_repo":"."}
{"id":"voice-code-priority-queue-jfz","content_hash":"bb387481a71d41c42fab08d44fdea0b253292e0084b9b17705e930fb080dd484","title":"fetchMaxPriorityOrder doesn't validate priority parameter before using in predicate","description":"**File:** DirectoryListView.swift:546-551, ConversationView.swift:962-967, SessionInfoView.swift:262-267\n\n**Issue:** fetchMaxPriorityOrder() executes NSFetchRequest with NSPredicate using %d format specifier for Int32, but doesn't validate that priority parameter is within valid Int32 range before formatting.\n\n**Impact:** \n- If priority is corrupted (e.g., Int32.max + 1 due to overflow), predicate formatting could fail\n- If priority is negative (edge case), predicate still works but violates assumptions\n- No validation that priority is in expected set {1, 5, 10}\n\n**Evidence:**\n```swift\n// All three implementations:\nprivate func fetchMaxPriorityOrder(priority: Int32) -\u003e Double {\n    let request: NSFetchRequest\u003cCDBackendSession\u003e = CDBackendSession.fetchRequest()\n    request.predicate = NSPredicate(format: \"isInPriorityQueue == YES AND priority == %d\", priority)\n    // ‚ùå No validation that priority is valid\n    let sessions = (try? viewContext.fetch(request)) ?? []\n    return sessions.map { $0.priorityOrder }.max() ?? 0.0\n}\n```\n\n**Edge Cases:**\n\n1. **priority = 0:**\n   - Valid Int32, predicate works\n   - But violates assumption that priority ‚â• 1\n\n2. **priority = -1:**\n   - Valid Int32, predicate works\n   - But violates assumption that priority \u003e 0\n\n3. **priority = 999:**\n   - Valid Int32, predicate works\n   - But not in UI's {1, 5, 10} set\n\n4. **priority = Int32.max (2,147,483,647):**\n   - Valid, predicate works\n   - Could indicate corruption\n\n**Proposed Fix:**\n```swift\nprivate func fetchMaxPriorityOrder(priority: Int32) -\u003e Double {\n    // Validate priority parameter\n    guard priority \u003e 0 \u0026\u0026 priority \u003c= 100 else {\n        logger.error(\"Invalid priority value: \\(priority), using default\")\n        return 0.0\n    }\n    \n    let request: NSFetchRequest\u003cCDBackendSession\u003e = CDBackendSession.fetchRequest()\n    request.predicate = NSPredicate(format: \"isInPriorityQueue == YES AND priority == %d\", priority)\n    \n    do {\n        let sessions = try viewContext.fetch(request)\n        return sessions.map { $0.priorityOrder }.max() ?? 0.0\n    } catch {\n        logger.error(\"Fetch failed: \\(error.localizedDescription)\")\n        return 0.0\n    }\n}\n```\n\nOr use NSPredicate with type-safe argument:\n```swift\nlet predicate = NSPredicate(format: \"isInPriorityQueue == YES AND priority == %@\", NSNumber(value: priority))\n```\n\n**Related:**\n- voice-code-priority-queue-i7s [P2]: Bounds checking for priority values\n- voice-code-priority-queue-887 [P3]: CoreData priority attribute has no validation\n- voice-code-priority-queue-obe [P3]: changePriority doesn't validate newPriority","status":"closed","priority":3,"issue_type":"bug","created_at":"2025-12-09T22:13:02.119718-06:00","updated_at":"2025-12-10T09:57:24.598642-06:00","closed_at":"2025-12-10T09:57:24.598642-06:00","source_repo":".","labels":["error-handling"]}
{"id":"voice-code-priority-queue-jzmx","content_hash":"906aa95962b92f002b4bf4cb12ba6ac5564d2a979d137bf9ea51f745f4e19a4c","title":"Auto-add continued/resumed sessions to priority queue","description":"When a user sends a prompt to an existing session (ConversationView.sendPrompt), the session is not auto-added to priority queue. Code exists but is commented out (lines 590-595) due to ghost session problem - adding before send creates orphan queue entries if send fails. Solution: Move auto-add to turn_complete or response handler callback. File: ConversationView.swift:590-595","status":"closed","priority":2,"issue_type":"bug","created_at":"2025-12-10T19:19:08.24713-06:00","updated_at":"2025-12-10T19:29:09.124929-06:00","closed_at":"2025-12-10T19:29:09.124929-06:00","source_repo":"."}
{"id":"voice-code-priority-queue-k3e","content_hash":"567a84b47642a76f6efe8a2422d92912610a67f9659d0c304ce79d400a92fa5a","title":"Priority Queue section visibility predicates differ between DirectoryListView and SessionInfoView","description":"**File:** DirectoryListView.swift:199, SessionInfoView.swift:72\n\n**Issue:** Priority Queue section visibility controlled by TWO different predicates in different views, creating inconsistent behavior:\n- DirectoryListView: shows if `settings.priorityQueueEnabled \u0026\u0026 !priorityQueueSessions.isEmpty`\n- SessionInfoView: shows if `settings.priorityQueueEnabled \u0026\u0026 session.isInPriorityQueue`\n\n**Impact:** Inconsistent UX across views:\n- DirectoryListView hides section when all sessions are locked (empty list)\n- SessionInfoView hides section when session NOT in queue\n- User sees different UI depending on which view they're in\n\n**Evidence:**\n```swift\n// DirectoryListView.swift:198\nif settings.priorityQueueEnabled \u0026\u0026 !priorityQueueSessions.isEmpty {\n    Section { /* Priority Queue */ }\n}\n\n// SessionInfoView.swift:72\nif settings.priorityQueueEnabled \u0026\u0026 session.isInPriorityQueue {\n    Section { /* Priority Queue */ }\n}\n```\n\n**Inconsistency Examples:**\n\n1. **Locked Sessions:**\n   - DirectoryListView: All sessions locked ‚Üí section disappears\n   - SessionInfoView: Session locked but in queue ‚Üí section still shows\n\n2. **Empty Queue:**\n   - DirectoryListView: No sessions in queue ‚Üí section disappears\n   - SessionInfoView: Current session not in queue ‚Üí section disappears\n\n3. **Feature Disabled:**\n   - DirectoryListView: Section hidden ‚úì\n   - SessionInfoView: Section hidden ‚úì\n   - (This is consistent)\n\n**Proposed Fix - Option 1:** Always show section if feature enabled:\n```swift\n// DirectoryListView.swift:198\nif settings.priorityQueueEnabled {\n    Section {\n        if priorityQueueSessions.isEmpty {\n            Text(\"No sessions in priority queue\")\n                .foregroundColor(.secondary)\n        } else {\n            ForEach(priorityQueueSessions) { /* rows */ }\n        }\n    } header: { Text(\"Priority Queue\") }\n}\n```\n\n**Proposed Fix - Option 2:** Show section with add button when session not in queue:\n```swift\n// SessionInfoView.swift:72\nif settings.priorityQueueEnabled {\n    Section {\n        if session.isInPriorityQueue {\n            // Existing picker UI\n        } else {\n            Button(\"Add to Priority Queue\") {\n                addToPriorityQueue(session)\n            }\n        }\n    } header: { Text(\"Priority Queue\") }\n}\n```\n\n**Related:**\n- voice-code-priority-queue-zss [P2]: Empty state messaging\n- voice-code-priority-queue-zp4 [P3]: SessionInfoView hidden section\n- voice-code-priority-queue-5ds [P2]: Section hidden reducing discoverability","status":"closed","priority":3,"issue_type":"bug","created_at":"2025-12-09T22:13:00.064583-06:00","updated_at":"2025-12-10T09:52:49.234007-06:00","closed_at":"2025-12-10T09:52:49.234007-06:00","source_repo":".","labels":["state-management"]}
{"id":"voice-code-priority-queue-kjc","content_hash":"70babfa56016c04386213ca3f0775f182d80463afd70fa2cb5bc1183195285b3","title":"DirectoryListView onChange sessions.count triggers redundant cache updates","description":"**Analysis:** Already mitigated by per-function debouncing.\n\n**Current behavior:**\n- onChange(of: sessions.count) calls 3 update functions\n- Each function has 150ms debounce (lines 444, 481)\n- Rapid session changes batch into single cache rebuild per type\n\n**Why it's acceptable:**\n- Debouncing prevents CPU spike on rapid updates\n- Cache rebuilds are fast (filter/sort on small arrays)\n- Main thread already async via DispatchWorkItem\n\n**Remaining concern:**\n- Three separate debounce timers instead of one combined\n- Could coalesce into single 'updateAllCaches' with one debounce\n- But current approach allows selective updates (queue only, directory only)\n\n**Recommendation:** Downgrade to P4. Premature optimization without profiling data.","status":"open","priority":4,"issue_type":"bug","created_at":"2025-12-09T21:48:27.177858-06:00","updated_at":"2025-12-10T09:40:43.690722-06:00","source_repo":".","labels":["performance"]}
{"id":"voice-code-priority-queue-klp","content_hash":"de2d4127f7f771e99c55a9559da2522fefdc61d44a68c88a782e02e1d6b78756","title":"ConversationView priority queue buttons hardcode purple color without accessibility consideration","description":"**File:** ConversationView.swift:338-349\n\n**Issue:** Priority queue toolbar buttons (star.fill / star.slash.fill) hardcode purple color (.foregroundColor(.purple)) but iOS supports multiple color schemes (light/dark mode) and accessibility features (Increase Contrast).\n\n**Impact:**\n- Purple may not be accessible in all contexts (contrast ratio)\n- Hardcoded color doesn't adapt to user's accessibility settings\n- No semantic meaning - purple is arbitrary choice\n\n**Evidence:**\n```swift\n// ConversationView.swift:338-339, 347\nImage(systemName: \"star.slash.fill\")\n    .foregroundColor(.purple)\n\nImage(systemName: \"star.fill\")\n    .foregroundColor(.purple)\n```\n\n**Why Purple?**\n- No documented reason in code comments\n- May conflict with future color schemes\n- voice-code-priority-queue-x8j [P4] tracks this as future concern\n\n**Proposed Fix:** Use semantic color or tint:\n```swift\n.foregroundColor(.accentColor)  // Adapts to user theme\n// OR\n.foregroundColor(.orange)  // Different from queue's .orange to distinguish features\n// OR\n.symbolRenderingMode(.palette)  // Use SF Symbol's built-in colors\n```\n\n**Accessibility Consideration:**\nTest with:\n- Dark Mode\n- Increase Contrast\n- Reduce Transparency\n- Color filters (Protanopia, Deuteranopia, Tritanopia)\n\n**Related:** voice-code-priority-queue-x8j tracks purple color choice.","status":"open","priority":3,"issue_type":"bug","created_at":"2025-12-09T21:56:02.168415-06:00","updated_at":"2025-12-09T21:56:02.168415-06:00","source_repo":".","labels":["ui-consistency"]}
{"id":"voice-code-priority-queue-l52","content_hash":"d457e05d4ecc62dc5beff9c16146fdaf3dcf8dae06f4e26b02bc52615cfe9bf1","title":"Add defensive checks for nil session.priorityQueuedAt display","description":"SessionInfoView line 97-105 displays priorityQueuedAt only if non-nil. But if session.isInPriorityQueue=true but priorityQueuedAt=nil (corrupted state), user won't see timestamp. Consider showing placeholder or logging warning. Not critical since timestamp is cosmetic.","status":"open","priority":3,"issue_type":"task","created_at":"2025-12-09T21:04:52.682533-06:00","updated_at":"2025-12-09T21:04:52.682533-06:00","source_repo":"."}
{"id":"voice-code-priority-queue-m0f","content_hash":"669ce261aec92cfc8f98a6ff9b26c1006d824221b07d7147d4c05f77144e6546","title":"Optimize sorting to avoid repeated string conversions","description":"DirectoryListView line 489 converts session.id.uuidString on every comparison during sort. For 100 sessions, potentially calls 100*log(100)‚âà664 times. Fix: Pre-compute uuidStrings in sorted closure or use Schwartzian transform with tuples.","status":"open","priority":3,"issue_type":"task","created_at":"2025-12-09T21:04:46.190599-06:00","updated_at":"2025-12-09T21:04:46.190599-06:00","source_repo":".","labels":["performance"]}
{"id":"voice-code-priority-queue-m74q","content_hash":"77b75337d90801ab75536b54eaa3108b8440c71875df75c191000dffd01a0b04","title":"Auto-add fix: Add unit tests for backendName lookup pattern","description":"Add tests 105 and 106 to PriorityQueueManagementTests.swift as specified in PRIORITY_QUEUE_AUTO_ADD_FIX.md.\n\nTest 105: testAutoAddSessionByBackendName\n- Create session with specific backendName\n- Verify session starts with priorityQueuePosition = 0\n- Fetch session by backendName predicate\n- Call addToPriorityQueue\n- Verify priorityQueuePosition \u003e 0\n\nTest 106: testAutoAddByBackendNameSessionNotFound\n- Query for non-existent backendName\n- Verify empty result (graceful handling, no crash)\n\nReference: PRIORITY_QUEUE_AUTO_ADD_FIX.md section 'Unit Tests'","acceptance_criteria":"1. Test 105 (testAutoAddSessionByBackendName) passes\n2. Test 106 (testAutoAddByBackendNameSessionNotFound) passes\n3. Total test count increases from 104 to 106\n4. All 106 tests pass","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-10T20:07:12.800406-06:00","updated_at":"2025-12-10T20:30:03.107909-06:00","closed_at":"2025-12-10T20:30:03.107909-06:00","source_repo":".","dependencies":[{"issue_id":"voice-code-priority-queue-m74q","depends_on_id":"voice-code-priority-queue-gg8y","type":"blocks","created_at":"2025-12-10T20:10:47.429777-06:00","created_by":"travisbrown"}]}
{"id":"voice-code-priority-queue-mbz","content_hash":"a33d045043a09f91db7e2a9d98064546cd6e37ca1c32fa67e00bd3a1f60752b6","title":"DispatchWorkItem capture list captures sessions array by value duplicating memory","description":"Line 468: '[viewModel, sessions] in' captures entire sessions array by value. For 1000 sessions, this duplicates ~200KB+ per debounce. Better: capture only needed IDs, then re-filter in closure. Or use weak/unowned capture if semantics allow. Trade-off: current approach prevents race conditions. Measure actual memory impact before optimizing.","status":"open","priority":3,"issue_type":"task","created_at":"2025-12-09T21:28:27.623621-06:00","updated_at":"2025-12-09T21:28:27.623621-06:00","source_repo":".","labels":["performance"]}
{"id":"voice-code-priority-queue-mc6p","content_hash":"1a9f08556c2a3816f4442051933d1c4da7f94f1138f75c6a071122b6f242543e","title":"Auto-add fix: Drop stashed changes from previous approach","description":"After implementation and testing is complete, drop the stashed changes from the previous turn_complete broadcast approach:\n\nCommands to run:\n  git stash drop stash@{0}  # 'WIP: iOS logging for turn_complete debugging'\n  git stash drop stash@{1}  # 'WIP: broadcast turn_complete to all clients'\n\nNote: Stash indices may shift if other stashes are added/dropped. Verify stash contents before dropping:\n  git stash show -p stash@{0}\n  git stash show -p stash@{1}\n\nReference: PRIORITY_QUEUE_AUTO_ADD_FIX.md section 'Stashed Changes Cleanup'","acceptance_criteria":"1. stash@{0} dropped (verify it's the iOS logging stash first)\n2. stash@{1} dropped (verify it's the backend broadcast stash first)\n3. No stashed changes related to turn_complete auto-add remain","status":"open","priority":2,"issue_type":"task","created_at":"2025-12-10T20:07:25.554771-06:00","updated_at":"2025-12-10T20:18:04.08889-06:00","source_repo":".","dependencies":[{"issue_id":"voice-code-priority-queue-mc6p","depends_on_id":"voice-code-priority-queue-yocj","type":"blocks","created_at":"2025-12-10T20:07:57.483921-06:00","created_by":"travisbrown"}]}
{"id":"voice-code-priority-queue-mmx","content_hash":"617281d222e56f36157c16d04aa8661f46e3ebdf4322497162ef4bb0125855cb","title":"No visual distinction between Queue and Priority Queue sections","description":"Both Queue and Priority Queue sections use identical row styling (CDBackendSessionRowContent). User can't tell which queue session is in without context. Consider: 1) Add subtle badge/icon, 2) Different row background, 3) Priority number indicator. Would improve scanability when both features enabled.","status":"open","priority":3,"issue_type":"task","created_at":"2025-12-09T21:23:30.370068-06:00","updated_at":"2025-12-09T21:23:30.370068-06:00","source_repo":".","labels":["ux"]}
{"id":"voice-code-priority-queue-mpq","content_hash":"8f56de1432a30a97523e0c46e7a0584efe0149668c8d325db09016c109d7eead","title":"No integration tests verify priority queue behavior across view boundaries","description":"**Analysis:** Valid but requires UI testing infrastructure.\n\n**Current test coverage:**\n- 32 unit tests in PriorityQueueManagementTests.swift\n- Cover CoreData operations, sorting, filtering, edge cases\n- Use isolated in-memory CoreData contexts\n\n**What unit tests verify:**\n‚úÖ CoreData schema and defaults\n‚úÖ Add/remove/changePriority operations\n‚úÖ Sorting logic (priority ‚Üí order ‚Üí ID)\n‚úÖ Filtering (locked sessions, non-queue sessions)\n‚úÖ Edge cases (empty queue, negative priorities, idempotent operations)\n‚úÖ Error handling (save failures)\n\n**What unit tests cannot verify:**\n‚ùå SwiftUI view lifecycle\n‚ùå NotificationCenter propagation to live views\n‚ùå Navigation state preservation\n‚ùå Real app restart persistence\n\n**Integration test complexity:**\n- Requires XCUITest setup\n- Slower execution (real UI)\n- Flaky potential (timing, animations)\n- Need test data setup via accessibility identifiers\n\n**Partial mitigation:**\nNotificationCenter tests could verify notification posting:\n```swift\nfunc testChangePriorityPostsNotification() {\n    let expectation = XCTestExpectation(description: \"Notification posted\")\n    let observer = NotificationCenter.default.addObserver(\n        forName: .priorityQueueChanged,\n        object: nil,\n        queue: .main\n    ) { _ in expectation.fulfill() }\n    \n    CDBackendSession.changePriority(session, newPriority: 5, context: context)\n    \n    wait(for: [expectation], timeout: 1.0)\n    NotificationCenter.default.removeObserver(observer)\n}\n```\n\n**Recommendation:** Downgrade to P3. Add NotificationCenter unit tests first, defer full UI integration tests until framework setup needed for other features.","status":"open","priority":3,"issue_type":"task","created_at":"2025-12-09T22:07:56.707998-06:00","updated_at":"2025-12-10T09:49:50.299509-06:00","source_repo":".","labels":["testing"]}
{"id":"voice-code-priority-queue-n94","content_hash":"5eb3c5d31dedf106a3474d6e8f70ad393fb2c8ea472ce6701c933bc5cdfbf3fe","title":"Priority queue business logic embedded in View files violates separation of concerns","description":"**File:** Multiple files (DirectoryListView, ConversationView, SessionInfoView)\n\n**Issue:** Priority queue management functions are implemented as private functions in View files. This violates separation of concerns - Views should not contain business logic.\n\n**Impact:**\n- Views become bloated (DirectoryListView is 846 lines)\n- Business logic coupled to UI layer\n- Cannot reuse logic outside SwiftUI context\n- Difficult to unit test (must instantiate entire View)\n- Cannot call from other contexts (e.g., background sync, Siri shortcuts)\n\n**Evidence:**\n```swift\n// DirectoryListView.swift:554-606\nstruct DirectoryListView: View {\n    // ... 500+ lines of UI ...\n    \n    // ‚ùå Business logic in View\n    private func addToPriorityQueue(_ session: CDBackendSession) { }\n    private func removeFromPriorityQueue(_ session: CDBackendSession) { }\n    private func changePriority(_ session: CDBackendSession, newPriority: Int32) { }\n    private func fetchMaxPriorityOrder(priority: Int32) -\u003e Double { }\n}\n```\n\n**Correct Architecture:**\n```\n‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n‚îÇ View Layer (SwiftUI)                    ‚îÇ\n‚îÇ  - DirectoryListView.swift              ‚îÇ\n‚îÇ  - ConversationView.swift               ‚îÇ\n‚îÇ  - SessionInfoView.swift                ‚îÇ\n‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n               ‚îÇ calls\n               ‚ñº\n‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n‚îÇ Service Layer                           ‚îÇ\n‚îÇ  - PriorityQueueManager.swift (NEW)     ‚îÇ\n‚îÇ  - OR CDBackendSession+PriorityQueue    ‚îÇ\n‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n               ‚îÇ modifies\n               ‚ñº\n‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n‚îÇ Data Layer (CoreData)                   ‚îÇ\n‚îÇ  - CDBackendSession.swift               ‚îÇ\n‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n```\n\n**Proposed Refactor:**\n```swift\n// NEW FILE: PriorityQueueService.swift\nclass PriorityQueueService {\n    let context: NSManagedObjectContext\n    \n    func addToPriorityQueue(_ session: CDBackendSession) throws {\n        guard !session.isInPriorityQueue else { return }\n        session.isInPriorityQueue = true\n        let maxOrder = try fetchMaxPriorityOrder(priority: session.priority)\n        session.priorityOrder = maxOrder + 1.0\n        session.priorityQueuedAt = Date()\n        try context.save()\n    }\n    \n    // ... other methods ...\n}\n\n// DirectoryListView.swift\nstruct DirectoryListView: View {\n    @StateObject private var priorityQueueService: PriorityQueueService\n    \n    private func addToPriorityQueue(_ session: CDBackendSession) {\n        try? priorityQueueService.addToPriorityQueue(session)\n        updateCachedPriorityQueueSessions()\n    }\n}\n```\n\n**Benefits:**\n- ‚úÖ Testable in isolation\n- ‚úÖ Reusable across app\n- ‚úÖ Clear separation of concerns\n- ‚úÖ Easier to maintain\n- ‚úÖ Can add logging/analytics in one place\n\n**Related:** voice-code-priority-queue-wl1 [P0] tracks code duplication refactoring.","status":"closed","priority":3,"issue_type":"bug","created_at":"2025-12-09T22:07:51.157221-06:00","updated_at":"2025-12-10T09:57:42.981886-06:00","closed_at":"2025-12-10T09:57:42.981886-06:00","source_repo":".","labels":["code-organization"]}
{"id":"voice-code-priority-queue-nxy","content_hash":"f0d4136b9d388daa67403dd834da62efbe52b99659a6af0f7e457dea3293ce27","title":"ConversationView addToPriorityQueue has no rollback on CoreData save failure","description":"**File:** ConversationView.swift:896-913\n\n**Issue:** addToPriorityQueue() creates optimistic state (sets properties, saves to CoreData) but if save fails, there's no rollback and no UI feedback to user.\n\n**Impact:**\n- CoreData save fails (disk full, constraint violation)\n- session.isInPriorityQueue = true in memory\n- session.priority, priorityOrder, priorityQueuedAt all set\n- User sees no error\n- Next CoreData fetch reverts to old values (confusing)\n\n**Evidence:**\n```swift\n// ConversationView.swift:900-912\nsession.isInPriorityQueue = true\nlet maxOrder = fetchMaxPriorityOrder(priority: session.priority)\nsession.priorityOrder = maxOrder + 1.0\nsession.priorityQueuedAt = Date()\n\ndo {\n    try viewContext.save()\n    print(\"‚úÖ [PriorityQueue] Added session to priority queue...\")\n} catch {\n    print(\"‚ùå [PriorityQueue] Failed to add session to priority queue: \\(error)\")\n    // ‚ùå No rollback - session object left in inconsistent state\n    // ‚ùå No user feedback - error only in console\n}\n```\n\n**Proposed Fix:**\n```swift\n// Save old values for rollback\nlet wasInQueue = session.isInPriorityQueue\nlet oldPriority = session.priority\nlet oldOrder = session.priorityOrder\nlet oldQueuedAt = session.priorityQueuedAt\n\nsession.isInPriorityQueue = true\nsession.priorityOrder = maxOrder + 1.0\nsession.priorityQueuedAt = Date()\n\ndo {\n    try viewContext.save()\n    print(\"‚úÖ Added to priority queue\")\n} catch {\n    // Rollback\n    session.isInPriorityQueue = wasInQueue\n    session.priority = oldPriority\n    session.priorityOrder = oldOrder\n    session.priorityQueuedAt = oldQueuedAt\n    \n    // Show user feedback\n    client.currentError = \"Failed to add to priority queue\"\n    print(\"‚ùå Failed to add: \\(error)\")\n}\n```\n\n**Related:** \n- voice-code-priority-queue-cjo [P2] tracks rollback for changePriority\n- voice-code-priority-queue-v4w [P2] tracks rollback for SessionInfoView","status":"closed","priority":3,"issue_type":"bug","created_at":"2025-12-09T21:56:07.18368-06:00","updated_at":"2025-12-10T09:52:31.793415-06:00","closed_at":"2025-12-10T09:52:31.793415-06:00","source_repo":".","labels":["error-recovery"]}
{"id":"voice-code-priority-queue-obe","content_hash":"a15cb69054fa232a1d16ba61381c241a489c411bcae35afc0e12d5a6c2002342","title":"changePriority doesn't validate newPriority parameter bounds","description":"changePriority accepts any Int32 value for newPriority (DirectoryListView:584, ConversationView:934, SessionInfoView:234). No validation that value is positive or within reasonable range. While Picker only offers 1,5,10, function is public API within class. Add validation: guard newPriority \u003e 0 \u0026\u0026 newPriority \u003c= 100 else { logger.error; return }. Prevents data corruption from programming errors.","status":"open","priority":3,"issue_type":"bug","created_at":"2025-12-09T21:28:37.545923-06:00","updated_at":"2025-12-09T21:28:37.545923-06:00","source_repo":"."}
{"id":"voice-code-priority-queue-ogn","content_hash":"61239cd50abd4147644634f4b938cc4d781d73a63f63f1fcc856e26c880ae843","title":"ConversationView fetchMaxPriorityOrder is third duplicate with silent errors","description":"**File:** ConversationView.swift:962-967\n\n**Issue:** fetchMaxPriorityOrder() duplicates exact same logic as DirectoryListView and SessionInfoView but with silent error handling. All three implementations could return different results if CoreData state is inconsistent.\n\n**Impact:**\n- Same query executed in 3 different contexts may return different results\n- No single source of truth\n- Bug fixes require 3x updates\n- Silent errors make debugging impossible\n\n**Evidence:**\n```swift\n// ConversationView.swift:962-967\nprivate func fetchMaxPriorityOrder(priority: Int32) -\u003e Double {\n    let request: NSFetchRequest\u003cCDBackendSession\u003e = CDBackendSession.fetchRequest()\n    request.predicate = NSPredicate(format: \"isInPriorityQueue == YES AND priority == %d\", priority)\n    let sessions = (try? viewContext.fetch(request)) ?? []\n    return sessions.map { $0.priorityOrder }.max() ?? 0.0\n}\n```\n\n**Why Silent Errors Are Dangerous:**\n- If fetch fails due to CoreData corruption, returns 0.0\n- Next session added gets priorityOrder = 0.0 + 1.0 = 1.0\n- May collide with existing session at 1.0\n- Sort order becomes unpredictable\n\n**Proposed Fix:** Centralize and add error logging:\n```swift\n// CDBackendSession+PriorityQueue.swift (new file)\nextension CDBackendSession {\n    static func fetchMaxPriorityOrder(priority: Int32, context: NSManagedObjectContext) -\u003e Double {\n        let request: NSFetchRequest\u003cCDBackendSession\u003e = fetchRequest()\n        request.predicate = NSPredicate(format: \"isInPriorityQueue == YES AND priority == %d\", priority)\n        request.sortDescriptors = [NSSortDescriptor(keyPath: \\CDBackendSession.priorityOrder, ascending: false)]\n        request.fetchLimit = 1\n        \n        do {\n            let sessions = try context.fetch(request)\n            return sessions.first?.priorityOrder ?? 0.0\n        } catch {\n            logger.error(\"Failed to fetch max priority order: \\(error.localizedDescription)\")\n            return 0.0\n        }\n    }\n}\n```\n\n**Benefits:**\n- Single implementation\n- Proper error logging\n- Performance optimization (fetchLimit = 1, sort descriptor)\n- Testable in isolation\n\n**Related:** voice-code-priority-queue-wl1 [P0] tracks broader duplication refactoring.","status":"closed","priority":3,"issue_type":"bug","created_at":"2025-12-09T21:56:15.928347-06:00","updated_at":"2025-12-10T09:52:31.792213-06:00","closed_at":"2025-12-10T09:52:31.792213-06:00","source_repo":".","labels":["code-quality"]}
{"id":"voice-code-priority-queue-ot2","content_hash":"43694ffa4af5d4e59fc10e50650b81e5f72129f8713424a13ac47bf776f472ab","title":"Review accessibility of swipe-to-remove in Priority Queue section","description":"DirectoryListView Priority Queue section uses swipeActions for remove (lines 205-210). Swipe gestures not accessible to VoiceOver users. Should add: 1) Accessibility custom actions, 2) Context menu alternative, 3) Edit mode with delete buttons. Same issue exists in Queue section. Broader accessibility improvement.","status":"open","priority":3,"issue_type":"task","created_at":"2025-12-09T21:18:41.109175-06:00","updated_at":"2025-12-09T21:18:41.109175-06:00","source_repo":".","labels":["accessibility"]}
{"id":"voice-code-priority-queue-ow9","content_hash":"7d0a8d33a771c7b7f5bd232aab41c911af0c9ca82b1659b0df44930d7944e0da","title":"SessionInfoView InfoRow lacks visual affordance for tap-to-copy","description":"**File:** SessionInfoView.swift:23-63\n\n**Task:** InfoRow tap targets are full-width buttons but only text \"Tap to copy any field\" footer provides affordance. Consider adding visual indicator (copy icon, ripple effect) to show tappability.\n\n**Current UX:** \n- User must read footer to know fields are tappable\n- No visual distinction between tappable InfoRows and read-only text\n- Successful copy shows confirmation banner but no immediate tap feedback\n\n**Proposed Enhancements:**\n1. **Add trailing copy icon:**\n```swift\nHStack {\n    VStack(alignment: .leading) { /* existing */ }\n    Spacer()\n    Image(systemName: \"doc.on.doc\")\n        .foregroundColor(.secondary)\n        .font(.caption)\n}\n```\n\n2. **Add press feedback:** Use .buttonStyle(.borderless) or custom style with press animation\n\n3. **Show checkmark briefly after copy:** Replace icon with checkmark for 1 second\n\n**Priority:** P4 - current UX is functional but could be more intuitive.","status":"open","priority":4,"issue_type":"task","created_at":"2025-12-09T21:45:26.967111-06:00","updated_at":"2025-12-09T21:45:26.967111-06:00","source_repo":".","labels":["ux"]}
{"id":"voice-code-priority-queue-oxe","content_hash":"987595dacce226fedd248469a7fae180a98a552bcbe24a815564f034af4b34b8","title":"Priority queue attributes stored in CDBackendSession rather than CDUserSession","description":"**File:** VoiceCode 2.xcdatamodel/contents:15-18\n\n**Task:** Priority queue attributes are stored on CDBackendSession but conceptually belong to user-specific state. Should they be in CDUserSession instead?\n\n**Current Design:**\n```\nCDBackendSession (synced from backend):\n- isInPriorityQueue\n- priority  \n- priorityOrder\n- priorityQueuedAt\n\nCDUserSession (user customizations):\n- customName\n- isUserDeleted\n- createdAt\n```\n\n**Question:** Is priority queue membership a **backend property** or **user preference**?\n\n**Arguments for Current Design (CDBackendSession):**\n- ‚úÖ Simpler implementation - no need to join tables for sorting\n- ‚úÖ Faster queries - all data in one entity\n- ‚úÖ Priority queue is session state, not user metadata\n\n**Arguments for CDUserSession:**\n- ‚úÖ Conceptually similar to customName - user's organizational choice\n- ‚úÖ Separates backend data (message count, last modified) from user preferences\n- ‚úÖ Backend doesn't know or care about iOS priority queue feature\n\n**Current Implementation Issues:**\n- Backend sends session data via WebSocket but doesn't know about priority queue\n- If backend is reset, CDBackendSession is recreated but priority queue state is lost\n- isUserDeleted is in CDUserSession, isInPriorityQueue is in CDBackendSession (inconsistent)\n\n**Recommendation:** Current design is functional. Consider migration only if priority queue needs to persist across backend resets or sync across devices.\n\n**Related:** Session architecture uses two-table pattern (CDBackendSession + CDUserSession) to separate concerns.","status":"open","priority":3,"issue_type":"task","created_at":"2025-12-09T21:47:25.69201-06:00","updated_at":"2025-12-09T21:47:25.69201-06:00","source_repo":".","labels":["data-integrity"]}
{"id":"voice-code-priority-queue-p4a9","content_hash":"e175d4f07622f0906d1cf71b4639a5504c27868b1281279a7f75ea93c6fe0010","title":"removeFromPriorityQueue destroys priorityQueuedAt timestamp losing queue history","description":"**File:** DirectoryListView.swift:570-580, ConversationView.swift:916-930\n\n**Issue:** removeFromPriorityQueue() sets priorityQueuedAt = nil, destroying timestamp of when session was added. If user removes and re-adds session, history is lost.\n\n**Impact:**\n- Session added to queue at 9:00 AM\n- User removes from queue at 3:00 PM\n- priorityQueuedAt = nil (timestamp destroyed)\n- User re-adds to queue at 4:00 PM\n- priorityQueuedAt = 4:00 PM (original time lost)\n- Cannot track \"how long was session in queue?\"\n- Cannot implement \"recently removed\" feature\n- No audit trail of queue operations\n\n**Evidence:**\n```swift\n// DirectoryListView.swift:573-576\nsession.isInPriorityQueue = false\nsession.priority = 10  // Reset to default\nsession.priorityOrder = 0.0\nsession.priorityQueuedAt = nil  // ‚ùå Destroys timestamp\n```\n\n**Alternative Approaches:**\n\n**Option 1: Preserve priorityQueuedAt**\n```swift\nsession.isInPriorityQueue = false\nsession.priority = 10\nsession.priorityOrder = 0.0\n// ‚úÖ Keep priorityQueuedAt to track original add time\n// priorityQueuedAt represents \"first added\" not \"currently queued\"\n```\n\n**Option 2: Add removal timestamp**\n```swift\n// Add new CoreData attribute\n@NSManaged public var priorityQueueRemovedAt: Date?\n\n// In removeFromPriorityQueue:\nsession.isInPriorityQueue = false\nsession.priorityQueueRemovedAt = Date()  // Track removal\n// Keep priorityQueuedAt to track when it was added\n```\n\n**Option 3: Add queue history**\n```swift\n// New entity: CDPriorityQueueEvent\n// Fields: sessionId, action (add/remove/changePriority), timestamp, priority\n// Maintains full audit log of queue operations\n```\n\n**Use Cases Enabled by Preserving Timestamp:**\n\n1. **Analytics:**\n   - \"Average time sessions spend in priority queue\"\n   - \"Most frequently added/removed sessions\"\n   - \"Peak queue usage times\"\n\n2. **UI Features:**\n   - \"Recently removed\" section (undo capability)\n   - \"Was in queue 3 days ago\" indicator\n   - Sort by \"most recently queued\"\n\n3. **Debugging:**\n   - \"When was this session added?\"\n   - \"How long between add and remove?\"\n   - \"History of queue operations\"\n\n**Recommendation:**\nKeep priorityQueuedAt when removing (Option 1) or add removal timestamp (Option 2). Timestamp is valuable user data that shouldn't be destroyed.\n\n**Related:**\n- voice-code-priority-queue-syl [P3]: changePriority doesn't update timestamp\n- Session history tracking in general","status":"open","priority":3,"issue_type":"bug","created_at":"2025-12-09T22:17:35.331735-06:00","updated_at":"2025-12-09T22:17:35.331735-06:00","source_repo":".","labels":["user-data"]}
{"id":"voice-code-priority-queue-pco","content_hash":"752666fe9e6cfe24453899eda05679a23da4212634e4647b5a2599a20eb13ddd","title":"DirectoryListView swipe actions use allowsFullSwipe without confirmation","description":"**File:** DirectoryListView.swift:205-211, ConversationView.swift (no swipe action)\n\n**Issue:** DirectoryListView Priority Queue section uses swipeActions with allowsFullSwipe: true, allowing accidental removals without confirmation.\n\n**Impact:**\n- User swipes to scroll list\n- Accidentally triggers full swipe\n- Session removed from priority queue immediately\n- No undo, no confirmation\n- Frustrating for users\n\n**Evidence:**\n```swift\n// DirectoryListView.swift:205-211\n.swipeActions(edge: .trailing, allowsFullSwipe: true) {\n    Button(role: .destructive) {\n        removeFromPriorityQueue(session)\n    } label: {\n        Label(\"Remove\", systemImage: \"xmark.circle\")\n    }\n}\n```\n\n**Why allowsFullSwipe Is Dangerous:**\n- Full swipe = instant action, no cancel\n- Easy to trigger accidentally\n- No visual confirmation before action\n- Destructive operation (loses priorityOrder, priorityQueuedAt)\n\n**iOS Guidelines:**\n- allowsFullSwipe should be reserved for common, safe actions (mark as read)\n- Destructive actions should require deliberate tap\n- Or show confirmation dialog\n\n**Proposed Fix - Option 1:** Disable full swipe:\n```swift\n.swipeActions(edge: .trailing, allowsFullSwipe: false) {\n    Button(role: .destructive) {\n        removeFromPriorityQueue(session)\n    } label: {\n        Label(\"Remove\", systemImage: \"xmark.circle\")\n    }\n}\n```\n\n**Proposed Fix - Option 2:** Add confirmation:\n```swift\n@State private var sessionToRemove: CDBackendSession?\n\n.swipeActions(edge: .trailing, allowsFullSwipe: true) {\n    Button(role: .destructive) {\n        sessionToRemove = session\n    } label: {\n        Label(\"Remove\", systemImage: \"xmark.circle\")\n    }\n}\n.confirmationDialog(\"Remove from Priority Queue?\", isPresented: Binding(\n    get: { sessionToRemove != nil },\n    set: { if !/bin/zsh { sessionToRemove = nil } }\n)) {\n    Button(\"Remove\", role: .destructive) {\n        if let session = sessionToRemove {\n            removeFromPriorityQueue(session)\n        }\n        sessionToRemove = nil\n    }\n    Button(\"Cancel\", role: .cancel) {\n        sessionToRemove = nil\n    }\n}\n```\n\n**Comparison with Regular Queue:**\nRegular Queue section (line 184-190) ALSO uses allowsFullSwipe: true, so this is consistent but equally problematic.\n\n**Related:** voice-code-priority-queue-q53 [P3] already tracks this issue.","status":"open","priority":3,"issue_type":"bug","created_at":"2025-12-09T22:13:11.844981-06:00","updated_at":"2025-12-09T22:13:11.844981-06:00","source_repo":".","labels":["ux"]}
{"id":"voice-code-priority-queue-pit","content_hash":"facfe474f3c902d976f0f665eb054419078f160873c31c94b2db2afb68ec55fd","title":"AppSettings queue features have no documented relationship (mutually exclusive vs complementary)","description":"**File:** AppSettings.swift:62-66, 56-60\n\n**Task:** queueEnabled and priorityQueueEnabled are separate toggles with no validation that they're mutually exclusive or can coexist. Both can be enabled simultaneously.\n\n**Current Behavior:**\n- User can enable BOTH Queue and Priority Queue features\n- DirectoryListView will show THREE sections: Recent, Queue, Priority Queue\n- Sessions can be in both queues simultaneously (separate isInQueue and isInPriorityQueue flags)\n\n**Questions:**\n1. **Is this intentional?** Should users be able to use both features at once?\n2. **What's the UX?** How do users understand the difference if both are active?\n3. **Performance impact?** Running both caching systems (queue + priority queue) uses more memory\n\n**Observations:**\n- voice-code-priority-queue-zct tracks \"Consider impact of both features enabled simultaneously\"\n- No documentation explaining the relationship between Queue and Priority Queue\n- Settings UI doesn't indicate whether they're mutually exclusive or complementary\n\n**Proposed Actions:**\n1. **Document intended behavior** in STANDARDS.md or feature spec\n2. **Add validation** if mutually exclusive:\n```swift\n@Published var priorityQueueEnabled: Bool {\n    didSet {\n        if priorityQueueEnabled {\n            queueEnabled = false  // Auto-disable regular queue\n        }\n        UserDefaults.standard.set(priorityQueueEnabled, forKey: \"priorityQueueEnabled\")\n    }\n}\n```\n\n3. **Or add UI warning** if complementary:\n```swift\n// In SettingsView:\nif settings.queueEnabled \u0026\u0026 settings.priorityQueueEnabled {\n    Text(\"‚ö†Ô∏è Both queue features are enabled. Sessions may appear in multiple lists.\")\n}\n```","status":"open","priority":4,"issue_type":"task","created_at":"2025-12-09T21:46:35.015161-06:00","updated_at":"2025-12-09T21:46:35.015161-06:00","source_repo":".","labels":["code-quality"]}
{"id":"voice-code-priority-queue-pqc","content_hash":"12dcb730b317ec56d3e48e2c3a2afd91f3ce957755c91368abb9b2122ef97247","title":"Add .onDisappear cleanup for debounced WorkItems","description":"DirectoryListView missing .onDisappear to cancel queueUpdateWorkItem and priorityQueueUpdateWorkItem. Work items could execute after view deallocated, causing state updates on gone view. Fix: Add .onDisappear { queueUpdateWorkItem?.cancel(); priorityQueueUpdateWorkItem?.cancel() }","status":"closed","priority":1,"issue_type":"bug","created_at":"2025-12-09T21:00:02.951462-06:00","updated_at":"2025-12-09T22:33:45.963195-06:00","closed_at":"2025-12-09T22:33:45.963195-06:00","source_repo":"."}
{"id":"voice-code-priority-queue-puu","content_hash":"9396715cd94994adeed8f72a247738cd50e74376a76431dacd3d777be9a5105f","title":"ConversationView priority queue functions don't notify DirectoryListView","description":"ConversationView has its own addToPriorityQueue/removeFromPriorityQueue functions that save to CoreData but DirectoryListView won't observe these changes (voice-code-priority-queue-do2). When user adds/removes via ConversationView toolbar, DirectoryListView shows stale data. Related to CoreData observation issue but separate symptom.","status":"closed","priority":1,"issue_type":"bug","created_at":"2025-12-09T21:17:33.015528-06:00","updated_at":"2025-12-09T22:32:35.672854-06:00","closed_at":"2025-12-09T22:32:35.672854-06:00","source_repo":"."}
{"id":"voice-code-priority-queue-q53","content_hash":"3935536068e73252bff061452630fd07c78600ebe110db72f17533512a464e51","title":"swipeActions uses allowsFullSwipe: true without confirmation","description":"DirectoryListView line 203 sets allowsFullSwipe: true for removeFromPriorityQueue. User can accidentally remove session with single full swipe gesture without confirmation. Consider: 1) Set allowsFullSwipe: false to require tap, 2) Add confirmation alert, 3) Add undo capability. Current behavior matches Queue section for consistency.","status":"open","priority":3,"issue_type":"task","created_at":"2025-12-09T21:23:13.746054-06:00","updated_at":"2025-12-09T21:23:13.746054-06:00","source_repo":".","labels":["ux"]}
{"id":"voice-code-priority-queue-qhd","content_hash":"fbdcea1ff89a067e8099ce078d62bd95123995912d2eb8b63c3af4c7f9768969","title":"Phase 3: Session Info Modal - Add priority editor UI","description":"Add priority editor to session info modal with stepper control and lock handling.\n\nFILES TO MODIFY:\n- ios/VoiceCode/Views/ConversationView.swift\n\nSTATE MANAGEMENT:\nAdd @State variable for managing priority value:\n@State private var editablePriority: Int32 = 10\n\nLOCATION:\nIn session info sheet presentation (around line 250)\n\nIMPLEMENTATION:\n\n1. Initialize State Variable:\n   Add to ConversationView's properties section:\n   @State private var editablePriority: Int32 = 10\n\n2. Add Priority Row in Session Info Sheet (UPDATED - Lock Handling):\n   Location: Inside .sheet(isPresented: $showingSessionInfo)\n   Condition: Only show if priorityQueueEnabled \u0026\u0026 session.isInPriorityQueue\n\nCode (UPDATED):\nif settings.priorityQueueEnabled \u0026\u0026 session.isInPriorityQueue {\n    HStack {\n        Text(\"Priority\")\n            .foregroundColor(.secondary)\n        Spacer()\n        Stepper(\"\\(editablePriority)\", \n                value: $editablePriority, \n                in: -100...100,\n                step: 1)\n            .disabled(viewModel.lockedSessions.contains(session.id.uuidString.lowercased()))\n    }\n    .onChange(of: editablePriority) { newValue in\n        changePriority(session, newPriority: newValue)\n    }\n    \n    // NEW: Show lock indicator if disabled\n    if viewModel.lockedSessions.contains(session.id.uuidString.lowercased()) {\n        Text(\"Priority locked while processing\")\n            .font(.caption2)\n            .foregroundColor(.orange)\n    }\n}\n\n3. Initialize editablePriority When Modal Opens (ENHANCED):\n   Add .onChange to sheet:\n   .onChange(of: showingSessionInfo) { isShowing in\n       if isShowing {\n           editablePriority = session.priority\n       }\n   }\n\nCOMPLETE INTEGRATION:\n\n.sheet(isPresented: $showingSessionInfo) {\n    VStack(alignment: .leading, spacing: 12) {\n        // Existing rows (Working Directory, Session ID, etc.)\n        \n        // NEW: Priority Row with Lock Handling\n        if settings.priorityQueueEnabled \u0026\u0026 session.isInPriorityQueue {\n            HStack {\n                Text(\"Priority\")\n                    .foregroundColor(.secondary)\n                Spacer()\n                Stepper(\"\\(editablePriority)\", \n                        value: $editablePriority, \n                        in: -100...100,\n                        step: 1)\n                    .disabled(viewModel.lockedSessions.contains(session.id.uuidString.lowercased()))\n            }\n            .onChange(of: editablePriority) { newValue in\n                changePriority(session, newPriority: newValue)\n            }\n            \n            // Lock indicator\n            if viewModel.lockedSessions.contains(session.id.uuidString.lowercased()) {\n                Text(\"Priority locked while processing\")\n                    .font(.caption2)\n                    .foregroundColor(.orange)\n            }\n        }\n    }\n    .padding()\n}\n.onChange(of: showingSessionInfo) { isShowing in\n    if isShowing {\n        // Reset editable state when modal opens\n        editablePriority = session.priority\n    }\n}\n\nPRIORITY RANGE SPECIFICATION:\n- Minimum: -100 (super urgent)\n- Maximum: 100 (very low priority)\n- Default: 10 (normal)\n- Step: 1\n- Range Rationale: Practical UX limits without being restrictive\n\nLOCK HANDLING (NEW):\n- Stepper disabled when session is locked (actively processing)\n- Lock indicator message shown when disabled\n- Prevents confusing behavior where priority change appears to fail\n- Visual feedback explains why stepper is disabled\n- When session unlocks, stepper automatically re-enables (SwiftUI reactivity)\n\nUI LAYOUT EXAMPLE:\n‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n‚îÇ Working Directory           ‚îÇ\n‚îÇ /Users/user/project         ‚îÇ\n‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§\n‚îÇ Session ID                  ‚îÇ\n‚îÇ abc123-def456-...           ‚îÇ\n‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§\n‚îÇ Priority            [-  10 +]‚îÇ  ‚Üê Enabled\n‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§\n‚îÇ Priority locked while       ‚îÇ  ‚Üê Only when locked\n‚îÇ processing                  ‚îÇ\n‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n\nEDGE CASES HANDLED:\n1. Session not in queue ‚Üí row hidden (conditional rendering)\n2. Session removed from queue while modal open ‚Üí row disappears (SwiftUI reactivity)\n3. Session locked while modal open ‚Üí stepper disables, lock message appears\n4. Session unlocks while modal open ‚Üí stepper re-enables, lock message disappears\n\nIMPLEMENTATION STEPS:\n1. Open ConversationView.swift\n2. Find @State property section (top of struct)\n3. Add @State private var editablePriority: Int32 = 10\n4. Find .sheet(isPresented: $showingSessionInfo)\n5. Locate session info content (VStack)\n6. Add Priority row with lock handling\n7. Add .onChange(of: showingSessionInfo) after sheet\n8. Initialize editablePriority = session.priority\n9. Build project (Cmd+B)\n10. Test modal opening/closing with locked and unlocked sessions\n\nVERIFICATION - Test Pyramid:\n\nUnit Tests:\n\n1. testPriorityEditorBinding\n   - Create session in priority queue\n   - Open modal (simulate)\n   - Assert editablePriority initialized from session.priority\n   - Change stepper value\n   - Assert editablePriority updates\n   \n2. testPriorityEditorHiddenWhenNotInQueue\n   - Create session NOT in priority queue\n   - Open modal\n   - Assert Priority row not rendered\n   \n3. testPriorityEditorHiddenWhenSettingDisabled\n   - Set priorityQueueEnabled = false\n   - Create session in priority queue\n   - Open modal\n   - Assert Priority row not rendered\n\n4. testPriorityEditorRangeConstraints\n   - Set priority to -100 (min)\n   - Assert stepper doesn't allow lower\n   - Set priority to 100 (max)\n   - Assert stepper doesn't allow higher\n\n5. testPriorityEditorDisabledWhenLocked (NEW)\n   - Create session in priority queue\n   - Lock session (add to lockedSessionIds)\n   - Open modal\n   - Assert stepper is disabled\n   - Assert lock message is visible\n\n6. testPriorityEditorReEnablesWhenUnlocked (NEW)\n   - Create locked session in modal\n   - Unlock session (remove from lockedSessionIds)\n   - Assert stepper re-enables\n   - Assert lock message disappears\n\n7. testLockMessageVisibility (NEW - ADDED)\n   - Open modal for locked session\n   - Assert \"Priority locked while processing\" text visible\n   - Assert text color is orange (.caption2 font)\n   - Unlock session\n   - Assert message disappears\n   - Assert no message when unlocked\n\n8. testLockMessageContent (NEW - ADDED)\n   - Lock session\n   - Open modal\n   - Verify exact message text: \"Priority locked while processing\"\n   - Verify font: .caption2\n   - Verify color: .orange\n\nIntegration Tests:\n\n9. testPriorityChangePersistence\n   - Open modal, change priority\n   - Close modal\n   - Reopen modal\n   - Assert editablePriority reflects saved value\n\n10. testPriorityChangeBlockedWhenLocked (NEW)\n   - Open modal for locked session\n   - Attempt to change priority (stepper disabled)\n   - Verify no changePriority call made\n   - Verify lock message visible\n\nManual Verification:\n1. Build and run app (Cmd+R)\n2. Add session to priority queue\n3. Open session conversation view\n4. Tap session info button (‚ìò)\n5. Verify \"Priority\" row appears\n6. Current value should be 10 (default)\n7. Tap + on stepper ‚Üí value increases to 11\n8. Tap - on stepper ‚Üí value decreases to 10\n9. Tap + repeatedly ‚Üí verify stops at 100 (max)\n10. Tap - repeatedly ‚Üí verify stops at -100 (min)\n11. Send prompt to session (locks it)\n12. Verify stepper becomes disabled (grayed out)\n13. Verify lock message appears in orange\n14. Verify message text: \"Priority locked while processing\"\n15. Wait for response (unlocks)\n16. Verify stepper re-enables\n17. Verify lock message disappears\n18. Close modal\n19. Navigate to Projects view\n20. Verify session moved in queue (if priority changed)\n21. Reopen info modal\n22. Verify value persisted\n\nVisual Verification:\n1. Priority row aligns with other rows\n2. Stepper control visible and functional\n3. Value display updates in real-time\n4. No layout issues with long values (-100 to 100)\n5. Lock message appears below stepper in orange\n6. Works in both light and dark mode\n7. Respects Dynamic Type sizing\n\nACCEPTANCE CRITERIA:\n‚úÖ editablePriority @State variable added\n‚úÖ Priority row added to session info sheet\n‚úÖ Conditional rendering: only when priorityQueueEnabled \u0026\u0026 isInPriorityQueue\n‚úÖ Stepper range: -100 to 100, step 1\n‚úÖ .onChange(of: showingSessionInfo) initializes editablePriority\n‚úÖ .onChange(of: editablePriority) calls changePriority function\n‚úÖ Stepper disabled when session is locked\n‚úÖ Lock indicator message shown when locked\n‚úÖ Stepper re-enables when session unlocks\n‚úÖ Lock message visibility test added (test 7)\n‚úÖ Lock message content test added (test 8)\n‚úÖ Modal shows current priority correctly\n‚úÖ Stepper increments/decrements work\n‚úÖ Range limits enforced (no values \u003c -100 or \u003e 100)\n‚úÖ UI layout correct, no overflow\n‚úÖ All unit tests pass (8 tests including lock message tests)\n‚úÖ Manual verification succeeds\n\nACCESSIBILITY:\n- Stepper has built-in VoiceOver support\n- Value announced as \"Priority 10\"\n- Increment/decrement actions announced\n- Lock message read by VoiceOver\n- Alternative: Could add accessibilityHint(\"Lower numbers are higher priority\")\n\nLOCALIZATION:\n- \"Priority\" label\n- \"Priority locked while processing\" message","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-07T17:56:50.587305-06:00","updated_at":"2025-12-09T20:31:38.939082-06:00","closed_at":"2025-12-09T20:31:38.939082-06:00","source_repo":".","dependencies":[{"issue_id":"voice-code-priority-queue-qhd","depends_on_id":"voice-code-priority-queue-516","type":"blocks","created_at":"2025-12-07T17:59:27.807453-06:00","created_by":"travisbrown"}]}
{"id":"voice-code-priority-queue-qq8","content_hash":"8ed398c7e5db5fccf41202dd4b75f3a50d0f9a585ec2536e6c1c572836b87fd1","title":"fetchMaxPriorityOrder doesn't set fetchLimit causing full table scan","description":"fetchMaxPriorityOrder (DirectoryListView:547-550, ConversationView:963-966, SessionInfoView:263-266) fetches ALL sessions matching priority, then calls .max() in Swift. For 1000+ sessions this is inefficient. Should set request.fetchLimit=1 and request.sortDescriptors=[NSSortDescriptor(key:'priorityOrder',ascending:false)] to fetch only max value from DB. Significant performance win.","status":"closed","priority":2,"issue_type":"bug","created_at":"2025-12-09T21:27:57.33801-06:00","updated_at":"2025-12-09T22:36:03.105634-06:00","closed_at":"2025-12-09T22:36:03.105634-06:00","source_repo":".","labels":["performance"]}
{"id":"voice-code-priority-queue-rd6","content_hash":"b4017b4ba0838ffdfd08791a138d9d087fbd11fafec8e832fcf755e37445b3d5","title":"Phase 1: Unit Tests - Create PriorityQueueManagementTests.swift","description":"Create comprehensive test file for priority queue functionality with proper test infrastructure.\n\nFILE TO CREATE:\n- ios/VoiceCodeTests/PriorityQueueManagementTests.swift\n\nREFERENCE IMPLEMENTATION:\n- Copy structure from ios/VoiceCodeTests/QueueManagementTests.swift\n- Use same in-memory CoreData stack pattern\n- Reuse test helper functions where applicable\n\nTEST INFRASTRUCTURE SETUP:\n\n1. Class structure:\n   class PriorityQueueManagementTests: XCTestCase {\n       var persistentContainer: NSPersistentContainer!\n       var viewContext: NSManagedObjectContext!\n       var mockSettings: AppSettings!\n   }\n\n2. setUp() method:\n   - Initialize in-memory CoreData stack\n   - Create NSPersistentContainer with VoiceCode model\n   - Set store type to NSInMemoryStoreType\n   - Initialize mockSettings with UserDefaults suite\n   \n3. tearDown() method:\n   - Clear all sessions from context\n   - Reset UserDefaults\n   - Set properties to nil\n\n4. Helper functions:\n   - createTestSession(name:priority:priorityOrder:) -\u003e CDBackendSession\n   - addToPriorityQueue(_ session:)\n   - removeFromPriorityQueue(_ session:)\n   - fetchAllPriorityQueueSessions() -\u003e [CDBackendSession]\n\nPHASE 1 TEST COVERAGE:\n\nTest 1: testCoreDataSchemaAttributes\nPurpose: Verify new attributes exist with correct types and defaults\nSteps:\n- Create new CDBackendSession entity\n- Assert session.isInPriorityQueue == false\n- Assert session.priority == 10\n- Assert session.priorityOrder == 0.0\n- Assert session.priorityQueuedAt == nil\n- Save context and reload session\n- Assert values persist correctly\n\nTest 2: testSettingsPersistence\nPurpose: Verify priorityQueueEnabled persists to UserDefaults\nSteps:\n- Create AppSettings instance\n- Assert priorityQueueEnabled == false (default)\n- Set priorityQueueEnabled = true\n- Create new AppSettings instance\n- Assert priorityQueueEnabled == true\n- Set to false\n- Create new instance\n- Assert priorityQueueEnabled == false\n\nTest 3: testDefaultPriorityValue\nPurpose: Verify new sessions get priority=10 by default\nSteps:\n- Create 5 test sessions\n- For each session, assert priority == 10\n- Assert isInPriorityQueue == false\n- Assert priorityOrder == 0.0\n\nTest 4: testLightweightMigration\nPurpose: Verify existing sessions migrate without data loss\nSteps:\n- Create test sessions with existing queue attributes\n- Set isInQueue, queuePosition, queuedAt\n- Save context\n- Reload sessions from persistent store\n- Assert existing attributes preserved\n- Assert new attributes have default values\n- Assert no data corruption\n\nTest 5: testAttributeTypes\nPurpose: Verify attribute types are correct\nSteps:\n- Create session\n- Set priority = Int32.max\n- Set priorityOrder = Double.greatestFiniteMagnitude\n- Set priorityQueuedAt = Date()\n- Save and reload\n- Assert values preserved with correct types\n- Assert no type conversion errors\n\nIMPLEMENTATION STEPS:\n1. Create new file: PriorityQueueManagementTests.swift in ios/VoiceCodeTests\n2. Import XCTest, CoreData, Foundation\n3. Import @testable VoiceCode\n4. Copy CoreData stack setup from QueueManagementTests\n5. Write setUp() and tearDown() methods\n6. Implement helper functions\n7. Write all 5 tests\n8. Run tests individually (Cmd+U on each test)\n9. Run full suite (Cmd+U)\n10. Check code coverage report\n\nVERIFICATION:\nUnit Tests:\n‚úÖ All 5 tests pass independently\n‚úÖ All 5 tests pass together in suite\n‚úÖ Tests run in \u003c 1 second total\n‚úÖ No flaky tests (run 10x, all pass)\n‚úÖ Code coverage \u003e 80% for new code paths\n\nManual Verification:\n1. Open test file in Xcode\n2. Click diamond icons in gutter to run individual tests\n3. Verify all green checkmarks\n4. Open test navigator (Cmd+6)\n5. Verify all tests listed and passing\n6. Check test output in console for any warnings\n\nACCEPTANCE CRITERIA:\n‚úÖ Test file created with proper structure\n‚úÖ In-memory CoreData stack configured\n‚úÖ All 5 Phase 1 tests implemented\n‚úÖ All tests pass consistently\n‚úÖ Helper functions created for reuse\n‚úÖ Test code follows existing patterns\n‚úÖ No hardcoded values (use constants)\n‚úÖ Descriptive test names and comments","status":"closed","priority":0,"issue_type":"task","created_at":"2025-12-07T17:55:37.386782-06:00","updated_at":"2025-12-09T20:00:13.446817-06:00","closed_at":"2025-12-09T20:00:13.446817-06:00","source_repo":".","dependencies":[{"issue_id":"voice-code-priority-queue-rd6","depends_on_id":"voice-code-priority-queue-vpf","type":"blocks","created_at":"2025-12-07T17:59:12.167528-06:00","created_by":"travisbrown"},{"issue_id":"voice-code-priority-queue-rd6","depends_on_id":"voice-code-priority-queue-ssd","type":"blocks","created_at":"2025-12-07T17:59:12.546887-06:00","created_by":"travisbrown"}]}
{"id":"voice-code-priority-queue-rsp","content_hash":"94ebdf25ac4dac0c0145e5d5291aca253eb16fcd74a98f5021bbb9c29ffed943","title":"No maxOrder calculation considers sessions being added concurrently","description":"**Analysis:** Theoretical race condition unlikely in practice.\n\n**Why it's unlikely:**\n1. All priority queue operations happen on main thread (UI-initiated)\n2. CoreData viewContext is main-thread bound\n3. iOS serializes UI events - user can't tap two buttons simultaneously\n4. No background threads modify priority queue\n\n**When it could happen:**\n- Automated testing with concurrent operations\n- Future multi-device sync (not implemented)\n- Backend-initiated priority changes (not implemented)\n\n**Current mitigation:**\n- fetchMaxPriorityOrder with 'excluding' parameter prevents self-race in changePriority\n- Main-thread execution serializes operations\n\n**Impact if duplicates occur:**\n- Two sessions get same priorityOrder\n- Sort uses session ID as tiebreaker (deterministic)\n- FIFO semantics slightly violated but functionally correct\n\n**Recommendation:** Downgrade to P4 (future enhancement). No real-world impact with current single-device iOS architecture.","status":"open","priority":4,"issue_type":"bug","created_at":"2025-12-09T21:29:06.210913-06:00","updated_at":"2025-12-10T09:35:59.188326-06:00","source_repo":"."}
{"id":"voice-code-priority-queue-sfpz","content_hash":"834cd84edf57a838305f12c8172ea635292dda9a2d9103005bcbbb6a45b77070","title":"No code review checklist or guidelines for priority queue changes","description":"**File:** All priority queue source files\n\n**Task:** No code review checklist or guidelines exist for priority queue code changes. Future modifications could introduce bugs due to subtle invariants.\n\n**Missing Documentation:**\n\n1. **Invariants to Maintain:**\n```markdown\n# Priority Queue Invariants\n\n## Data Integrity\n- [ ] isInPriorityQueue == true ‚üπ priorityOrder \u003e 0.0\n- [ ] isInPriorityQueue == true ‚üπ priorityQueuedAt != nil\n- [ ] isInPriorityQueue == true ‚üπ priority ‚àà {1, 5, 10}\n- [ ] Sessions with same priority must have unique priorityOrder\n- [ ] priorityOrder must be finite (not NaN, not Infinity)\n\n## Synchronization\n- [ ] CoreData changes trigger cache refresh\n- [ ] Changes in SessionInfoView propagate to DirectoryListView\n- [ ] Changes in ConversationView propagate to DirectoryListView\n- [ ] Lock state changes update Priority Queue section\n\n## Performance\n- [ ] Cache updates are debounced (150ms)\n- [ ] No full table scans in sorting\n- [ ] WorkItems are cancelled on rapid updates\n- [ ] Background state check prevents watchdog kills\n\n## Error Handling\n- [ ] CoreData save failures rollback mutations\n- [ ] fetchMaxPriorityOrder errors are logged\n- [ ] Invalid priority values are validated\n- [ ] User receives feedback on failures\n```\n\n2. **Code Review Checklist:**\n```markdown\n# Priority Queue Code Review Checklist\n\n## Before Submitting PR\n\n### Data Integrity\n- [ ] Do mutations have rollback on save failure?\n- [ ] Are priority values validated before use?\n- [ ] Does code handle NaN/Infinity in priorityOrder?\n- [ ] Are all three properties (isInPriorityQueue, priorityOrder, priorityQueuedAt) updated together?\n\n### Synchronization\n- [ ] Are cache updates called after CoreData changes?\n- [ ] Are NotificationCenter events posted for cross-view updates?\n- [ ] Is updateCachedPriorityQueueSessions called after mutations?\n- [ ] Does UI update when settings.priorityQueueEnabled changes?\n\n### Performance\n- [ ] Are cache updates debounced?\n- [ ] Does code avoid main thread blocking?\n- [ ] Are CoreData fetches using fetchLimit where appropriate?\n- [ ] Do WorkItems check isAppActive before executing?\n\n### Testing\n- [ ] Do unit tests cover new edge cases?\n- [ ] Do integration tests verify cross-view behavior?\n- [ ] Does migration test validate schema changes?\n- [ ] Do tests verify rollback on errors?\n\n### Documentation\n- [ ] Are complex algorithms documented with comments?\n- [ ] Are design decisions explained?\n- [ ] Are edge cases documented?\n- [ ] Is user-facing behavior described?\n\n### Accessibility\n- [ ] Do buttons have accessibility labels?\n- [ ] Do pickers have accessibility hints?\n- [ ] Are colors tested for contrast?\n- [ ] Does UI work with VoiceOver?\n\n### Error Handling\n- [ ] Are errors logged with sufficient context?\n- [ ] Do users receive feedback on failures?\n- [ ] Are silent failures avoided?\n- [ ] Is error propagation appropriate?\n```\n\n3. **Common Pitfalls:**\n```markdown\n# Priority Queue Common Pitfalls\n\n## ‚ùå Don't\n- Don't set isInPriorityQueue without updating priorityOrder\n- Don't use try? without logging errors\n- Don't forget to call updateCachedPriorityQueueSessions\n- Don't hardcode priority values (use constants)\n- Don't block main thread with CoreData operations\n- Don't forget rollback on save failures\n\n## ‚úÖ Do\n- Do validate priority values before use\n- Do log errors with context (session ID, priority)\n- Do update all caches after mutations\n- Do use OSLog logger instead of print()\n- Do check isAppActive before heavy operations\n- Do provide user feedback on errors\n```\n\n**Implementation:**\nCreate PRIORITY_QUEUE_GUIDELINES.md in project root documenting:\n- Architectural patterns\n- Data flow diagrams\n- Invariants to maintain\n- Common pitfalls\n- Code review checklist\n- Testing requirements\n\n**Benefits:**\n- Prevents regression bugs\n- Onboards new developers faster\n- Documents tribal knowledge\n- Improves code review quality\n- Reduces maintenance burden","status":"open","priority":3,"issue_type":"task","created_at":"2025-12-09T22:17:33.695719-06:00","updated_at":"2025-12-09T22:17:33.695719-06:00","source_repo":".","labels":["code-review"]}
{"id":"voice-code-priority-queue-sps","content_hash":"4b4dda88a5b654c86b2bee8b0716614415776dd9ac0b0378a3e2dd44267baeca","title":"Verify memory safety of WorkItem capture list with sessions array","description":"DispatchWorkItem captures [viewModel, sessions] by value. sessions is @State array of NSManagedObjects. Captured array holds strong references to CoreData objects for 150ms+ debounce delay. Verify objects don't fault/dangle if deleted during delay. Low risk but should validate in memory profiler.","status":"open","priority":3,"issue_type":"task","created_at":"2025-12-09T21:11:30.077999-06:00","updated_at":"2025-12-09T21:11:30.077999-06:00","source_repo":".","labels":["performance"]}
{"id":"voice-code-priority-queue-sru9","content_hash":"88428caaa43550f839c387b13f24ece0fef061c5660da5f378126bfa254abb5c","title":"Auto-add fix: Implement session_updated approach for priority queue","description":"Implement the fix described in PRIORITY_QUEUE_AUTO_ADD_FIX.md - trigger auto-add in SessionSyncManager.handleSessionUpdated when assistant messages are received instead of relying on unreliable turn_complete message.\n\nFiles to modify:\n- ios/VoiceCode/Managers/SessionSyncManager.swift (add ~15 lines after CoreData save)\n\nKey implementation details:\n1. Check if assistantMessagesToSpeak is not empty (indicates new assistant response)\n2. Dispatch to main thread for CoreData access\n3. Check AppSettings.shared.priorityQueueEnabled\n4. Fetch session by backendName (sessionId parameter is the backend name)\n5. Call CDBackendSession.addToPriorityQueue (idempotent)\n6. Log success/failure appropriately\n\nReference: PRIORITY_QUEUE_AUTO_ADD_FIX.md section 'Code Changes'","acceptance_criteria":"1. Code compiles without errors\n2. Auto-add triggers when session_updated contains new assistant message\n3. Auto-add does NOT trigger for user-only messages\n4. Auto-add does NOT trigger when priority queue is disabled\n5. Auto-add is idempotent (safe to call multiple times)\n6. Proper logging for success and failure cases\n7. No regressions in existing functionality","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-10T20:07:04.98605-06:00","updated_at":"2025-12-10T20:29:48.269193-06:00","closed_at":"2025-12-10T20:29:48.269193-06:00","source_repo":"."}
{"id":"voice-code-priority-queue-ssd","content_hash":"bbca9208c260eb9fa2bc85f168771979d8370e701c7723f54a4b78c6abce475a","title":"Phase 1: Settings - Add priorityQueueEnabled toggle","description":"Add priority queue feature toggle to app settings with persistence and non-destructive behavior.\n\nFILES TO MODIFY:\n1. ios/VoiceCode/Managers/AppSettings.swift\n   - Add @Published var priorityQueueEnabled: Bool\n   - Add UserDefaults persistence in didSet\n   - Initialize from UserDefaults in init()\n\n2. ios/VoiceCode/Views/SettingsView.swift\n   - Add new Section with header \"Priority Queue\"\n   - Add Toggle control bound to settings.priorityQueueEnabled\n   - Add descriptive Text caption\n\nIMPLEMENTATION STEPS:\n\nAppSettings.swift:\n1. Locate existing @Published properties (around line 56)\n2. Add new property after queueEnabled:\n   @Published var priorityQueueEnabled: Bool {\n       didSet {\n           UserDefaults.standard.set(priorityQueueEnabled, forKey: \"priorityQueueEnabled\")\n       }\n   }\n3. Update init() to load from UserDefaults:\n   self.priorityQueueEnabled = UserDefaults.standard.bool(forKey: \"priorityQueueEnabled\")\n4. Default is false (opt-in feature)\n\nSettingsView.swift:\n1. Find existing Queue section (around line 110)\n2. Add new section after Queue section:\n   Section(header: Text(\"Priority Queue\")) {\n       Toggle(\"Enable Priority Queue\", isOn: $settings.priorityQueueEnabled)\n       \n       Text(\"Automatically track sessions in priority-based queue. Sessions updated on workstation appear automatically. Lower priority numbers appear first.\")\n           .font(.caption)\n           .foregroundColor(.secondary)\n   }\n\nTOGGLE BEHAVIOR (NEW):\n\nWhen User DISABLES Priority Queue (toggle OFF):\n1. UI section in DirectoryListView hidden immediately\n2. CoreData attributes remain UNCHANGED (data persists)\n3. Auto-add from backend stops\n4. Existing queued sessions remain in database with isInPriorityQueue=true\n\nWhen User RE-ENABLES Priority Queue (toggle ON):\n1. UI section reappears\n2. Previously queued sessions show in queue (state preserved)\n3. Auto-add resumes for new sessions\n\nRationale:\n- Non-destructive toggle (user's queue state preserved)\n- Similar to \"hiding\" a feature, not deleting data\n- User can experiment with feature without losing work\n- Alternative (clearing all queue flags) rejected as too destructive\n\nImplementation Note:\n- No special code needed for disable/enable behavior\n- DirectoryListView already checks settings.priorityQueueEnabled\n- VoiceCodeClient already checks before auto-add\n- SwiftUI reactivity handles UI hide/show automatically\n\nVERIFICATION - Test Pyramid:\n\nUnit Tests (PriorityQueueManagementTests.swift):\n1. testPriorityQueueSettingsDefaultValue\n   - Create new AppSettings instance\n   - Assert priorityQueueEnabled == false\n   \n2. testPriorityQueueSettingsPersistence\n   - Create AppSettings, set priorityQueueEnabled = true\n   - Create new AppSettings instance\n   - Assert priorityQueueEnabled == true (persisted)\n   \n3. testPriorityQueueSettingsToggle\n   - Toggle value multiple times\n   - Verify UserDefaults updated each time\n\n4. testToggleOffPreservesQueueData (NEW)\n   - Add 3 sessions to priority queue\n   - Set priorityQueueEnabled = false\n   - Assert sessions still have isInPriorityQueue=true\n   - Assert priority/priorityOrder values unchanged\n\n5. testToggleOnRestoresQueueDisplay (NEW)\n   - Add sessions to queue with enabled=true\n   - Set enabled=false\n   - Set enabled=true\n   - Assert sessions still in queue\n   - Assert UI section would show them\n\nIntegration Tests:\n1. testSettingsViewDisplaysPriorityQueueToggle\n   - Create SettingsView with mock AppSettings\n   - Verify Priority Queue section renders\n   - Verify toggle exists and is bound correctly\n\n2. testToggleOffHidesUISection (NEW)\n   - Enable priority queue, add sessions\n   - Navigate to DirectoryListView\n   - Verify Priority Queue section visible\n   - Disable toggle in settings\n   - Navigate back to DirectoryListView\n   - Verify Priority Queue section hidden\n\nManual Verification:\n1. Build and run app (Cmd+R)\n2. Navigate to Settings view (tap gear icon)\n3. Scroll to find \"Priority Queue\" section\n4. Verify section appears below Queue section\n5. Verify toggle switch is OFF by default\n6. Tap toggle to ON\n7. Add 3 sessions to priority queue\n8. Navigate back to Settings\n9. Toggle OFF\n10. Navigate to directory view ‚Üí verify section hidden\n11. Sessions still in CoreData (check debugger)\n12. Toggle back ON\n13. Navigate to directory view ‚Üí verify section reappears with same sessions\n14. Kill app and relaunch\n15. Verify toggle state persisted\n16. Verify queue data preserved\n\nACCEPTANCE CRITERIA:\n‚úÖ priorityQueueEnabled property added to AppSettings\n‚úÖ UserDefaults key: \"priorityQueueEnabled\"\n‚úÖ Default value: false\n‚úÖ Toggle UI added to SettingsView\n‚úÖ Description text explains feature clearly\n‚úÖ State persists across app launches\n‚úÖ Toggle OFF hides UI but preserves CoreData\n‚úÖ Toggle ON restores UI with previous queue state\n‚úÖ Unit tests pass for persistence logic and data preservation\n‚úÖ Manual toggle test confirms non-destructive behavior\n\nFUTURE CONSIDERATION:\nAdd \"Clear Priority Queue\" button that explicitly removes all sessions from queue. This would give users control over data cleanup if desired.\n\nDependencies (1):\n  [blocks] voice-code-priority-queue-vpf (open): Phase 1: CoreData Schema - Add priority queue attributes to CDBackendSession [P0]\n\nDependents (1):\n  [blocks] voice-code-priority-queue-rd6 (open): Phase 1: Unit Tests - Create PriorityQueueManagementTests.swift [P0]","status":"closed","priority":0,"issue_type":"feature","created_at":"2025-12-07T17:55:11.767029-06:00","updated_at":"2025-12-09T19:57:44.975991-06:00","closed_at":"2025-12-09T19:57:44.975991-06:00","source_repo":".","dependencies":[{"issue_id":"voice-code-priority-queue-ssd","depends_on_id":"voice-code-priority-queue-vpf","type":"blocks","created_at":"2025-12-07T17:59:11.786262-06:00","created_by":"travisbrown"}]}
{"id":"voice-code-priority-queue-svb","content_hash":"e225300ba45701fbcc226c5b9332f3329b8dfe9a074bd9755aa7e86c8c6d6741","title":"DispatchWorkItem closures capture entire sessions array creating memory pressure","description":"**File:** DirectoryListView.swift:446-465, 483-512\n\n**Issue:** DispatchWorkItem closures capture entire sessions array. Cannot use [weak self] because DirectoryListView is a struct (SwiftUI View), not a class.\n\n**Impact:** Memory overhead from duplicating session array in each WorkItem closure. With 100 sessions √ó 10 debounces/sec = 1000 session references in memory.\n\n**Constraint:** SwiftUI View is a struct, so:\n- No weak references possible\n- Value semantics mean captures are copies\n- Intentional snapshot behavior to avoid SwiftUI dependency tracking (per comment line 484)\n\n**Analysis:**\nStruct capture is intentional design:\n1. Prevents SwiftUI infinite layout loops (see comment lines 447-449)\n2. Avoids accessing @Published properties in closure\n3. Ensures stable snapshot during async execution\n\n**Solutions:**\n\n**Option 1 - Accept current behavior:**\nWith typical usage (5-20 sessions), memory impact is minimal. Only issue with power users (100+ sessions).\n\n**Option 2 - Refactor to class-based ViewModel:**\nExtract queue logic to ObservableObject class, use weak self there. Major refactor, breaks SwiftUI patterns.\n\n**Option 3 - Optimize data structure:**\nInstead of capturing full CDBackendSession objects, capture minimal data:\n```swift\nstruct SessionSnapshot: Identifiable {\n    let id: UUID\n    let priority: Int32\n    let priorityOrder: Double\n    let isInPriorityQueue: Bool\n}\n\nlet snapshots = sessions.map { SessionSnapshot(id: $0.id, priority: $0.priority, ...) }\nlet workItem = DispatchWorkItem { [viewModel, snapshots] in\n    // Work with lightweight snapshots\n}\n```\n\n**Recommendation:**\nDowngrade to P3. Accept current behavior unless profiling shows actual memory issues with real-world usage.","status":"open","priority":3,"issue_type":"bug","created_at":"2025-12-09T22:13:05.910734-06:00","updated_at":"2025-12-09T22:43:30.943088-06:00","source_repo":".","labels":["memory-management"]}
{"id":"voice-code-priority-queue-syl","content_hash":"714391dd9e9a06cab149701525ae7b0511c774846fc72c5a48eba79b8fa8e68d","title":"SessionInfoView changePriority doesn't update priorityQueuedAt timestamp","description":"**File:** SessionInfoView.swift:234-260\n\n**Issue:** changePriority() doesn't update session.priorityQueuedAt timestamp when priority changes. The timestamp shows when session was FIRST added to queue, not when priority was last changed.\n\n**Impact:** \n- \"Queued: 3 hours ago\" may be misleading if user changed priority 5 minutes ago\n- No audit trail of priority changes\n- Can't determine if session priority is stale\n\n**Evidence:**\n```swift\n// SessionInfoView.swift:249-251\nsession.priority = newPriority\nsession.priorityOrder = maxOrder + 1.0\n// ‚ùå session.priorityQueuedAt NOT updated\n```\n\n**Question:** Should priorityQueuedAt represent:\n1. **Initial add time** (current behavior) - when session FIRST entered queue\n2. **Last modified time** - when priority was LAST changed\n3. Both: separate `queuedAt` and `priorityModifiedAt` fields\n\n**Proposed Fix (if option 2):**\n```swift\nsession.priority = newPriority\nsession.priorityOrder = maxOrder + 1.0\nsession.priorityQueuedAt = Date()  // Update timestamp\n```\n\n**Note:** This is a product decision - current behavior may be intentional to preserve original queue time.","status":"open","priority":3,"issue_type":"bug","created_at":"2025-12-09T21:45:18.062297-06:00","updated_at":"2025-12-09T21:45:18.062297-06:00","source_repo":".","labels":["data-consistency"]}
{"id":"voice-code-priority-queue-tfr","content_hash":"5425c394a8b399ffdbc617202e1aeb55f82af49017441ffd57ed91b96f9f05e6","title":"Move priority queue auto-add to after successful response","description":"ConversationView lines 584-588 commented out premature auto-add to prevent ghost sessions. Auto-add needs proper implementation in response handler with these requirements:\n1. Only add to priority queue after turn_complete received (not before send)\n2. Add visual feedback (toast/banner) when auto-added\n3. Handle case where user manually adds before turn_complete\n4. Consider: Should auto-add happen for ALL prompts or only first prompt in new session?\n\nCurrent workaround: Users must manually add sessions to priority queue via toolbar button.","status":"closed","priority":1,"issue_type":"bug","created_at":"2025-12-09T20:59:47.989038-06:00","updated_at":"2025-12-10T19:29:10.441446-06:00","closed_at":"2025-12-10T19:29:10.441446-06:00","source_repo":"."}
{"id":"voice-code-priority-queue-ttwt","content_hash":"f08d9ca8fcaae75f0e08f618caba3179e080d5e357c56b31fe21f16cb27a8ad2","title":"Auto-add frontend-created sessions to priority queue","description":"Sessions created via DirectoryListView.createNewSession() and SessionsForDirectoryView.createNewSession() are not automatically added to priority queue when priorityQueueEnabled is true. Only backend session_created events trigger auto-add. Frontend sessions should also be auto-added after CoreData save completes. Files: DirectoryListView.swift:644, SessionsForDirectoryView.swift:234","status":"closed","priority":2,"issue_type":"bug","created_at":"2025-12-10T19:19:05.576773-06:00","updated_at":"2025-12-10T19:29:07.801901-06:00","closed_at":"2025-12-10T19:29:07.801901-06:00","source_repo":"."}
{"id":"voice-code-priority-queue-tyi","content_hash":"3953582dec176a295cab37e2f853d86a06c31cd843c4c45919adde26ad98abcd","title":"Priority Queue feature has zero localization support for non-English users","description":"**File:** DirectoryListView.swift:214, SettingsView.swift:119-121, SessionInfoView.swift:106-109\n\n**Issue:** All user-facing text is hardcoded English strings with no localization support. App cannot be translated to other languages.\n\n**Impact:** \n- Non-English users cannot use Priority Queue feature\n- Cannot ship in non-English markets\n- Violates iOS localization best practices\n\n**Hardcoded Strings:**\n\n1. **DirectoryListView.swift:214:**\n```swift\nText(\"Priority Queue\")  // Section header\n```\n\n2. **SettingsView.swift:119-121:**\n```swift\nToggle(\"Enable Priority Queue\", isOn: $settings.priorityQueueEnabled)\nText(\"Automatically track sessions in priority-based queue. Sessions updated on workstation appear automatically. Lower priority numbers appear first.\")\n```\n\n3. **SessionInfoView.swift:81-83:**\n```swift\nText(\"High (1)\").tag(Int32(1))\nText(\"Medium (5)\").tag(Int32(5))\nText(\"Low (10)\").tag(Int32(10))\n```\n\n4. **SessionInfoView.swift:106-109:**\n```swift\nText(\"Priority Queue\")\nText(\"Change priority to adjust position in queue. Lower priority number = higher importance.\")\n```\n\n5. **ConversationView.swift:** (no visible text but accessibility labels missing)\n\n**Proposed Fix:**\n```swift\n// Create Localizable.strings file\n\"priority_queue.section_title\" = \"Priority Queue\";\n\"priority_queue.toggle_label\" = \"Enable Priority Queue\";\n\"priority_queue.description\" = \"Automatically track sessions in priority-based queue. Lower priority numbers appear first.\";\n\"priority_queue.priority_high\" = \"High (1)\";\n\"priority_queue.priority_medium\" = \"Medium (5)\";\n\"priority_queue.priority_low\" = \"Low (10)\";\n\n// Use in code:\nText(LocalizedStringKey(\"priority_queue.section_title\"))\nToggle(LocalizedStringKey(\"priority_queue.toggle_label\"), isOn: $settings.priorityQueueEnabled)\nText(LocalizedStringKey(\"priority_queue.description\"))\n```\n\nOr use NSLocalizedString:\n```swift\nText(NSLocalizedString(\"priority_queue.section_title\", comment: \"Priority Queue section header\"))\n```\n\n**Strings Needing Localization:**\n- Section headers (\"Priority Queue\")\n- Settings labels and descriptions\n- Priority level names (High, Medium, Low)\n- Empty state messages\n- Error messages\n- Confirmation messages\n- Accessibility labels\n\n**Related:** voice-code-priority-queue-2e6 [P4] tracks future localization support.\n\n**Note:** Existing codebase also lacks localization, so this is consistent with current state. But should be addressed before international launch.","status":"open","priority":3,"issue_type":"bug","created_at":"2025-12-09T22:13:03.465743-06:00","updated_at":"2025-12-09T22:13:03.465743-06:00","source_repo":".","labels":["internationalization"]}
{"id":"voice-code-priority-queue-u07","content_hash":"12daf6efeb1ff94f440d83fc11b11b3f0cbfbddb2b345f7f359573d27313d5ce","title":"Consider adding priorityOrder compaction/normalization","description":"After many operations, priorityOrder values could become large (e.g., 10000.0). Consider periodic normalization to renumber from 1.0 to N.0 within each priority group. Benefits: cleaner values, avoid eventual Double precision limits. Not urgent - would take millions of operations to matter.","status":"open","priority":3,"issue_type":"task","created_at":"2025-12-09T21:04:59.680962-06:00","updated_at":"2025-12-09T21:04:59.680962-06:00","source_repo":".","labels":["enhancement"]}
{"id":"voice-code-priority-queue-un4","content_hash":"b78b033aea23567c805999512fdfac4c5788b91dabffd7b5896afce98f2ca0cd","title":"Settings description text is confusing and inaccurate","description":"SettingsView line 121: 'Sessions updated on workstation appear automatically' is misleading. Priority Queue doesn't sync from workstation - it auto-adds when user sends prompts from iOS. Correct description: 'Sessions are automatically added when you send a prompt. Manage priorities from session info. Lower priority numbers appear first (1=High, 5=Med, 10=Low).' Critical for user understanding.","status":"closed","priority":2,"issue_type":"bug","created_at":"2025-12-09T21:22:38.35771-06:00","updated_at":"2025-12-09T22:36:03.105942-06:00","closed_at":"2025-12-09T22:36:03.105942-06:00","source_repo":".","labels":["ux"]}
{"id":"voice-code-priority-queue-v08","content_hash":"fd145bce391c96c922323361cc77de649c1f4a166e9afb06e5b63d04eec8780f","title":"Add integration test for priority queue persistence across app restart","description":"**Task:** Add integration test verifying priority queue state (isInPriorityQueue, priority, priorityOrder, priorityQueuedAt) persists correctly across app restarts using real CoreData store (not in-memory).\n\n**Why:** Current tests use in-memory CoreData which doesn't test persistence. Real-world usage requires priority queue to survive app termination and migration.","status":"open","priority":3,"issue_type":"task","created_at":"2025-12-09T21:37:22.5876-06:00","updated_at":"2025-12-09T21:37:22.5876-06:00","source_repo":".","labels":["testing"]}
{"id":"voice-code-priority-queue-v4w","content_hash":"65e69ac79569bfd21d840cb78192fadb2ca2ad99854e14b23043f45f4cbfc105","title":"SessionInfoView changePriority missing rollback on save failure","description":"**File:** SessionInfoView.swift:234-260\n\n**Issue:** changePriority() mutates session.priority and session.priorityOrder BEFORE calling viewContext.save(). If save fails, session object is left in inconsistent state with new values in memory but old values in persistent store.\n\n**Fix:** Add rollback on CoreData save failure.","status":"closed","priority":2,"issue_type":"bug","created_at":"2025-12-09T21:37:14.560768-06:00","updated_at":"2025-12-09T22:34:39.547164-06:00","closed_at":"2025-12-09T22:34:39.547164-06:00","source_repo":".","labels":["error-handling"]}
{"id":"voice-code-priority-queue-vdk","content_hash":"7bce894b092f905d5d3ebabebce52f551d17ced91e5646fb072f2a58206ee5c0","title":"SettingsView Queue and Priority Queue sections lack visual differentiation","description":"**File:** SettingsView.swift:118-124\n\n**Task:** Priority Queue Settings section has no visual distinction from regular Queue section above it (lines 110-116). Both have similar toggle + description pattern.\n\n**Impact:** Users may not understand the difference between Queue and Priority Queue features. They look identical in Settings.\n\n**Current UI:**\n```\n‚îå‚îÄ Queue ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n‚îÇ ‚òë Enable Queue           ‚îÇ\n‚îÇ Show threads in queue... ‚îÇ\n‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n\n‚îå‚îÄ Priority Queue ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n‚îÇ ‚òê Enable Priority Queue  ‚îÇ\n‚îÇ Automatically track...   ‚îÇ\n‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n```\n\n**Proposed Enhancement:** Add icon or badge to differentiate:\n```swift\nSection(header: \n    Label(\"Priority Queue\", systemImage: \"star.fill\")\n        .foregroundColor(.purple)\n) {\n    // ...\n}\n```\n\nOr reorder sections to group related features:\n1. Server Configuration\n2. Voice Selection\n3. Audio Playback\n4. **Session Management** (new parent section)\n   - Recent\n   - Queue\n   - Priority Queue\n5. Resources\n6. System Prompt\n\n**Priority:** P3 - current UX is functional but could be clearer.","status":"open","priority":3,"issue_type":"task","created_at":"2025-12-09T21:46:03.773056-06:00","updated_at":"2025-12-09T21:46:03.773056-06:00","source_repo":".","labels":["ux"]}
{"id":"voice-code-priority-queue-vpf","content_hash":"71cb290ece0516833c708fbea89036d2907bab02165db3c94046070b949ba492","title":"Phase 1: CoreData Schema - Add priority queue attributes to CDBackendSession","description":"Add four new attributes to CDBackendSession entity for priority queue functionality.\n\nNEW ATTRIBUTES:\n- isInPriorityQueue: Bool (default false) - Whether session is in priority queue\n- priority: Int32 (default 10) - Priority level (lower = higher priority)\n- priorityOrder: Double (default 0.0) - Hidden ordering field within same priority\n- priorityQueuedAt: Date? (default nil) - Timestamp when added to priority queue\n\nFILES TO MODIFY:\n1. ios/VoiceCode.xcodeproj/VoiceCode.xcdatamodeld\n   - Select VoiceCode.xcdatamodeld in Xcode\n   - Editor ‚Üí Add Model Version (if not version 2 yet)\n   - Creates \"VoiceCode 2.xcdatamodel\"\n   - Set as current model: File Inspector ‚Üí Model Version ‚Üí \"VoiceCode 2\"\n\n2. ios/VoiceCode/Models/CDBackendSession.swift\n   - Add @NSManaged properties for all 4 attributes\n   - Location: After existing queue attributes (isInQueue, queuePosition, queuedAt)\n\nIMPLEMENTATION STEPS:\n\nCoreData Model (VoiceCode.xcdatamodeld):\n1. Open Xcode project\n2. Navigate to VoiceCode.xcdatamodeld\n3. Editor menu ‚Üí Add Model Version ‚Üí name: \"VoiceCode 2\"\n4. Select File Inspector (Cmd+Option+1)\n5. Model Version ‚Üí set Current to \"VoiceCode 2\"\n6. Select CDBackendSession entity in VoiceCode 2 model\n7. Click + button in Attributes section (4 times)\n\n8. Add isInPriorityQueue:\n   - Name: isInPriorityQueue\n   - Type: Boolean\n   - Default Value: NO\n   - Optional: Uncheck\n   - Transient: Uncheck\n\n9. Add priority:\n   - Name: priority\n   - Type: Integer 32\n   - Default Value: 10\n   - Optional: Uncheck\n\n10. Add priorityOrder:\n    - Name: priorityOrder\n    - Type: Double\n    - Default Value: 0\n    - Optional: Uncheck\n\n11. Add priorityQueuedAt:\n    - Name: priorityQueuedAt\n    - Type: Date\n    - Optional: Check (allow nil)\n\n12. Save model file (Cmd+S)\n\nSwift Properties (CDBackendSession.swift):\n1. Open CDBackendSession.swift\n2. Find existing queue properties section\n3. Add after queuedAt property:\n\n@NSManaged public var isInPriorityQueue: Bool\n@NSManaged public var priority: Int32\n@NSManaged public var priorityOrder: Double\n@NSManaged public var priorityQueuedAt: Date?\n\n4. Save file (Cmd+S)\n\nNSPersistentContainer Configuration:\nVerify automatic migration enabled (should already be configured):\n\nlazy var persistentContainer: NSPersistentContainer = {\n    let container = NSPersistentContainer(name: \"VoiceCode\")\n    \n    let description = container.persistentStoreDescriptions.first\n    description?.shouldInferMappingModelAutomatically = true  // Enable\n    description?.shouldMigrateStoreAutomatically = true       // Enable\n    \n    container.loadPersistentStores { (storeDescription, error) in\n        if let error = error as NSError? {\n            fatalError(\"Unresolved error \\(error), \\(error.userInfo)\")\n        }\n    }\n    return container\n}()\n\nVERIFICATION - Test Pyramid:\n\nUnit Tests (testCoreDataSchemaAttributes):\n- Create CDBackendSession entity\n- Assert isInPriorityQueue == false\n- Assert priority == 10\n- Assert priorityOrder == 0.0\n- Assert priorityQueuedAt == nil\n- Save context, reload session\n- Assert values persist correctly\n- Assert attribute types correct\n\nIntegration Tests (testLightweightMigration):\n- Simulates upgrading from old model to new model\n- Create old version store (if available)\n- Load with new model, automatic migration\n- Assert migration succeeds (no errors)\n- Fetch all existing sessions\n- Assert new attributes have default values\n- Assert existing attributes (name, workingDirectory) preserved\n\nManual Verification:\n1. Build project (Cmd+B)\n2. Check for compilation errors\n3. Run app on simulator\n4. Monitor console for migration logs\n5. Navigate to Projects view\n6. Verify app doesn't crash\n7. Use debugger (lldb) to inspect session:\n   (lldb) po session.isInPriorityQueue  // false\n   (lldb) po session.priority            // 10\n   (lldb) po session.priorityOrder       // 0.0\n   (lldb) po session.priorityQueuedAt    // nil\n8. Create new session via app\n9. Inspect again, verify defaults applied\n\nACCEPTANCE CRITERIA:\n‚úÖ VoiceCode 2 model version created\n‚úÖ All 4 attributes added with correct types\n‚úÖ Default values configured in model editor\n‚úÖ All @NSManaged properties declared in Swift\n‚úÖ Project builds without errors\n‚úÖ App runs without crashes\n‚úÖ Migration succeeds automatically\n‚úÖ Existing sessions have new attributes with defaults\n‚úÖ No data loss for existing queue or session data\n‚úÖ testCoreDataSchemaAttributes passes\n‚úÖ testLightweightMigration passes (if implemented)\n‚úÖ Console shows migration success (no errors)\n\nEDGE CASES HANDLED:\n- Fresh install (no existing data): Defaults apply\n- Existing sessions: Migration adds attributes automatically\n- Existing queue sessions: isInQueue preserved, isInPriorityQueue separate\n- Model version tracking: Explicit version 2 created","status":"closed","priority":0,"issue_type":"feature","created_at":"2025-12-07T17:54:57.186181-06:00","updated_at":"2025-12-09T19:54:37.556176-06:00","closed_at":"2025-12-09T19:54:37.556176-06:00","source_repo":".","dependencies":[{"issue_id":"voice-code-priority-queue-vpf","depends_on_id":"voice-code-priority-queue-3ay","type":"blocks","created_at":"2025-12-08T19:37:43.362854-06:00","created_by":"travisbrown"}]}
{"id":"voice-code-priority-queue-vs1","content_hash":"bfb2397dafc112c9b9a513ea2e8d46a0de93905698097e64db6d67b51aa4e6d7","title":"Create Priority enum for type-safe priority values","description":"**Merged with voice-code-priority-queue-4ln (magic numbers).**\n\n**Proposed implementation:**\n```swift\nenum Priority: Int32, CaseIterable {\n    case high = 1\n    case medium = 5\n    case low = 10\n    \n    var displayName: String {\n        switch self {\n        case .high: return \"High (1)\"\n        case .medium: return \"Medium (5)\"\n        case .low: return \"Low (10)\"\n        }\n    }\n    \n    static let  = Priority.low\n}\n\nenum PriorityQueueConstants {\n    static let orderIncrement: Double = 1.0\n    static let debounceDelay: TimeInterval = 0.15\n    static let userDefaultsKey = \"priorityQueueEnabled\"\n}\n```\n\n**Benefits:**\n- Type-safe priority values\n- Centralized display strings\n- Easy to add new priority levels\n- Clear documentation of magic numbers\n\n**Recommendation:** Good refactor, but P3 priority since current Int32 works.","status":"open","priority":3,"issue_type":"task","created_at":"2025-12-09T21:00:50.920267-06:00","updated_at":"2025-12-10T09:41:19.726954-06:00","source_repo":".","labels":["refactor"]}
{"id":"voice-code-priority-queue-w7g","content_hash":"e750dd93e75e22de04c6785f5c47f4a82d269aa95d0f884a0afd74cf05bfbbf0","title":"Add validation to prevent priority property mutation during fetch","description":"fetchMaxPriorityOrder queries sessions with specific priority while changePriority mutates session.priority. If fetch executes between priority assignment and save, could get stale maxOrder. Low probability but possible race. Fix: Use transaction or fetch sessions excluding current session ID in predicate.","status":"closed","priority":1,"issue_type":"bug","created_at":"2025-12-09T21:03:51.001316-06:00","updated_at":"2025-12-09T22:33:18.892356-06:00","closed_at":"2025-12-09T22:33:18.892356-06:00","source_repo":"."}
{"id":"voice-code-priority-queue-wl1","content_hash":"c36e1e9050b1e54c6642828773a710aeae7bdaaae9ffde9656cdecae4b982227","title":"Extract duplicate priority queue functions to shared extension","description":"Four priority queue functions are duplicated across 3 files (DirectoryListView, ConversationView, SessionInfoView): fetchMaxPriorityOrder, addToPriorityQueue, removeFromPriorityQueue, changePriority. Already caused maintenance issue when changePriority bug had to be fixed in all 3 files. Solution: Extract to CDBackendSession+PriorityQueue.swift extension.","status":"closed","priority":0,"issue_type":"bug","created_at":"2025-12-09T20:58:35.249876-06:00","updated_at":"2025-12-09T22:24:02.140802-06:00","closed_at":"2025-12-09T22:24:02.140802-06:00","source_repo":".","labels":["refactor"]}
{"id":"voice-code-priority-queue-wp1","content_hash":"ffefcc2a6afebee86b06939b2d768aa9af0ac437ed4ab839dd1da6e6a4aa5759","title":"Add telemetry/analytics for priority queue feature usage","description":"Track: 1) Enable/disable rates, 2) Priority distribution (how many use High/Med/Low), 3) Average queue size, 4) Priority change frequency, 5) Auto-add vs manual add ratio. Data would inform future UX decisions and validate feature value.","status":"open","priority":4,"issue_type":"task","created_at":"2025-12-09T21:05:31.850144-06:00","updated_at":"2025-12-09T21:05:31.850144-06:00","source_repo":".","labels":["analytics"]}
{"id":"voice-code-priority-queue-x8j","content_hash":"2f2e0cfb69fd57da7510e18cd67c708c57da10a296b0fe37cf752e7c8a20b807","title":"Toolbar star icon color purple may conflict with future themes","description":"ConversationView lines 339, 347: star icons use hardcoded .foregroundColor(.purple). If app adds dark mode or custom themes, purple may not have sufficient contrast. Consider using semantic colors from asset catalog or system colors. Also verify purple choice - stars typically yellow/gold in iOS. Design decision needed.","status":"open","priority":4,"issue_type":"task","created_at":"2025-12-09T21:23:41.362939-06:00","updated_at":"2025-12-09T21:23:41.362939-06:00","source_repo":".","labels":["ui"]}
{"id":"voice-code-priority-queue-xhz","content_hash":"443cdd489d64d8f47ef7cf4c34c5bcfdec6e9bc1cfe821ed3a0d20894cc96dc3","title":"DirectoryListView creates new WorkItem on every debounce call instead of reusing","description":"**File:** DirectoryListView.swift:464-502\n\n**Issue:** updateCachedPriorityQueueSessions() creates DispatchWorkItem with 150ms debounce, but if called rapidly (e.g., session count changes 10 times in 1 second), creates 10 WorkItems even though only last one executes.\n\n**Impact:**\n- Memory allocation overhead from unused WorkItems\n- Closure captures grow with each cancellation\n- GC pressure from abandoned closures\n\n**Evidence:**\n```swift\n// DirectoryListView.swift:464-502\nprivate func updateCachedPriorityQueueSessions() {\n    priorityQueueUpdateWorkItem?.cancel()  // Cancel previous\n    \n    let workItem = DispatchWorkItem { ... }  // ‚ùå Allocate new WorkItem every time\n    priorityQueueUpdateWorkItem = workItem\n    \n    DispatchQueue.main.asyncAfter(deadline: .now() + 0.15, execute: workItem)\n}\n```\n\n**Scenario:**\n1. Call updateCached... 10 times in 100ms\n2. Creates 10 WorkItems\n3. Cancels first 9\n4. Only 10th executes\n5. First 9 allocations wasted\n\n**Why This Happens:**\n- onChange(of: sessions.count) fires on every session add/remove\n- onChange(of: viewModel.lockedSessions) fires on every lock/unlock\n- NotificationCenter fires on session list updates\n- All three can fire rapidly during batch operations\n\n**Proposed Optimization:**\n```swift\n// Reuse WorkItem instead of creating new one\nprivate func updateCachedPriorityQueueSessions() {\n    guard priorityQueueUpdateWorkItem == nil || priorityQueueUpdateWorkItem?.isCancelled == true else {\n        return  // Already scheduled, skip\n    }\n    \n    let workItem = DispatchWorkItem { [weak self] in\n        guard let self = self else { return }\n        // ... update logic ...\n        self.priorityQueueUpdateWorkItem = nil  // Clear after execution\n    }\n    \n    priorityQueueUpdateWorkItem = workItem\n    DispatchQueue.main.asyncAfter(deadline: .now() + 0.15, execute: workItem)\n}\n```\n\nOr use NSObject.cancelPreviousPerformRequests:\n```swift\n// Cancel previous scheduled call\nNSObject.cancelPreviousPerformRequests(withTarget: self, selector: #selector(updateCached), object: nil)\n// Schedule new call\nself.perform(#selector(updateCached), with: nil, afterDelay: 0.15)\n```\n\n**Note:** Current implementation is CORRECT but not optimal. WorkItems are lightweight, so overhead is minimal.","status":"open","priority":3,"issue_type":"bug","created_at":"2025-12-09T22:07:53.91816-06:00","updated_at":"2025-12-09T22:07:53.91816-06:00","source_repo":".","labels":["performance"]}
{"id":"voice-code-priority-queue-ybs","content_hash":"d6d9c031aa095ce5914baf5e6a56749e1d5ebd3960fa27653727a0a1315bc8ef","title":"DirectoryListView sort doesn't handle NaN or Infinity in priorityOrder","description":"**File:** DirectoryListView.swift:472-490\n\n**Issue:** Three-level sort assumes priority and priorityOrder are never NaN, Infinity, or -Infinity. If CoreData corruption or manual edit sets invalid values, sort becomes non-deterministic.\n\n**Impact:**\n- Corrupted Double values cause undefined sort behavior\n- App may crash or hang on sort operations\n- Priority Queue section shows random order\n\n**Edge Cases Not Handled:**\n\n1. **NaN (Not a Number):**\n```swift\nsession.priorityOrder = Double.nan\n// Comparison: NaN \u003c 1.0 ‚Üí false\n// Comparison: 1.0 \u003c NaN ‚Üí false\n// Sort becomes unstable\n```\n\n2. **Infinity:**\n```swift\nsession.priorityOrder = Double.infinity\n// Always sorts to end\n// Could be intentional or corruption\n```\n\n3. **Negative values:**\n```swift\nsession.priorityOrder = -1.0\n// Sorts before 0.0\n// Violates invariant that priorityOrder \u003e= 0.0\n```\n\n**Proposed Fix:**\n```swift\n.sorted { session1, session2 in\n    // 1. Priority (ascending)\n    let priority1 = session1.priority\n    let priority2 = session2.priority\n    if priority1 != priority2 {\n        return priority1 \u003c priority2\n    }\n    \n    // 2. Priority order (ascending) - validate before comparing\n    let order1 = session1.priorityOrder.isFinite ? session1.priorityOrder : 0.0\n    let order2 = session2.priorityOrder.isFinite ? session2.priorityOrder : 0.0\n    if order1 != order2 {\n        return order1 \u003c order2\n    }\n    \n    // 3. Session ID (deterministic)\n    return session1.id.uuidString \u003c session2.id.uuidString\n}\n```\n\nOr add validation when setting priorityOrder:\n```swift\nprivate func addToPriorityQueue(_ session: CDBackendSession) {\n    guard !session.isInPriorityQueue else { return }\n    \n    session.isInPriorityQueue = true\n    let maxOrder = fetchMaxPriorityOrder(priority: session.priority)\n    \n    // ‚úÖ Validate result before assigning\n    if maxOrder.isFinite \u0026\u0026 maxOrder \u003e= 0 {\n        session.priorityOrder = maxOrder + 1.0\n    } else {\n        logger.error(\"Invalid maxOrder: \\(maxOrder), using 1.0\")\n        session.priorityOrder = 1.0\n    }\n    \n    session.priorityQueuedAt = Date()\n}\n```\n\n**Related:** voice-code-priority-queue-72z [P3] tracks safeguard against Double.infinity or NaN in priorityOrder.","status":"open","priority":3,"issue_type":"bug","created_at":"2025-12-09T22:08:02.974743-06:00","updated_at":"2025-12-09T22:08:02.974743-06:00","source_repo":".","labels":["edge-case"]}
{"id":"voice-code-priority-queue-ycs","content_hash":"b3f60e3a81b81a80818635c7bfcc357305f289a9b68356b0a503b7882ac13a08","title":"No migration test validates CoreData model upgrade preserves existing user data","description":"**File:** ios/VoiceCode/VoiceCode.xcdatamodeld/.xccurrentversion, VoiceCode 2.xcdatamodel/contents\n\n**Issue:** CoreData model migration from VoiceCode to VoiceCode 2 adds four new attributes but has no migration test to verify existing user data is preserved correctly.\n\n**Impact:**\n- Users upgrading from old version to new version trigger automatic migration\n- If migration fails, app may crash or lose data\n- No automated test validates migration preserves existing sessions\n- No rollback mechanism if migration corrupts data\n\n**Added Attributes:**\n```xml\n\u003cattribute name=\"isInPriorityQueue\" attributeType=\"Boolean\" defaultValueString=\"NO\" usesScalarValueType=\"YES\"/\u003e\n\u003cattribute name=\"priority\" attributeType=\"Integer 32\" defaultValueString=\"10\" usesScalarValueType=\"YES\"/\u003e\n\u003cattribute name=\"priorityOrder\" attributeType=\"Double\" defaultValueString=\"0\" usesScalarValueType=\"YES\"/\u003e\n\u003cattribute name=\"priorityQueuedAt\" optional=\"YES\" attributeType=\"Date\" usesScalarValueType=\"NO\"/\u003e\n```\n\n**Migration Risks:**\n\n1. **Default Values:**\n   - Do existing sessions get isInPriorityQueue = NO? ‚úì\n   - Do existing sessions get priority = 10? ‚úì\n   - Do existing sessions get priorityOrder = 0.0? ‚úì\n   - Do existing sessions get priorityQueuedAt = nil? ‚úì\n\n2. **Data Preservation:**\n   - Are existing session IDs preserved?\n   - Are existing messages preserved?\n   - Are existing user customizations preserved?\n\n3. **Index Creation:**\n   - Does migration create indexes if added in future?\n   - What's performance impact on large databases (1000+ sessions)?\n\n**Proposed Testing:**\n```swift\n// NEW FILE: MigrationTests.swift\nclass CoreDataMigrationTests: XCTestCase {\n    func testMigrationFromV1ToV2PreservesData() {\n        // 1. Create V1 database with sample data\n        let v1Controller = createV1Database()\n        let v1Context = v1Controller.container.viewContext\n        \n        let session = CDBackendSession(context: v1Context)\n        session.id = UUID()\n        session.backendName = \"Test Session\"\n        session.workingDirectory = \"/test\"\n        try! v1Context.save()\n        \n        let sessionID = session.id\n        \n        // 2. Close V1 database\n        v1Controller = nil\n        \n        // 3. Open with V2 model (triggers migration)\n        let v2Controller = PersistenceController(inMemory: false)\n        let v2Context = v2Controller.container.viewContext\n        \n        // 4. Verify data preserved\n        let fetchRequest = CDBackendSession.fetchRequest()\n        fetchRequest.predicate = NSPredicate(format: \"id == %@\", sessionID as CVarArg)\n        \n        let migrated = try! v2Context.fetch(fetchRequest).first!\n        \n        // Verify old data preserved\n        XCTAssertEqual(migrated.backendName, \"Test Session\")\n        XCTAssertEqual(migrated.workingDirectory, \"/test\")\n        \n        // Verify new attributes have defaults\n        XCTAssertFalse(migrated.isInPriorityQueue)\n        XCTAssertEqual(migrated.priority, 10)\n        XCTAssertEqual(migrated.priorityOrder, 0.0)\n        XCTAssertNil(migrated.priorityQueuedAt)\n    }\n}\n```\n\n**Related:**\n- voice-code-priority-queue-6lp [P2]: Verify migration logging\n- voice-code-priority-queue-e7z [P3]: Verify automatic migration with logging","status":"open","priority":3,"issue_type":"bug","created_at":"2025-12-09T22:17:28.614869-06:00","updated_at":"2025-12-09T22:17:28.614869-06:00","source_repo":".","labels":["backward-compatibility"]}
{"id":"voice-code-priority-queue-yja","content_hash":"3c4217ee81205f33d6f9e848103028119649eed39f2fa90f5f64c2318a7eb213","title":"Add unit tests for edge cases in priority queue logic","description":"Missing tests for: 1) Priority change while session locked, 2) Removing session that doesn't exist, 3) Concurrent add operations, 4) Priority change with invalid values, 5) CoreData save failures, 6) Empty priority groups. Add to PriorityQueueManagementTests.swift.","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-09T21:05:06.625387-06:00","updated_at":"2025-12-10T09:39:25.305292-06:00","closed_at":"2025-12-10T09:39:25.305292-06:00","source_repo":".","labels":["testing"]}
{"id":"voice-code-priority-queue-yn5","content_hash":"a00f9f1faa54855a46cfe7ff6a602b9970b53f2d651e817b6981dfd3ac96c80d","title":"Add KVO or notification when session properties change in CoreData","description":"Related to voice-code-priority-queue-do2. DirectoryListView should observe individual session property changes, not just sessions.count. Options: 1) Use @FetchRequest instead of @State, 2) Add NotificationCenter observer for NSManagedObjectContextObjectsDidChange, 3) Use Combine publisher on viewContext. Prevents stale cache.","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-09T21:11:17.737909-06:00","updated_at":"2025-12-09T22:32:35.673104-06:00","closed_at":"2025-12-09T22:32:35.673104-06:00","source_repo":"."}
{"id":"voice-code-priority-queue-yocj","content_hash":"4e4a59b0270ed702f76a70137d45483230f7fbb1dd1bbf3ee1ff9ab64704be29","title":"Auto-add fix: Manual integration testing","description":"Execute integration test checklist from PRIORITY_QUEUE_AUTO_ADD_FIX.md:\n\n1. Basic Flow\n   - Open existing session in ConversationView\n   - Send prompt\n   - Verify session appears in priority queue after Claude responds\n\n2. Reconnection Scenario (THE BUG WE'RE FIXING)\n   - Open existing session\n   - Send prompt\n   - Background the app during Claude processing\n   - Return to app after response completes\n   - Verify session is in priority queue\n\n3. Multiple Sessions\n   - Open session A, send prompt\n   - Switch to session B, send prompt\n   - Verify both sessions appear in priority queue\n\n4. Priority Queue Disabled\n   - Disable priority queue in settings\n   - Send prompt to session\n   - Verify session is NOT auto-added\n\n5. Idempotency\n   - Add session to priority queue manually\n   - Send another prompt\n   - Verify position unchanged (no duplicate add)\n\nReference: PRIORITY_QUEUE_AUTO_ADD_FIX.md section 'Integration Test Checklist'","acceptance_criteria":"All 5 integration test scenarios pass:\n1. Basic Flow - session auto-added after Claude responds\n2. Reconnection Scenario - session auto-added even after app backgrounding\n3. Multiple Sessions - both sessions added to queue\n4. Priority Queue Disabled - session NOT added when feature disabled\n5. Idempotency - position unchanged on repeat prompts","status":"open","priority":1,"issue_type":"task","created_at":"2025-12-10T20:07:31.844033-06:00","updated_at":"2025-12-10T20:15:30.28564-06:00","source_repo":".","dependencies":[{"issue_id":"voice-code-priority-queue-yocj","depends_on_id":"voice-code-priority-queue-m74q","type":"blocks","created_at":"2025-12-10T20:15:17.519424-06:00","created_by":"travisbrown"}]}
{"id":"voice-code-priority-queue-yz2","content_hash":"ba00686b81682e9989a2f810e2a6dead45280f1b58562496cf81834f084a15e8","title":"DirectoryListView saveContext doesn't propagate errors to callers","description":"**File:** DirectoryListView.swift:536-543\n\n**Issue:** saveContext() helper catches and logs CoreData save errors but doesn't propagate them to caller. Functions like addToPriorityQueue() can't tell if save succeeded or failed.\n\n**Impact:**\n- addToPriorityQueue() logs success message even if CoreData save failed (line 566)\n- No user feedback on save failures\n- Silent data loss if disk full or constraint violation\n\n**Evidence:**\n```swift\n// DirectoryListView.swift:537-543\nprivate func saveContext() {\n    do {\n        try viewContext.save()\n    } catch {\n        logger.error(\"‚ùå [PriorityQueue] CoreData save failed: \\(error.localizedDescription)\")\n        // ‚ùå Error not propagated - caller doesn't know save failed\n    }\n}\n\n// DirectoryListView.swift:554-567\nprivate func addToPriorityQueue(_ session: CDBackendSession) {\n    // ... mutations ...\n    saveContext()  // May fail silently\n    logger.info(\"‚úÖ [PriorityQueue] Added session to priority queue...\")  // Logged even on failure\n}\n```\n\n**Fix:** Make saveContext() return Bool or throw:\n```swift\nprivate func saveContext() -\u003e Bool {\n    do {\n        try viewContext.save()\n        return true\n    } catch {\n        logger.error(\"‚ùå [PriorityQueue] CoreData save failed: \\(error.localizedDescription)\")\n        return false\n    }\n}\n\nprivate func addToPriorityQueue(_ session: CDBackendSession) {\n    // ...\n    if saveContext() {\n        logger.info(\"‚úÖ Added to priority queue\")\n    } else {\n        logger.error(\"‚ùå Failed to save priority queue change\")\n    }\n}\n```","status":"closed","priority":3,"issue_type":"bug","created_at":"2025-12-09T21:48:25.412986-06:00","updated_at":"2025-12-10T10:02:02.730076-06:00","closed_at":"2025-12-10T10:02:02.730076-06:00","source_repo":".","labels":["error-handling"]}
{"id":"voice-code-priority-queue-z9w","content_hash":"e052655c8235d83a045794dcd298cf4991034b3c14a70662c50bd566633b262d","title":"DirectoryListView addToPriorityQueue sets isInPriorityQueue before fetching maxOrder","description":"**File:** DirectoryListView.swift:472-490, ConversationView.swift:896-913\n\n**Issue:** When adding session to priority queue, code sets session.isInPriorityQueue = true BEFORE fetching maxOrder and BEFORE CoreData save. If another thread/process adds session to same priority group between these operations, both sessions get same priorityOrder.\n\n**Impact:** Race condition in distributed system:\n1. User A adds session to priority 5 (maxOrder = 0.0)\n2. User B adds different session to priority 5 (maxOrder = 0.0) - simultaneously\n3. Both get priorityOrder = 1.0\n4. Sort order becomes non-deterministic (falls back to UUID tiebreaker)\n\n**Evidence:**\n```swift\n// DirectoryListView.swift:558-563\nsession.isInPriorityQueue = true  // ‚ùå Set BEFORE fetching max\n// Keep existing priority (default 10, or user-set value)\n// Set priorityOrder to end of priority group\nlet maxOrder = fetchMaxPriorityOrder(priority: session.priority)  // Query sees session we just modified!\nsession.priorityOrder = maxOrder + 1.0\nsession.priorityQueuedAt = Date()\n```\n\n**Problem:** fetchMaxPriorityOrder queries sessions where `isInPriorityQueue == YES AND priority == N`. If we already set isInPriorityQueue = true, our own session is included in the query!\n\n**Verification:**\n```swift\n// What fetchMaxPriorityOrder sees:\nNSPredicate(format: \"isInPriorityQueue == YES AND priority == %d\", priority)\n\n// If we set session.isInPriorityQueue = true first:\n// Query includes CURRENT session in results!\n```\n\n**Expected Behavior:**\n- Session A adds to priority 5 ‚Üí priorityOrder = 1.0\n- Session B adds to priority 5 ‚Üí priorityOrder = 2.0\n\n**Actual Behavior:**\n- Session A sets isInPriorityQueue = true\n- Session A fetches maxOrder (includes self) ‚Üí maxOrder = 0.0 (because priorityOrder not set yet)\n- Session A sets priorityOrder = 1.0\n- If query DOES include self but priorityOrder is still 0.0, maxOrder = 0.0 ‚úì\n- If query excludes self because CoreData hasn't saved yet, maxOrder = 0.0 ‚úì\n\n**Actually NOT A BUG** because:\n- priorityOrder is set to 0.0 initially (default)\n- fetchMaxPriorityOrder gets max(0.0) = 0.0 even if self is included\n- Only becomes issue if we set priorityOrder BEFORE calling fetchMaxPriorityOrder\n\n**WAIT - Deeper Issue:**\nIf session already has isInPriorityQueue = true and priorityOrder = 5.0 from previous add, then user removes and re-adds:\n1. removeFromPriorityQueue sets priorityOrder = 0.0\n2. addToPriorityQueue sets isInPriorityQueue = true (already true?)\n3. fetchMaxPriorityOrder includes old sessions but excludes current (priorityOrder = 0.0)\n4. Should work correctly\n\n**Conclusion:** Not a bug in current implementation, but fragile. Order of operations matters.","status":"closed","priority":2,"issue_type":"bug","created_at":"2025-12-09T22:07:49.226215-06:00","updated_at":"2025-12-09T22:34:39.546994-06:00","closed_at":"2025-12-09T22:34:39.546994-06:00","source_repo":".","labels":["data-integrity"]}
{"id":"voice-code-priority-queue-zct","content_hash":"12e8ff08e21c08e2a0b7d9c6a9ef18ca2f8ecbfebe572dfef4b2c580ebb02696","title":"Consider impact of both Queue and Priority Queue being enabled simultaneously","description":"**Analysis:** Current behavior is intentional and useful.\n\n**Behavior:**\n- Queue section: Shows sessions where isInQueue=true (FIFO ordering by queuePosition)\n- Priority Queue section: Shows sessions where isInPriorityQueue=true (priority-based ordering)\n- Session can appear in BOTH sections simultaneously\n- Each section has independent expand/collapse state\n\n**Why this is valid:**\n- Queue = simple FIFO for processing order\n- Priority Queue = prioritized work tracking\n- User might add session to Queue for 'process next' and Priority Queue for 'important'\n- Different use cases, complementary features\n\n**UX considerations already addressed:**\n- voice-code-priority-queue-jd6 (P3) tracks toolbar button confusion when both enabled\n- Sections are visually distinct with different headers\n- Swipe actions correctly target respective queue\n\n**Recommendation:** Close as by-design. Features are complementary, not mutually exclusive.","status":"open","priority":4,"issue_type":"task","created_at":"2025-12-09T21:11:08.811254-06:00","updated_at":"2025-12-10T09:48:12.686677-06:00","source_repo":".","labels":["ux"]}
{"id":"voice-code-priority-queue-zes","content_hash":"350a7f72cfa7bb7e2c70c29d6ec6a6b0164789471b4c6200bd382599da705522","title":"Verify CoreData merge policy handles concurrent priority changes","description":"**Analysis:** Current merge policy is appropriate for single-device iOS app.\n\nNSMergeByPropertyObjectTrumpMergePolicy means:\n- In-memory (object) changes win over store changes\n- Last user action is preserved\n- Single-device = no external conflicts possible\n\n**When this matters:**\n- Multi-device sync (not implemented)\n- Background CloudKit sync (not implemented)\n- Concurrent processes (iOS doesn't allow)\n\n**Current architecture:**\n- Single viewContext on main thread\n- All priority changes user-initiated\n- No external data sources modify priority properties\n\n**Recommendation:** Downgrade to P4. Document merge policy choice in code comment for future reference.","status":"open","priority":4,"issue_type":"task","created_at":"2025-12-09T21:18:32.726933-06:00","updated_at":"2025-12-10T09:36:48.957409-06:00","source_repo":"."}
{"id":"voice-code-priority-queue-zir","content_hash":"513a88b1ac02a2546be80da8708d2584a44aa975d11a30f23b8a26a0bc3a2e15","title":"Replace all print() with OSLog logger in priority queue code","description":"Priority queue functions use mix of print() and logger. ConversationView lines 909,927,936,955,957 and SessionInfoView lines 237,242,255,258 use print(). Should use logger.info/debug/error for consistency and better log filtering. Add logger constant to SessionInfoView.","status":"closed","priority":1,"issue_type":"bug","created_at":"2025-12-09T20:59:16.041707-06:00","updated_at":"2025-12-09T22:32:35.673329-06:00","closed_at":"2025-12-09T22:32:35.673329-06:00","source_repo":".","labels":["code-quality"]}
{"id":"voice-code-priority-queue-zp4","content_hash":"ae856929aee19e2e83b898793c19886f1ecf59c78943bbd4df9451a686f8ca3c","title":"SessionInfoView Priority Queue section doesn't show if not in queue","description":"SessionInfoView line 72: section only shows if 'session.isInPriorityQueue'. User can't add to priority queue from SessionInfoView - must use ConversationView toolbar or auto-add. Consider showing section always when priorityQueueEnabled, with add button if not queued. Would improve feature discoverability.","status":"open","priority":3,"issue_type":"task","created_at":"2025-12-09T21:23:50.874091-06:00","updated_at":"2025-12-09T21:23:50.874091-06:00","source_repo":".","labels":["ux"]}
{"id":"voice-code-priority-queue-zqb","content_hash":"619bca999b21beb4113a06d81a5e7cf175d8aac227aca61e9e80203762e8ea80","title":"Phase 3: Tests - Verify auto-refresh behavior","description":"Verify auto-refresh behavior when priority changed in modal.\n\nFILE TO MODIFY:\n- ios/VoiceCodeTests/PriorityQueueManagementTests.swift\n\nCRITICAL TEST:\ntestAutoRefreshAfterPriorityChange\nPurpose: Verify DirectoryListView queue list updates automatically when priority changed\nApproach:\n1. Create 3 sessions in priority queue (P5, P10, P15)\n2. Fetch initial sorted array\n3. Change P15 session to P5\n4. Simulate DirectoryListView updateCachedPriorityQueueSessions call\n5. Assert queue order changed: [P5-old, P5-new, P10]\n6. Verify NO manual refresh call needed\n7. Verify CoreData change notification triggers update\n\nAdditional Tests:\n- testPriorityChangeTriggersNotification - CoreData posts change notification\n- testMultiplePriorityChanges - Rapid changes handled correctly\n- testPriorityChangeWithLockedSessions - Locked sessions stay filtered\n\nACCEPTANCE CRITERIA:\n‚úÖ Queue list auto-updates when priority changed\n‚úÖ CoreData observation working correctly\n‚úÖ No manual refresh button needed\n‚úÖ All tests pass\n‚úÖ No UI flicker during update","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-07T17:57:11.219587-06:00","updated_at":"2025-12-10T09:49:04.722865-06:00","closed_at":"2025-12-10T09:49:04.722865-06:00","source_repo":".","dependencies":[{"issue_id":"voice-code-priority-queue-zqb","depends_on_id":"voice-code-priority-queue-hpz","type":"blocks","created_at":"2025-12-07T17:59:28.572489-06:00","created_by":"travisbrown"}]}
{"id":"voice-code-priority-queue-zrk","content_hash":"8c16bc09cfa56d6a3a2de546e4d3134057282af9f4a5f46c822bf07dc40b7edc","title":"Phase 6: Performance Testing - Load testing with 100+ sessions","description":"Verify performance with large number of sessions in priority queue.\n\nSPECIFIC PERFORMANCE TARGETS (UPDATED):\n\nBased on design document review:\n- Queue sort 100 sessions: \u003c5ms (NOT \u003c50ms - design had inconsistency)\n- Queue sort 1000 sessions: \u003c50ms\n- Drag operations: 60fps sustained\n- Priority change UI refresh: \u003c100ms (perceived as instant)\n- Memory usage: \u003c50MB increase for 100 sessions\n\nNote: Design document had inconsistency - one section said ~1ms for 100 sessions, another said \u003c50ms. The 5ms target is realistic middle ground.\n\nTEST SCENARIOS:\n\n1. Large Queue Rendering\n   - Add 100 sessions to priority queue\n   - Navigate to Projects view\n   - Measure: Time to render queue section\n   - Target: \u003c 500ms\n   - Verify smooth scrolling (60fps)\n   - Tool: Xcode Instruments (Time Profiler)\n\n2. Sorting Performance (CRITICAL - UPDATED TARGETS)\n   - 100 sessions with random priorities\n   - Trigger updateCachedPriorityQueueSessions\n   - Measure: Sort execution time\n   - Target: \u003c 5ms (updated from design review)\n   - Secondary test: 1000 sessions \u003c 50ms\n   - No UI lag during sort\n   - Tool: os_signpost for precise measurement\n\n3. Drag Performance\n   - 100 sessions in queue\n   - Drag session from top to bottom\n   - Measure: Frame rate during drag\n   - Target: 60fps sustained\n   - No dropped frames\n   - Tool: Xcode FPS meter overlay\n\n4. Priority Change Performance\n   - 100 sessions in queue\n   - Change priority via modal\n   - Measure: Time until UI updates\n   - Target: \u003c 100ms (perceived as instant)\n   - No perceived lag\n   - Tool: Manual observation + Instruments\n\n5. CoreData Query Performance\n   - 100 sessions in priority queue\n   - Fetch with filters and sorting\n   - Measure: Query execution time\n   - Target: \u003c 50ms\n   - Use Core Data instruments\n   - Verify indexes used efficiently\n\n6. Memory Usage\n   - Add 100 sessions\n   - Monitor memory footprint\n   - Target: \u003c 50MB increase\n   - No memory leaks\n   - Tool: Memory Graph Debugger\n\nMEASUREMENT IMPLEMENTATION:\n\nFor Sorting Performance (Scenario 2):\n```swift\nimport os.signpost\n\nlet log = OSLog(subsystem: \"com.voicecode\", category: \"Performance\")\nlet signpostID = OSSignpostID(log: log)\n\nos_signpost(.begin, log: log, name: \"PriorityQueueSort\", signpostID: signpostID)\nupdateCachedPriorityQueueSessions()\nos_signpost(.end, log: log, name: \"PriorityQueueSort\", signpostID: signpostID)\n```\n\nView in Instruments: Points of Interest template\n\nTOOLS:\n- Xcode Instruments (Time Profiler)\n- Core Data Instruments\n- Memory Graph Debugger\n- FPS counter overlay (Debug ‚Üí Show FPS)\n- os_signpost for precise timing\n- Points of Interest instrument\n\nOPTIMIZATION STRATEGIES (if targets not met):\n\nIf sorting is slow:\n- Add fetchBatchSize to NSFetchRequest\n- Implement prefetching for relationships\n- Use lightweight faulting\n- Cache sorted results more aggressively\n- Optimize predicate format\n\nIf memory is high:\n- Review object lifecycle\n- Ensure proper faulting\n- Check for retain cycles\n- Reduce cached data\n\nIf UI is laggy:\n- Move sorting to background queue\n- Implement progressive rendering\n- Reduce SwiftUI view complexity\n\nSTRESS TESTING:\n\nEdge case tests:\n- 1000 sessions (verify \u003c50ms sort)\n- Rapid priority changes (10 changes/second)\n- Continuous dragging (60 seconds)\n- Add/remove 100 sessions rapidly\n- Lock/unlock all sessions repeatedly\n\nPERFORMANCE REPORT FORMAT (NEW):\n\nDocument results in this format:\n\n## Performance Test Results\n\n### Test Environment\n- Device: [iPhone model]\n- iOS Version: [version]\n- Build: [Debug/Release]\n- Date: [test date]\n\n### Scenario 1: Large Queue Rendering\n- **Target:** \u003c 500ms\n- **Actual:** [X ms]\n- **Status:** ‚úÖ Pass / ‚ùå Fail\n- **Tool:** Time Profiler\n- **Notes:** [Any observations]\n- **Screenshot:** [Instruments trace]\n\n### Scenario 2: Sorting Performance (100 sessions)\n- **Target:** \u003c 5ms\n- **Actual:** [X ms]\n- **Status:** ‚úÖ Pass / ‚ùå Fail\n- **Tool:** os_signpost\n- **Screenshot:** [Points of Interest trace]\n\n### Scenario 2b: Sorting Performance (1000 sessions)\n- **Target:** \u003c 50ms\n- **Actual:** [X ms]\n- **Status:** ‚úÖ Pass / ‚ùå Fail\n\n### Scenario 3: Drag Performance\n- **Target:** 60fps sustained\n- **Actual:** [X fps average, Y fps minimum]\n- **Status:** ‚úÖ Pass / ‚ùå Fail\n- **Tool:** FPS overlay\n- **Dropped frames:** [count]\n\n### Scenario 4: Priority Change UI Refresh\n- **Target:** \u003c 100ms\n- **Actual:** [X ms]\n- **Status:** ‚úÖ Pass / ‚ùå Fail\n- **Perception:** Instant / Noticeable lag\n\n### Scenario 5: CoreData Query Performance\n- **Target:** \u003c 50ms\n- **Actual:** [X ms]\n- **Status:** ‚úÖ Pass / ‚ùå Fail\n- **Tool:** Core Data Instruments\n\n### Scenario 6: Memory Usage\n- **Target:** \u003c 50MB increase\n- **Baseline:** [X MB]\n- **After 100 sessions:** [Y MB]\n- **Increase:** [Y-X MB]\n- **Status:** ‚úÖ Pass / ‚ùå Fail\n- **Leaks detected:** Yes / No\n\n### Optimizations Applied\n- [List any optimizations needed to meet targets]\n- [Or \"None - all targets met\"]\n\n### Recommendations\n- [Any suggestions for further optimization]\n- [Or \"Performance acceptable for production\"]\n\nACCEPTANCE CRITERIA:\n‚úÖ All 6 performance targets met with 100 sessions\n‚úÖ Stress test with 1000 sessions passes (\u003c50ms sort)\n‚úÖ Instruments profiling completed for all scenarios\n‚úÖ No memory leaks detected\n‚úÖ 60fps maintained during animations and drags\n‚úÖ Performance report documented with measurements\n‚úÖ Optimization applied if targets not met\n‚úÖ Specific targets verified: 5ms for 100 sessions, 50ms for 1000 sessions\n‚úÖ UI refresh \u003c100ms verified\n‚úÖ Drag 60fps verified\n‚úÖ Report follows template format","status":"open","priority":4,"issue_type":"task","created_at":"2025-12-08T19:37:57.322867-06:00","updated_at":"2025-12-08T22:34:28.208436-06:00","source_repo":".","dependencies":[{"issue_id":"voice-code-priority-queue-zrk","depends_on_id":"voice-code-priority-queue-gby","type":"blocks","created_at":"2025-12-08T19:38:01.817511-06:00","created_by":"travisbrown"}]}
{"id":"voice-code-priority-queue-zss","content_hash":"b5c4fd1784f70d3c49cfa2eccb76401b32acb777d4214913db1c8f993f4d38bd","title":"Add empty state messaging when priority queue is hidden by locks","description":"**Analysis:** Edge case requiring complex logic.\n\n**Scenario:**\n1. User has 3 sessions in priority queue\n2. All 3 are currently processing (locked)\n3. Priority Queue section hidden (priorityQueueSessions.isEmpty after filter)\n4. User confused: 'Where did my queue go?'\n\n**Fix complexity:**\nWould need to track:\n- Total sessions with isInPriorityQueue=true\n- How many are locked vs unlocked\n- Show different UI based on counts\n\n**Implementation:**\n```swift\nlet allPriorityQueueSessions = sessions.filter { $0.isInPriorityQueue }\nlet visibleCount = priorityQueueSessions.count\nlet lockedCount = allPriorityQueueSessions.count - visibleCount\n\nif lockedCount \u003e 0 \u0026\u0026 visibleCount == 0 {\n    Text(\"\\(lockedCount) session(s) currently processing\")\n        .foregroundColor(.secondary)\n}\n```\n\n**Recommendation:** Downgrade to P4. Edge case (all sessions locked simultaneously) is rare. Users can check individual sessions or wait for processing to complete.","status":"open","priority":4,"issue_type":"task","created_at":"2025-12-09T21:04:23.848578-06:00","updated_at":"2025-12-10T09:48:35.6562-06:00","source_repo":".","labels":["ux"]}
{"id":"voice-code-security-au2","content_hash":"cba02aa6b675f167b93ab260196abf1674fd8f7710255eca74c37147ce0e5ce6","title":"API Key Authentication","description":"## Design Document\n@docs/api-key-authentication.md\n\n## Overview\nImplement Pre-Shared Key (PSK) authentication between iOS app and Clojure backend. Users generate a 43-character API key on the backend, scan it via QR code on iOS, and all subsequent WebSocket and HTTP connections are authenticated.\n\n## Acceptance Criteria\n1. Backend generates cryptographically secure 43-char API keys (voice-code- prefix + 32 hex chars)\n2. Backend displays API key as QR code in terminal with Unicode block characters\n3. iOS app scans QR code and stores key securely in Keychain with Share Extension access\n4. WebSocket connections include api_key in connect message; backend validates and marks channel authenticated\n5. Invalid/missing API keys are rejected with generic auth_error message (timing-attack resistant)\n6. Authentication persists for WebSocket session lifetime (no per-message auth)\n7. HTTP endpoints validate Bearer token in Authorization header\n8. Share Extension includes API key in HTTP requests\n9. iOS provides UI for key management (scan, view, delete)\n10. Clear error UX when authentication fails or key is missing","status":"open","priority":1,"issue_type":"epic","created_at":"2026-01-02T14:39:10.514025-06:00","updated_at":"2026-01-02T14:39:10.514025-06:00","source_repo":"."}
{"id":"voice-code-security-au2.10","content_hash":"ba16eeb9620e59e86a5f1b0cd29e94fe2fa4105c30b0d8a167986ccd4ea1c70e","title":"Create KeychainManager for secure API key storage","description":"## Design Reference\n@docs/api-key-authentication.md#35-ios-keychain-storage\n\n## Context\nFoundation iOS task for secure credential storage. KeychainManager provides Keychain access with Share Extension sharing via access group. Must be completed before VoiceCodeClient updates.\n\n## Requirements\n- [ ] Create KeychainManager.swift class\n- [ ] Implement saveAPIKey(_ key: String) throws\n- [ ] Implement retrieveAPIKey() -\u003e String?\n- [ ] Implement deleteAPIKey() throws\n- [ ] Implement hasAPIKey() -\u003e Bool\n- [ ] Implement isValidAPIKeyFormat(_ key: String) -\u003e Bool\n- [ ] Configure kSecAttrAccessGroup for Share Extension sharing\n- [ ] Use kSecAttrAccessibleAfterFirstUnlock for availability\n\n## Technical Approach\n- Files to create: VoiceCode/KeychainManager.swift\n- Service name: \"com.example.voicecode.api-key\"\n- Access group: Configure in entitlements for app + extension\n- Key validation: 43 chars, prefix check, hex validation\n- Error handling: Custom KeychainError enum\n\n## Verification\n- [ ] Unit test: saveAPIKey stores key\n- [ ] Unit test: retrieveAPIKey returns stored key\n- [ ] Unit test: deleteAPIKey removes key\n- [ ] Unit test: hasAPIKey returns correct state\n- [ ] Unit test: isValidAPIKeyFormat validates correctly\n- [ ] Integration test: Share Extension can access stored key\n\n## Parallelization\nCan be worked alongside: Backend auth namespace, ZXing dependency\n\n## Acceptance Criteria\n- AC3: iOS stores key securely in Keychain\n- AC8: Share Extension can access key (via access group)","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-02T14:43:43.925327-06:00","updated_at":"2026-01-02T14:43:43.925327-06:00","source_repo":"."}
{"id":"voice-code-security-au2.11","content_hash":"823ffdbe8fd173f5059c6d060026553f249b783262abf54e44480c3cd386a195","title":"Update VoiceCodeClient to include API key in connect","description":"## Design Reference\n@docs/api-key-authentication.md#35-ios-keychain-storage\n\n## Context\nVoiceCodeClient must send API key in connect message and handle auth responses. This integrates KeychainManager with WebSocket communication.\n\n## Requirements\n- [ ] Add apiKey property to VoiceCodeClient\n- [ ] Load API key from KeychainManager on init\n- [ ] Include api_key field in connect message JSON\n- [ ] Handle auth_error message type\n- [ ] Handle auth_version in hello message\n- [ ] Implement exponential backoff for reconnection\n- [ ] Notify delegate/observers on auth failure\n\n## Technical Approach\n- Files to modify: VoiceCode/VoiceCodeClient.swift\n- Connect message: Add \"api_key\": apiKey to JSON\n- Auth error handling: Parse type: \"auth_error\", notify UI\n- Backoff: 1s initial, 30s max, 2x multiplier, +/-25% jitter\n- Store auth_version from hello for future compatibility\n\n## Verification\n- [ ] Unit test: connect message includes api_key\n- [ ] Unit test: auth_error triggers failure callback\n- [ ] Unit test: hello auth_version is parsed\n- [ ] Unit test: exponential backoff timing correct\n- [ ] Integration test: successful auth flow\n- [ ] Integration test: failed auth flow\n\n## Parallelization\nMust wait for: KeychainManager\n\n## Acceptance Criteria\n- AC4: WebSocket connect includes api_key\n- AC5: Auth errors handled gracefully","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-02T14:44:20.808204-06:00","updated_at":"2026-01-02T14:44:20.808204-06:00","source_repo":".","dependencies":[{"issue_id":"voice-code-security-au2.11","depends_on_id":"voice-code-security-au2.10","type":"blocks","created_at":"2026-01-02T14:44:20.808727-06:00","created_by":"travisbrown"}]}
{"id":"voice-code-security-au2.12","content_hash":"13dfc14b327f8f1ae20ca3d7c2e380528e9ce4a304ae3bf2a545cd2ba9d6d0e5","title":"Implement QRScannerView for API key scanning","description":"## Design Reference\n@docs/api-key-authentication.md#35-ios-keychain-storage\n\n## Context\nQR scanner enables easy API key transfer from terminal to iOS device. Uses AVFoundation for camera access and validates scanned keys before storage.\n\n## Requirements\n- [ ] Create QRScannerView.swift using AVCaptureSession\n- [ ] Request camera permission with appropriate messaging\n- [ ] Detect QR codes containing API key format\n- [ ] Validate scanned key with isValidAPIKeyFormat\n- [ ] Save valid key via KeychainManager\n- [ ] Provide success/failure feedback to user\n- [ ] Handle camera permission denied state\n\n## Technical Approach\n- Files to create: VoiceCode/Views/QRScannerView.swift\n- Use AVCaptureMetadataOutput for QR detection\n- Filter for .qr metadata object type\n- Validate key format before accepting\n- Dismiss on successful scan or user cancel\n- Show alert for invalid QR codes\n\n## Verification\n- [ ] Unit test: valid QR code accepted\n- [ ] Unit test: invalid QR code rejected with message\n- [ ] Manual test: scan QR from terminal\n- [ ] Manual test: camera permission flow\n- [ ] Manual test: permission denied state\n\n## Parallelization\nCan be worked alongside: AuthenticationRequiredView, APIKeySection\n\n## Acceptance Criteria\n- AC3: iOS scans QR code and stores key\n- AC10: Clear feedback on scan success/failure","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-02T14:44:43.745162-06:00","updated_at":"2026-01-02T14:44:43.745162-06:00","source_repo":".","dependencies":[{"issue_id":"voice-code-security-au2.12","depends_on_id":"voice-code-security-au2.10","type":"blocks","created_at":"2026-01-02T14:44:43.745664-06:00","created_by":"travisbrown"}]}
{"id":"voice-code-security-au2.13","content_hash":"a814d5533b2118772006ffc5b1dfcfab081d2a0ad3909e16426a5e8b5d8bd8cc","title":"Create AuthenticationRequiredView for unauthenticated state","description":"## Design Reference\n@docs/api-key-authentication.md#35-ios-keychain-storage\n\n## Context\nShown when app launches without API key or when authentication fails. Provides clear instructions and entry point to QR scanning.\n\n## Requirements\n- [ ] Create AuthenticationRequiredView.swift\n- [ ] Display clear message explaining auth requirement\n- [ ] Show \"Scan QR Code\" button to launch scanner\n- [ ] Show \"Enter Manually\" button for manual entry\n- [ ] Display after auth_error from backend\n- [ ] Integrate with app navigation flow\n\n## Technical Approach\n- Files to create: VoiceCode/Views/AuthenticationRequiredView.swift\n- SwiftUI view with centered content\n- Lock icon or similar visual indicator\n- Instructions text explaining the setup process\n- Two CTAs: Scan QR (primary), Enter Manually (secondary)\n- Navigation to QRScannerView or manual entry\n\n## Verification\n- [ ] Unit test: view renders correctly\n- [ ] Manual test: appears when no API key\n- [ ] Manual test: appears after auth_error\n- [ ] Manual test: navigation to scanner works\n- [ ] Manual test: navigation to manual entry works\n\n## Parallelization\nCan be worked alongside: QRScannerView, APIKeySection\n\n## Acceptance Criteria\n- AC10: Clear error UX when key is missing","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-02T14:44:56.651629-06:00","updated_at":"2026-01-02T14:44:56.651629-06:00","source_repo":".","dependencies":[{"issue_id":"voice-code-security-au2.13","depends_on_id":"voice-code-security-au2.10","type":"blocks","created_at":"2026-01-02T14:44:56.652186-06:00","created_by":"travisbrown"}]}
{"id":"voice-code-security-au2.14","content_hash":"f373d0445e3e76258f84e5561b2f22fcd69eceab5e6d5ed163d8513efe1d918c","title":"Create APIKeySection for Settings view","description":"## Design Reference\n@docs/api-key-authentication.md#35-ios-keychain-storage\n\n## Context\nSettings section showing API key status and providing key management actions. Part of the app's settings/preferences screen.\n\n## Requirements\n- [ ] Create APIKeySection.swift view component\n- [ ] Show connection status (authenticated/not)\n- [ ] Show masked key preview (first/last 4 chars)\n- [ ] Provide \"Update Key\" action\n- [ ] Provide \"Delete Key\" action with confirmation\n- [ ] Integrate into existing Settings view\n\n## Technical Approach\n- Files to create: VoiceCode/Views/APIKeySection.swift\n- Files to modify: Settings view to include section\n- Key masking: \"voic...89ab\" format\n- Delete confirmation: Alert with destructive action\n- Update: Navigate to QRScannerView or manual entry\n\n## Verification\n- [ ] Unit test: masked key format correct\n- [ ] Unit test: status displays correctly\n- [ ] Manual test: delete with confirmation\n- [ ] Manual test: update flow works\n\n## Parallelization\nCan be worked alongside: QRScannerView, AuthenticationRequiredView\n\n## Acceptance Criteria\n- AC9: iOS provides key management UI","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-02T14:45:21.051522-06:00","updated_at":"2026-01-02T14:45:21.051522-06:00","source_repo":".","dependencies":[{"issue_id":"voice-code-security-au2.14","depends_on_id":"voice-code-security-au2.10","type":"blocks","created_at":"2026-01-02T14:45:21.052145-06:00","created_by":"travisbrown"}]}
{"id":"voice-code-security-au2.15","content_hash":"ad6f2963ab9b9aea42258bada8f4f4c0727f85ce25f319c140ea2ff730a76bec","title":"Create APIKeyManagementView for manual key entry","description":"## Design Reference\n@docs/api-key-authentication.md#35-ios-keychain-storage\n\n## Context\nFull-screen view for manual API key entry and management. Provides alternative to QR scanning and detailed key information.\n\n## Requirements\n- [ ] Create APIKeyManagementView.swift\n- [ ] Text field for manual key entry\n- [ ] Real-time key format validation\n- [ ] Save button (enabled only for valid keys)\n- [ ] Current key display (masked)\n- [ ] Delete key option\n- [ ] Link to QR scanner as alternative\n\n## Technical Approach\n- Files to create: VoiceCode/Views/APIKeyManagementView.swift\n- TextField with secure entry option\n- Validate on each character change\n- Show validation status (checkmark/x)\n- Format hint showing expected key format\n- Integrate with KeychainManager\n\n## Verification\n- [ ] Unit test: validation feedback works\n- [ ] Unit test: save only enabled for valid keys\n- [ ] Manual test: manual entry flow\n- [ ] Manual test: navigation to QR scanner\n\n## Parallelization\nMust wait for: KeychainManager, QRScannerView\n\n## Acceptance Criteria\n- AC9: iOS provides key management UI","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-02T14:45:36.252061-06:00","updated_at":"2026-01-02T14:45:36.252061-06:00","source_repo":".","dependencies":[{"issue_id":"voice-code-security-au2.15","depends_on_id":"voice-code-security-au2.10","type":"blocks","created_at":"2026-01-02T14:45:36.252628-06:00","created_by":"travisbrown"},{"issue_id":"voice-code-security-au2.15","depends_on_id":"voice-code-security-au2.12","type":"blocks","created_at":"2026-01-02T14:45:36.252938-06:00","created_by":"travisbrown"}]}
{"id":"voice-code-security-au2.16","content_hash":"90ed78cd8c272866cefd4bc9889b12d049e9b819d95a7c7cba2a4c2f70e9b740","title":"Update Share Extension to include Bearer token","description":"## Design Reference\n@docs/api-key-authentication.md#34-http-bearer-authentication\n\n## Context\nShare Extension makes HTTP requests to upload files. Must include Bearer token and handle 401 responses appropriately.\n\n## Requirements\n- [ ] Access API key from Keychain via shared access group\n- [ ] Add Authorization: Bearer header to HTTP requests\n- [ ] Handle 401 Unauthorized response\n- [ ] Show appropriate error message for auth failure\n- [ ] Handle missing API key state gracefully\n\n## Technical Approach\n- Files to modify: ShareExtension/ShareViewController.swift\n- Use KeychainManager with shared access group\n- Header: request.setValue(\"Bearer \\(apiKey)\", forHTTPHeaderField: \"Authorization\")\n- On 401: Show \"Authentication required\" error\n- On missing key: Show \"Please set up API key in main app\"\n\n## Verification\n- [ ] Unit test: Authorization header included\n- [ ] Unit test: 401 response handled\n- [ ] Integration test: successful upload with auth\n- [ ] Manual test: share from other app with valid key\n- [ ] Manual test: share error when no key configured\n\n## Parallelization\nMust wait for: KeychainManager, HTTP Bearer auth\n\n## Acceptance Criteria\n- AC8: Share Extension includes API key in HTTP requests","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-02T14:45:55.639813-06:00","updated_at":"2026-01-02T14:45:55.639813-06:00","source_repo":".","dependencies":[{"issue_id":"voice-code-security-au2.16","depends_on_id":"voice-code-security-au2.10","type":"blocks","created_at":"2026-01-02T14:45:55.640333-06:00","created_by":"travisbrown"},{"issue_id":"voice-code-security-au2.16","depends_on_id":"voice-code-security-au2.9","type":"blocks","created_at":"2026-01-02T14:45:55.640651-06:00","created_by":"travisbrown"}]}
{"id":"voice-code-security-au2.17","content_hash":"156b5bfd4d7fc61dd9521e8e5e448d28fd1f16b58d6c43258321707c7cc90eeb","title":"Update STANDARDS.md with authentication protocol","description":"## Design Reference\n@docs/api-key-authentication.md#appendix-a\n\n## Context\nDocumentation must reflect the new authentication fields in the WebSocket protocol. STANDARDS.md is the source of truth for protocol specification.\n\n## Requirements\n- [ ] Add api_key field to connect message documentation\n- [ ] Add auth_error message type documentation\n- [ ] Add auth_version field to hello message documentation\n- [ ] Update message examples to show auth fields\n- [ ] Document Authorization header for HTTP endpoints\n\n## Technical Approach\n- Files to modify: STANDARDS.md\n- Add api_key to Client -\u003e Backend connect message\n- Add auth_error to Backend -\u003e Client message types\n- Add auth_version to hello message fields\n- Add HTTP Authorization header section\n\n## Verification\n- [ ] All new fields documented with examples\n- [ ] Examples match actual implementation\n- [ ] Protocol version noted\n\n## Parallelization\nCan be worked alongside: Any implementation task\n\n## Acceptance Criteria\n- Protocol documentation complete and accurate","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-02T14:46:25.786254-06:00","updated_at":"2026-01-02T14:46:25.786254-06:00","source_repo":"."}
{"id":"voice-code-security-au2.18","content_hash":"c000d8bf5da99199a993da0d32b39e66feb4a2394a5092901f1d4d559a738b53","title":"End-to-end integration tests for authentication","description":"## Design Reference\n@docs/api-key-authentication.md#5-testing-strategy\n\n## Context\nFinal validation that all authentication components work together. Tests the complete flow from key generation through authenticated communication.\n\n## Requirements\n- [ ] Test: Generate key -\u003e display QR -\u003e scan -\u003e connect -\u003e authenticated\n- [ ] Test: Invalid key rejected at WebSocket connect\n- [ ] Test: Missing key rejected at WebSocket connect\n- [ ] Test: HTTP upload with valid Bearer token succeeds\n- [ ] Test: HTTP upload with invalid Bearer token returns 401\n- [ ] Test: Reconnection maintains authentication\n\n## Technical Approach\n- Backend integration tests in test/voice_code/integration_test.clj\n- iOS UI tests for full flow (if UI testing configured)\n- May require test fixtures for key generation\n- Use dynamic binding for test key file path\n\n## Verification\n- [ ] All integration tests pass\n- [ ] Tests run in CI pipeline\n- [ ] No flaky tests\n\n## Parallelization\nMust wait for: WebSocket auth, HTTP auth, VoiceCodeClient updates\n\n## Acceptance Criteria\n- All acceptance criteria validated end-to-end","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-02T14:46:55.949845-06:00","updated_at":"2026-01-02T14:46:55.949845-06:00","source_repo":".","dependencies":[{"issue_id":"voice-code-security-au2.18","depends_on_id":"voice-code-security-au2.8","type":"blocks","created_at":"2026-01-02T14:46:55.950486-06:00","created_by":"travisbrown"},{"issue_id":"voice-code-security-au2.18","depends_on_id":"voice-code-security-au2.9","type":"blocks","created_at":"2026-01-02T14:46:55.950857-06:00","created_by":"travisbrown"},{"issue_id":"voice-code-security-au2.18","depends_on_id":"voice-code-security-au2.11","type":"blocks","created_at":"2026-01-02T14:46:55.951141-06:00","created_by":"travisbrown"}]}
{"id":"voice-code-security-au2.4","content_hash":"ff289f698d52145298cff977c04edfb39846aace0fb80abd8a5c6c34226a7f19","title":"Implement auth namespace with key generation and validation","description":"## Design Reference\n@docs/api-key-authentication.md#3-detailed-design\n\n## Context\nFoundation task for API key authentication. The auth namespace provides all cryptographic operations needed by both WebSocket and HTTP authentication. This must be completed before server integration.\n\n## Requirements\n- [ ] Create backend/src/voice_code/auth.clj namespace\n- [ ] Implement generate-key using SecureRandom for 128-bit entropy\n- [ ] Implement valid-key-format? to validate 43-char key structure\n- [ ] Implement constant-time-equals? to prevent timing attacks\n- [ ] Implement save-key! with chmod 600 file permissions\n- [ ] Implement load-key with nil return for missing file\n- [ ] Implement authenticate combining load and compare\n- [ ] Use dynamic var *key-file-path* for test isolation\n\n## Technical Approach\n- Files to create: backend/src/voice_code/auth.clj\n- Key format: 11-char prefix + 32 lowercase hex chars = 43 chars total\n- Key file location: ~/.voice-code/api-key\n- Use java.security.SecureRandom for entropy\n- Use byte-level XOR accumulation for constant-time comparison\n\n## Verification\n- [ ] Unit test: generate-key produces valid 43-char keys\n- [ ] Unit test: valid-key-format? accepts valid, rejects invalid formats\n- [ ] Unit test: constant-time-equals? returns correct results\n- [ ] Unit test: save-key! creates file with 600 permissions\n- [ ] Unit test: load-key returns nil for missing file\n- [ ] Unit test: authenticate validates correctly\n\n## Parallelization\nCan be worked alongside: Add ZXing dependency, Create KeychainManager\n\n## Acceptance Criteria\n- AC1: Backend generates cryptographically secure 43-char API keys\n- AC5: Invalid keys rejected with timing-attack resistant comparison","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-02T14:41:08.344469-06:00","updated_at":"2026-01-02T14:41:08.344469-06:00","source_repo":"."}
{"id":"voice-code-security-au2.5","content_hash":"51a0719993dea0ee9938aab732692ef3e73f9d7051dfc25f30b7b3aeeb83a15d","title":"Add ZXing dependency to deps.edn","description":"## Design Reference\n@docs/api-key-authentication.md#32-qr-code-display\n\n## Context\nZXing library is required for QR code matrix generation. This is a simple dependency addition that unblocks the QR namespace implementation.\n\n## Requirements\n- [ ] Add com.google.zxing/core to deps.edn\n- [ ] Add com.google.zxing/javase to deps.edn\n- [ ] Verify dependency resolves correctly\n\n## Technical Approach\n- Files to modify: backend/deps.edn\n- Dependencies to add:\n  - com.google.zxing/core {:mvn/version \"3.5.2\"}\n  - com.google.zxing/javase {:mvn/version \"3.5.2\"}\n\n## Verification\n- [ ] Run clj -Stree to verify dependencies resolve\n- [ ] REPL can require com.google.zxing.qrcode.QRCodeWriter\n\n## Parallelization\nCan be worked alongside: Implement auth namespace, Create KeychainManager\n\n## Acceptance Criteria\n- AC2: Supports QR code generation (dependency prerequisite)","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-02T14:41:34.511416-06:00","updated_at":"2026-01-02T14:41:34.511416-06:00","source_repo":"."}
{"id":"voice-code-security-au2.6","content_hash":"ecf1f33e3d0378e1406eda6b19a9cba747975db898e6d61671b2119863b25120","title":"Implement QR code namespace for terminal display","description":"## Design Reference\n@docs/api-key-authentication.md#32-qr-code-display\n\n## Context\nQR code display enables easy key transfer from backend to iOS device. Uses ZXing for matrix generation and Unicode block characters for terminal rendering.\n\n## Requirements\n- [ ] Create backend/src/voice_code/qr.clj namespace\n- [ ] Implement generate-qr-matrix using ZXing QRCodeWriter\n- [ ] Implement render-qr-terminal with Unicode block characters\n- [ ] Implement display-setup-qr! with instructions text\n- [ ] Handle error correction level L for QR generation\n\n## Technical Approach\n- Files to create: backend/src/voice_code/qr.clj\n- Dependencies: Requires ZXing (voice-code-security-au2.5)\n- Unicode chars: FULL BLOCK, LOWER HALF, UPPER HALF, SPACE\n- QR size: Let ZXing auto-size based on content\n- Terminal width: Assume 80+ columns\n\n## Verification\n- [ ] Unit test: generate-qr-matrix returns valid matrix\n- [ ] Unit test: render-qr-terminal produces string output\n- [ ] Manual: QR code scannable by iOS camera app\n- [ ] Manual: Instructions clearly visible above QR\n\n## Parallelization\nCan be worked alongside: iOS KeychainManager tasks (after ZXing dep added)\n\n## Acceptance Criteria\n- AC2: Backend displays API key as QR code in terminal","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-02T14:41:59.390916-06:00","updated_at":"2026-01-02T14:41:59.390916-06:00","source_repo":".","dependencies":[{"issue_id":"voice-code-security-au2.6","depends_on_id":"voice-code-security-au2.5","type":"blocks","created_at":"2026-01-02T14:41:59.391429-06:00","created_by":"travisbrown"}]}
{"id":"voice-code-security-au2.7","content_hash":"01859be7e4a1201474cc033627c2cb4dc16beedbfc379066e419840258384f13","title":"Add Makefile targets for key generation and QR display","description":"## Design Reference\n@docs/api-key-authentication.md#36-makefile-targets\n\n## Context\nMakefile targets provide user-friendly commands for key management. These are the primary interface for backend operators to generate and display API keys.\n\n## Requirements\n- [ ] Add generate-key target to backend/Makefile\n- [ ] Add show-qr target to backend/Makefile\n- [ ] Ensure targets work from project root\n\n## Technical Approach\n- Files to modify: backend/Makefile\n- generate-key: clj -X:run :command :generate-key\n- show-qr: clj -X:run :command :show-qr\n- May need to add :run alias to deps.edn\n\n## Verification\n- [ ] make generate-key creates ~/.voice-code/api-key\n- [ ] make show-qr displays scannable QR code\n- [ ] Targets fail gracefully if key missing (show-qr)\n\n## Parallelization\nMust wait for: auth namespace, QR namespace\n\n## Acceptance Criteria\n- AC1: Key generation accessible via make target\n- AC2: QR display accessible via make target","status":"open","priority":2,"issue_type":"task","created_at":"2026-01-02T14:42:42.949807-06:00","updated_at":"2026-01-02T14:42:42.949807-06:00","source_repo":".","dependencies":[{"issue_id":"voice-code-security-au2.7","depends_on_id":"voice-code-security-au2.4","type":"blocks","created_at":"2026-01-02T14:42:42.950373-06:00","created_by":"travisbrown"},{"issue_id":"voice-code-security-au2.7","depends_on_id":"voice-code-security-au2.6","type":"blocks","created_at":"2026-01-02T14:42:42.950682-06:00","created_by":"travisbrown"}]}
{"id":"voice-code-security-au2.8","content_hash":"9f62684bd4f63426395b8c681f3276b2c28cf59e8dc08531b6bb74ec63347a12","title":"Integrate authentication into WebSocket server","description":"## Design Reference\n@docs/api-key-authentication.md#33-session-based-authentication\n\n## Context\nCore server integration that validates API keys on WebSocket connect and tracks authenticated channels. All subsequent messages are allowed only for authenticated channels.\n\n## Requirements\n- [ ] Add authenticated-channels atom to server namespace\n- [ ] Update hello message to include auth_version: 1\n- [ ] Modify connect handler to extract and validate api_key\n- [ ] Implement auth_error message type\n- [ ] Add channel to authenticated set on successful auth\n- [ ] Remove channel from set on disconnect\n- [ ] Block all messages except connect for unauthenticated channels\n\n## Technical Approach\n- Files to modify: backend/src/voice_code/server.clj\n- New atom: (defonce authenticated-channels (atom #{}))\n- Hello message: Add :auth-version 1 to response\n- Connect handler: Extract :api-key, call auth/authenticate\n- Error response: {:type \"auth_error\" :message \"Authentication failed\"}\n- Use generic error message (no detail about why auth failed)\n\n## Verification\n- [ ] Unit test: hello includes auth_version\n- [ ] Unit test: valid api_key authenticates channel\n- [ ] Unit test: invalid api_key returns auth_error\n- [ ] Unit test: missing api_key returns auth_error\n- [ ] Unit test: unauthenticated channel blocked from prompt\n- [ ] Integration test: full connect flow with auth\n\n## Parallelization\nMust wait for: auth namespace\n\n## Acceptance Criteria\n- AC4: WebSocket validates api_key in connect message\n- AC5: Invalid/missing keys rejected with auth_error\n- AC6: Authentication persists for session lifetime","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-02T14:43:01.72142-06:00","updated_at":"2026-01-02T14:43:01.72142-06:00","source_repo":".","dependencies":[{"issue_id":"voice-code-security-au2.8","depends_on_id":"voice-code-security-au2.4","type":"blocks","created_at":"2026-01-02T14:43:01.721997-06:00","created_by":"travisbrown"}]}
{"id":"voice-code-security-au2.9","content_hash":"a566de2f8640a4592fc48720b24b6545bbdca8f01be899880e1ee2f3410fc46c","title":"Add Bearer token authentication to HTTP upload endpoint","description":"## Design Reference\n@docs/api-key-authentication.md#34-http-bearer-authentication\n\n## Context\nHTTP endpoints (file upload) need Bearer token authentication for Share Extension and other HTTP clients. Uses same API key as WebSocket auth.\n\n## Requirements\n- [ ] Extract Authorization header from HTTP requests\n- [ ] Parse Bearer token from header value\n- [ ] Validate token using auth/authenticate\n- [ ] Return 401 Unauthorized for invalid/missing token\n- [ ] Return 401 with generic error message body\n\n## Technical Approach\n- Files to modify: backend/src/voice_code/server.clj (HTTP handler)\n- Header format: Authorization: Bearer \u003capi-key\u003e\n- Parse: (when-let [auth (get-in request [:headers \"authorization\"])]\n           (second (re-matches #\"Bearer (.+)\" auth)))\n- Response: {:status 401 :body \"Unauthorized\"}\n\n## Verification\n- [ ] Unit test: valid Bearer token allows request\n- [ ] Unit test: invalid Bearer token returns 401\n- [ ] Unit test: missing Authorization header returns 401\n- [ ] Unit test: malformed Authorization header returns 401\n- [ ] Integration test: file upload with Bearer token\n\n## Parallelization\nCan be worked alongside: WebSocket auth integration\n\n## Acceptance Criteria\n- AC7: HTTP endpoints validate Bearer token","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-02T14:43:12.88886-06:00","updated_at":"2026-01-02T14:43:12.88886-06:00","source_repo":".","dependencies":[{"issue_id":"voice-code-security-au2.9","depends_on_id":"voice-code-security-au2.4","type":"blocks","created_at":"2026-01-02T14:43:12.889424-06:00","created_by":"travisbrown"}]}
