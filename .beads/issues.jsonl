{"id":"connectivity-01t","title":"Review: Robust reconnection logic (exponential backoff)","notes":"Reference: docs/websocket-best-practices.md item 1\nTask: Review current implementation against this practice\nOutput: Update docs/websocket-recommendations.md with findings","status":"closed","priority":3,"issue_type":"task","created_at":"2026-01-11T13:56:40.495709-06:00","created_by":"travisbrown","updated_at":"2026-01-11T14:36:03.445615-06:00","closed_at":"2026-01-11T14:36:03.445615-06:00","close_reason":"Reviewed reconnection logic implementation - fully implemented with exponential backoff, jitter, max delay cap, backoff reset, and comprehensive tests"}
{"id":"connectivity-0sf","title":"Review: Connection quality monitoring (RTT)","notes":"Reference: docs/websocket-best-practices.md item 14\nTask: Review current implementation against this practice\nOutput: Update docs/websocket-recommendations.md with findings","status":"closed","priority":3,"issue_type":"task","created_at":"2026-01-11T13:56:47.936595-06:00","created_by":"travisbrown","updated_at":"2026-01-11T15:44:41.693337-06:00","closed_at":"2026-01-11T15:44:41.693337-06:00","close_reason":"Closed"}
{"id":"connectivity-1qq","title":"WebSocket Connectivity Resilience","description":"## Design Document\n@docs/design-connectivity-resilience.md\n\n## Overview\nImplement high-priority WebSocket connectivity improvements for the iOS client and backend, addressing network awareness, connection lifecycle, and half-open connection detection.\n\n## Features\n1. **Network Reachability Monitoring** - NWPathMonitor integration for network-aware reconnection\n2. **WiFi/Cellular Handoff** - Proactive reconnection on interface transitions  \n3. **Server Heartbeat** - 45s server heartbeats with 90s timeout for zombie connection detection\n4. **Background Lifecycle** - Clean disconnect with beginBackgroundTask and 25s cleanup window\n\n## Acceptance Criteria\n\n### Network Reachability\n- [ ] NWPathMonitor starts on client initialization\n- [ ] Reconnection timer pauses when network becomes unavailable\n- [ ] Immediate reconnection attempt when network becomes available\n- [ ] Backoff resets to 0 when network becomes available\n- [ ] networkStatus published property updates on changes\n\n### WiFi/Cellular Handoff\n- [ ] Interface change from WiFi to Cellular triggers proactive reconnection\n- [ ] Interface change from Cellular to WiFi triggers proactive reconnection\n- [ ] Connection is closed cleanly before reconnection\n- [ ] No reconnection if interface type doesn't change\n\n### Server Heartbeat\n- [ ] Backend sends heartbeat every 45 seconds to all connected clients\n- [ ] iOS client tracks last heartbeat received time\n- [ ] Heartbeat timeout (90s) triggers zombie connection handling\n- [ ] Zombie connection triggers disconnect and reconnection\n- [ ] Heartbeat monitoring starts after authentication\n- [ ] Heartbeat monitoring stops on disconnect\n\n### Background Lifecycle\n- [ ] App entering background requests beginBackgroundTask\n- [ ] In-flight operations are given time to complete (up to 25s)\n- [ ] WebSocket disconnects cleanly before suspension\n- [ ] Background task ends properly (no leaks)\n- [ ] App returning to foreground triggers reconnection (if network available)\n\n### Backward Compatibility\n- [ ] Existing ping/pong mechanism continues to work\n- [ ] Clients without heartbeat support don't crash on heartbeat message\n- [ ] Protocol version doesn't change","status":"open","priority":1,"issue_type":"epic","created_at":"2026-01-11T18:41:02.76879-06:00","created_by":"travisbrown","updated_at":"2026-01-11T18:41:02.76879-06:00"}
{"id":"connectivity-1qq.1","title":"Test infrastructure: MockNWPath and test helpers","description":"## Design Reference\n@docs/design-connectivity-resilience.md - Section: Verification Strategy \u003e Test Infrastructure Required\n\n## Context\nThe iOS `NWPath` class is final and cannot be subclassed or directly mocked. To enable unit testing of network monitoring logic, we need a protocol-based abstraction that allows injecting mock network paths in tests.\n\n## Requirements\n1. Create `NetworkPathProtocol` that captures the interface of `NWPath` needed by our code\n2. Extend `NWPath` to conform to `NetworkPathProtocol`\n3. Create `MockNWPath` test double for unit tests\n4. Add `#if DEBUG` test accessors to `VoiceCodeClient` for internal state inspection\n\n## Technical Approach\n\n### NetworkPathProtocol\n```swift\nprotocol NetworkPathProtocol {\n    var status: NWPath.Status { get }\n    var isConstrained: Bool { get }\n    func usesInterfaceType(_ type: NWInterface.InterfaceType) -\u003e Bool\n}\n\nextension NWPath: NetworkPathProtocol {}\n```\n\n### MockNWPath\n```swift\nclass MockNWPath: NetworkPathProtocol {\n    var status: NWPath.Status\n    var isConstrained: Bool\n    private var usesWiFi: Bool\n    private var usesCellular: Bool\n    \n    init(status: NWPath.Status = .satisfied, isConstrained: Bool = false,\n         usesWiFi: Bool = false, usesCellular: Bool = false) { ... }\n    \n    func usesInterfaceType(_ type: NWInterface.InterfaceType) -\u003e Bool { ... }\n}\n```\n\n### Test Accessors (#if DEBUG)\nAdd to `VoiceCodeClient.swift`:\n- `testableReconnectionTimer`, `testableReconnectionAttempts`, `testableLastHeartbeatReceived`\n- `testableSetNetworkAvailable(_:)`, `testableSetConnected(_:)`, etc.\n- `testableMapPathToStatus(_:)`, `testableDidInterfaceChange(from:to:)`\n\n## Verification\n- [ ] `MockNWPath` compiles and conforms to `NetworkPathProtocol`\n- [ ] Test helpers are only compiled in DEBUG builds\n- [ ] Existing tests continue to pass\n- [ ] New test file `VoiceCodeClientNetworkTests.swift` created with basic structure\n\n## Acceptance Criteria\n- [ ] `NetworkPathProtocol` defined with status, isConstrained, usesInterfaceType\n- [ ] `NWPath` extended to conform to protocol\n- [ ] `MockNWPath` allows configuring status, isConstrained, usesWiFi, usesCellular\n- [ ] Test accessors available under `#if DEBUG` in VoiceCodeClient\n- [ ] Protocol-based test methods for mapPathToStatus and didInterfaceChange","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-11T18:42:53.85517-06:00","created_by":"travisbrown","updated_at":"2026-01-11T18:42:53.85517-06:00","dependencies":[{"issue_id":"connectivity-1qq.1","depends_on_id":"connectivity-1qq","type":"parent-child","created_at":"2026-01-11T18:42:53.855996-06:00","created_by":"travisbrown"}]}
{"id":"connectivity-1qq.2","title":"Network Reachability Monitoring (Phase 1A)","description":"## Design Reference\n@docs/design-connectivity-resilience.md - Section: Feature 1: Network Reachability Monitoring\n\n## Context\nCurrent reconnection logic fires regardless of network availability, wasting battery and CPU. iOS provides `NWPathMonitor` to observe network status changes in real-time.\n\n## Requirements\n1. Add `NWPathMonitor` integration to `VoiceCodeClient`\n2. Track network availability state\n3. Pause reconnection attempts when network unavailable\n4. Trigger immediate reconnection (with backoff reset) when network becomes available\n5. Publish `networkStatus` for UI consumption\n\n## Technical Approach\n\n### New Properties (in VoiceCodeClient class)\n```swift\nprivate var pathMonitor: NWPathMonitor?\nprivate var currentNetworkPath: NWPath?\nprivate var isNetworkAvailable: Bool = true\n@Published var networkStatus: NetworkStatus = .unknown\n```\n\n### Key Methods\n- `startNetworkMonitoring()` - Initialize and start NWPathMonitor\n- `stopNetworkMonitoring()` - Cancel monitor on disconnect\n- `handleNetworkPathUpdate(_:)` - Process path changes\n- `mapPathToStatus(_:)` - Convert NWPath to NetworkStatus enum\n- `handleNetworkBecameAvailable()` - Reset backoff, immediate connect\n- `handleNetworkBecameUnavailable()` - Cancel reconnection timer\n\n### Integration Points\n1. Call `startNetworkMonitoring()` in `init()` when `setupObservers: true`\n2. Modify `setupReconnection()` to check `isNetworkAvailable` before scheduling\n3. Call `stopNetworkMonitoring()` in `disconnect()`\n\n## Verification\n- [ ] Unit tests for `mapPathToStatus()` all status cases\n- [ ] Unit tests for reconnection skipping when network unavailable\n- [ ] Unit tests for backoff reset when network becomes available\n- [ ] Manual test: airplane mode on/off shows correct behavior\n\n## Acceptance Criteria\n- [ ] NWPathMonitor starts on client initialization\n- [ ] Reconnection timer pauses when network becomes unavailable\n- [ ] Immediate reconnection attempt when network becomes available\n- [ ] Backoff resets to 0 when network becomes available\n- [ ] networkStatus published property updates on changes","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-11T18:43:15.036404-06:00","created_by":"travisbrown","updated_at":"2026-01-11T18:43:15.036404-06:00","dependencies":[{"issue_id":"connectivity-1qq.2","depends_on_id":"connectivity-1qq","type":"parent-child","created_at":"2026-01-11T18:43:15.037182-06:00","created_by":"travisbrown"},{"issue_id":"connectivity-1qq.2","depends_on_id":"connectivity-1qq.1","type":"blocks","created_at":"2026-01-11T18:45:01.135508-06:00","created_by":"travisbrown"}]}
{"id":"connectivity-1qq.3","title":"WiFi/Cellular Handoff Detection (Phase 1B)","description":"## Design Reference\n@docs/design-connectivity-resilience.md - Section: Feature 2: WiFi to Cellular Handoff\n\n## Context\nWhen iOS switches between WiFi and Cellular networks, the existing TCP connection may become unusable but not immediately fail. Proactive reconnection on interface change prevents user-visible delays.\n\n## Requirements\n1. Detect WiFi ↔ Cellular interface transitions using NWPath\n2. Trigger proactive reconnection (disconnect + immediate reconnect) on interface change\n3. Log interface transitions for debugging\n4. Avoid reconnection if interface type doesn't actually change\n\n## Technical Approach\n\n### Key Methods\n```swift\nfunc didInterfaceChange(from oldPath: NWPath?, to newPath: NWPath) -\u003e Bool {\n    guard let oldPath = oldPath else { return false }\n    let oldUsesWiFi = oldPath.usesInterfaceType(.wifi)\n    let newUsesWiFi = newPath.usesInterfaceType(.wifi)\n    let oldUsesCellular = oldPath.usesInterfaceType(.cellular)\n    let newUsesCellular = newPath.usesInterfaceType(.cellular)\n    return (oldUsesWiFi != newUsesWiFi) || (oldUsesCellular != newUsesCellular)\n}\n\nfunc handleNetworkInterfaceChange(from oldPath: NWPath?, to newPath: NWPath) {\n    logger.info(\"Network interface changed: \\(fromInterface) → \\(toInterface)\")\n    if isConnected {\n        disconnect()\n        reconnectionAttempts = 0\n        connect(sessionId: sessionId)\n    }\n}\n\nfunc describeInterface(_ path: NWPath?) -\u003e String // For logging\n```\n\n### Integration\nCall `handleNetworkInterfaceChange()` from `handleNetworkPathUpdate()` when:\n- Network is still available AND\n- Interface type has changed (WiFi ↔ Cellular)\n\n## Verification\n- [ ] Unit tests for `didInterfaceChange()` - WiFi→Cellular returns true\n- [ ] Unit tests for `didInterfaceChange()` - same interface returns false\n- [ ] Unit tests for `didInterfaceChange()` - nil oldPath returns false\n- [ ] Manual test: switch from WiFi to cellular while connected\n\n## Acceptance Criteria\n- [ ] Interface change from WiFi to Cellular triggers proactive reconnection\n- [ ] Interface change from Cellular to WiFi triggers proactive reconnection\n- [ ] Connection is closed cleanly before reconnection\n- [ ] No reconnection if interface type doesn't change","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-11T18:43:35.341456-06:00","created_by":"travisbrown","updated_at":"2026-01-11T18:43:35.341456-06:00","dependencies":[{"issue_id":"connectivity-1qq.3","depends_on_id":"connectivity-1qq","type":"parent-child","created_at":"2026-01-11T18:43:35.34233-06:00","created_by":"travisbrown"},{"issue_id":"connectivity-1qq.3","depends_on_id":"connectivity-1qq.1","type":"blocks","created_at":"2026-01-11T18:45:06.329692-06:00","created_by":"travisbrown"},{"issue_id":"connectivity-1qq.3","depends_on_id":"connectivity-1qq.2","type":"blocks","created_at":"2026-01-11T18:45:25.689263-06:00","created_by":"travisbrown"}]}
{"id":"connectivity-1qq.4","title":"Background Lifecycle Management (Phase 1C)","description":"## Design Reference\n@docs/design-connectivity-resilience.md - Section: Feature 4: App Lifecycle - Clean Disconnect\n\n## Context\nCurrent implementation leaves WebSocket open when app backgrounds. iOS may suspend the app mid-operation, leaving the connection in an undefined state. Using `beginBackgroundTask` gives up to 30 seconds to complete cleanup.\n\n## Requirements\n1. Request background execution time when app enters background\n2. Wait for in-flight operations (locked sessions, running commands) with timeout\n3. Disconnect WebSocket cleanly before iOS suspension\n4. End background task properly (no leaks)\n5. Update foreground handler to check network availability\n\n## Technical Approach\n\n### New Property (in VoiceCodeClient class)\n```swift\n#if os(iOS)\nprivate var backgroundTaskID: UIBackgroundTaskIdentifier = .invalid\n#endif\n```\n\n### Key Methods\n```swift\nfunc handleAppEnteredBackground() {\n    backgroundTaskID = UIApplication.shared.beginBackgroundTask(\n        withName: \"VoiceCodeCleanup\"\n    ) { [weak self] in\n        self?.completeBackgroundTask()\n    }\n    performBackgroundCleanup()\n}\n\nfunc performBackgroundCleanup() // Check for in-flight ops\nfunc waitForInFlightOperations(completion:) // 25s timeout poll\nfunc finalizeBackgroundCleanup() // Disconnect + end task\nfunc completeBackgroundTask() // End UIBackgroundTaskIdentifier\n```\n\n### Integration\n1. Replace empty `handleAppEnteredBackground()` implementation\n2. Update `handleAppBecameActive()` to check `isNetworkAvailable`\n\n## Verification\n- [ ] Unit test: background entry triggers disconnect\n- [ ] Unit test: foreground with network unavailable doesn't reconnect\n- [ ] Manual test: background app, check server logs for clean disconnect\n- [ ] Manual test: verify background task completes (no crash)\n\n## Acceptance Criteria\n- [ ] App entering background requests beginBackgroundTask\n- [ ] In-flight operations are given time to complete (up to 25s)\n- [ ] WebSocket disconnects cleanly before suspension\n- [ ] Background task ends properly (no leaks)\n- [ ] App returning to foreground triggers reconnection (if network available)","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-11T18:43:57.900561-06:00","created_by":"travisbrown","updated_at":"2026-01-11T18:43:57.900561-06:00","dependencies":[{"issue_id":"connectivity-1qq.4","depends_on_id":"connectivity-1qq","type":"parent-child","created_at":"2026-01-11T18:43:57.90142-06:00","created_by":"travisbrown"},{"issue_id":"connectivity-1qq.4","depends_on_id":"connectivity-1qq.1","type":"blocks","created_at":"2026-01-11T18:45:11.422478-06:00","created_by":"travisbrown"},{"issue_id":"connectivity-1qq.4","depends_on_id":"connectivity-1qq.2","type":"blocks","created_at":"2026-01-11T18:45:30.894727-06:00","created_by":"travisbrown"}]}
{"id":"connectivity-1qq.5","title":"Backend Heartbeat Scheduler (Phase 2A)","description":"## Design Reference\n@docs/design-connectivity-resilience.md - Section: Feature 3: Server Heartbeat for Half-Open Detection \u003e Backend Implementation\n\n## Context\nClient-initiated pings cannot detect half-open connections where the client→server path is broken. Server-initiated heartbeats allow clients to detect when they haven't heard from the server in too long.\n\n## Requirements\n1. Send heartbeat message to all connected clients every 45 seconds\n2. Heartbeat includes timestamp for debugging\n3. Gracefully handle send failures (remove stale channels)\n4. Scheduler starts on server startup, stops on shutdown\n5. Backward compatible - clients ignoring heartbeat should not break\n\n## Technical Approach\n\n### Protocol Extension\nNew message type (Backend → Client):\n```json\n{\n  \"type\": \"heartbeat\",\n  \"timestamp\": \"\u003cISO-8601-timestamp\u003e\"\n}\n```\n\n### Implementation\n```clojure\n(def heartbeat-interval-ms 45000)\n(defonce heartbeat-executor (atom nil))\n\n(defn send-heartbeat! [channel]\n  (when (contains? @connected-clients channel)\n    (try\n      (http/send! channel\n                  (generate-json {:type :heartbeat\n                                  :timestamp (java.time.Instant/now)}))\n      (catch Exception e\n        (log/warn e \"Failed to send heartbeat, removing stale channel\")\n        (unregister-channel! channel)))))\n\n(defn broadcast-heartbeat! []\n  (doseq [channel (keys @connected-clients)]\n    (send-heartbeat! channel)))\n\n(defn start-heartbeat-scheduler! []\n  (let [executor (Executors/newSingleThreadScheduledExecutor)\n        heartbeat-task (reify Runnable (run [_] (broadcast-heartbeat!)))]\n    (.scheduleAtFixedRate executor heartbeat-task\n                          heartbeat-interval-ms heartbeat-interval-ms\n                          TimeUnit/MILLISECONDS)))\n\n(defn stop-heartbeat-scheduler! [] ...)\n```\n\n### Integration\n1. Call `start-heartbeat-scheduler!` in `-main`\n2. Add shutdown hook to call `stop-heartbeat-scheduler!`\n3. Update @STANDARDS.md with new message type\n\n## Verification\n- [ ] Unit test: send-heartbeat! sends to connected client\n- [ ] Unit test: send-heartbeat! removes channel on failure\n- [ ] Unit test: broadcast-heartbeat! sends to all clients\n- [ ] Integration test: verify heartbeat messages in WebSocket log\n\n## Acceptance Criteria\n- [ ] Backend sends heartbeat every 45 seconds to all connected clients\n- [ ] Heartbeat message includes type and timestamp\n- [ ] Failed sends remove stale channels\n- [ ] Scheduler starts on backend startup\n- [ ] Scheduler stops cleanly on shutdown","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-11T18:44:21.066306-06:00","created_by":"travisbrown","updated_at":"2026-01-11T18:44:21.066306-06:00","dependencies":[{"issue_id":"connectivity-1qq.5","depends_on_id":"connectivity-1qq","type":"parent-child","created_at":"2026-01-11T18:44:21.067154-06:00","created_by":"travisbrown"}]}
{"id":"connectivity-1qq.6","title":"iOS Heartbeat Monitoring (Phase 2B)","description":"## Design Reference\n@docs/design-connectivity-resilience.md - Section: Feature 3: Server Heartbeat for Half-Open Detection \u003e iOS Client Implementation\n\n## Context\nAfter backend deploys heartbeat messages (Phase 2A), iOS client needs to monitor for expected heartbeats and detect \"zombie\" connections where the server→client path is broken.\n\n## Requirements\n1. Track last heartbeat received timestamp\n2. Timeout if no heartbeat received within 90 seconds (2x 45s interval)\n3. On timeout, treat as zombie connection and force reconnection\n4. Start monitoring after authentication completes\n5. Stop monitoring on disconnect\n\n## Technical Approach\n\n### New Properties (in VoiceCodeClient class)\n```swift\nprivate var lastHeartbeatReceived: Date?\nprivate var heartbeatTimeoutTimer: DispatchSourceTimer?\nprivate static let expectedHeartbeatInterval: TimeInterval = 45.0\nprivate static let heartbeatTimeout: TimeInterval = 90.0\n```\n\n### Key Methods\n```swift\nfunc startHeartbeatMonitoring() // Create 90s timeout timer\nfunc stopHeartbeatMonitoring() // Cancel timer\nfunc checkHeartbeatTimeout() // Called by timer, checks lastHeartbeat\nfunc handleZombieConnection() // Disconnect + reconnect\nfunc handleHeartbeat(_ json: [String: Any]) // Update lastHeartbeatReceived\n```\n\n### Integration\n1. Add `case \"heartbeat\"` to `handleMessage()` switch\n2. Call `startHeartbeatMonitoring()` after receiving \"connected\" message\n3. Call `stopHeartbeatMonitoring()` in `disconnect()`\n\n### Graceful Degradation\nIf `lastHeartbeatReceived` is nil (server doesn't support heartbeat yet), timeout check does nothing. This allows iOS update to deploy before backend.\n\n## Verification\n- [ ] Unit test: heartbeat message updates lastHeartbeatReceived\n- [ ] Unit test: timeout check with old heartbeat triggers reconnection\n- [ ] Unit test: timeout check with nil heartbeat (server not supporting) does nothing\n- [ ] Integration test: connect to heartbeat-enabled server, verify no timeout\n\n## Acceptance Criteria\n- [ ] iOS client tracks last heartbeat received time\n- [ ] Heartbeat timeout (90s) triggers zombie connection handling\n- [ ] Zombie connection triggers disconnect and reconnection\n- [ ] Heartbeat monitoring starts after authentication\n- [ ] Heartbeat monitoring stops on disconnect\n- [ ] Clients without backend heartbeat support don't crash or misbehave","status":"open","priority":1,"issue_type":"task","created_at":"2026-01-11T18:44:44.685344-06:00","created_by":"travisbrown","updated_at":"2026-01-11T18:44:44.685344-06:00","dependencies":[{"issue_id":"connectivity-1qq.6","depends_on_id":"connectivity-1qq","type":"parent-child","created_at":"2026-01-11T18:44:44.686121-06:00","created_by":"travisbrown"},{"issue_id":"connectivity-1qq.6","depends_on_id":"connectivity-1qq.1","type":"blocks","created_at":"2026-01-11T18:45:16.531954-06:00","created_by":"travisbrown"},{"issue_id":"connectivity-1qq.6","depends_on_id":"connectivity-1qq.5","type":"blocks","created_at":"2026-01-11T18:45:39.939092-06:00","created_by":"travisbrown"}]}
{"id":"connectivity-28u","title":"Review: Message ordering handling","notes":"Reference: docs/websocket-best-practices.md item 5\nTask: Review current implementation against this practice\nOutput: Update docs/websocket-recommendations.md with findings","status":"closed","priority":3,"issue_type":"task","created_at":"2026-01-11T13:56:43.527603-06:00","created_by":"travisbrown","updated_at":"2026-01-11T14:46:53.965571-06:00","closed_at":"2026-01-11T14:46:53.965571-06:00","close_reason":"Reviewed message ordering handling - implementation complete with timestamp-based ordering"}
{"id":"connectivity-3b8","title":"Review: Half-open connection handling","notes":"Reference: docs/websocket-best-practices.md item 24. Task: Review current implementation against this practice. Output: Update docs/websocket-recommendations.md with findings.","status":"closed","priority":3,"issue_type":"task","created_at":"2026-01-11T13:56:47.607123-06:00","created_by":"travisbrown","updated_at":"2026-01-11T15:35:55.04653-06:00","closed_at":"2026-01-11T15:35:55.04653-06:00","close_reason":"Closed"}
{"id":"connectivity-3kr","title":"Review: Connection affinity with fallback","notes":"Reference: docs/websocket-best-practices.md item 33\nTask: Review current implementation against this practice\nOutput: Update docs/websocket-recommendations.md with findings","status":"closed","priority":3,"issue_type":"task","created_at":"2026-01-11T13:56:46.901991-06:00","created_by":"travisbrown","updated_at":"2026-01-11T15:28:54.294347-06:00","closed_at":"2026-01-11T15:28:54.294347-06:00","close_reason":"Reviewed item 33 (connection affinity with fallback). Not applicable to single-server architecture. Findings documented in websocket-recommendations.md."}
{"id":"connectivity-49c","title":"Review: Optimistic UI with rollback","notes":"Reference: docs/websocket-best-practices.md item 22. Task: Review current implementation against this practice. Output: Update docs/websocket-recommendations.md with findings.","status":"closed","priority":3,"issue_type":"task","created_at":"2026-01-11T13:56:46.166417-06:00","created_by":"travisbrown","updated_at":"2026-01-11T15:18:09.028031-06:00","closed_at":"2026-01-11T15:18:09.028031-06:00","close_reason":"Reviewed item 22 (Optimistic UI with rollback). Status: Partial. Optimistic UI is implemented with immediate CoreData message creation and server reconciliation, but rollback on error is missing - error handler unlocks session but doesn't update message status to .error. Added 4 gaps and 5 recommendations to docs/websocket-recommendations.md."}
{"id":"connectivity-4zp","title":"Review: Background URLSession for uploads","notes":"Reference: docs/websocket-best-practices.md item 26. Task: Review current implementation against this practice. Output: Update docs/websocket-recommendations.md with findings.","status":"closed","priority":3,"issue_type":"task","created_at":"2026-01-11T13:56:49.597685-06:00","created_by":"travisbrown","updated_at":"2026-01-11T16:10:46.383461-06:00","closed_at":"2026-01-11T16:10:46.383461-06:00","close_reason":"Closed"}
{"id":"connectivity-54w","title":"Review: Heartbeats/ping-pong implementation","notes":"Reference: docs/websocket-best-practices.md item 3\nTask: Review current implementation against this practice\nOutput: Update docs/websocket-recommendations.md with findings","status":"closed","priority":3,"issue_type":"task","created_at":"2026-01-11T13:56:42.055554-06:00","created_by":"travisbrown","updated_at":"2026-01-11T14:40:42.815787-06:00","closed_at":"2026-01-11T14:40:42.815787-06:00","close_reason":"Reviewed heartbeats/ping-pong implementation - fully implemented with 30s interval, proper timer lifecycle, conditional sending"}
{"id":"connectivity-7oa","title":"Review: App lifecycle handling (background/foreground)","notes":"Reference: docs/websocket-best-practices.md item 9\nTask: Review current implementation against this practice\nOutput: Update docs/websocket-recommendations.md with findings","status":"closed","priority":3,"issue_type":"task","created_at":"2026-01-11T13:56:46.97788-06:00","created_by":"travisbrown","updated_at":"2026-01-11T15:32:00.595713-06:00","closed_at":"2026-01-11T15:32:00.595713-06:00","close_reason":"Reviewed app lifecycle handling (item 9). Status: Partial - foreground reconnection works, but no clean disconnect on background and no background task for critical operations. Added 4 gaps and 4 recommendations to docs/websocket-recommendations.md"}
{"id":"connectivity-86e","title":"Review: Message size limits (256KB iOS)","notes":"Reference: docs/websocket-best-practices.md item 8\nTask: Review current implementation against this practice\nOutput: Update docs/websocket-recommendations.md with findings","status":"closed","priority":3,"issue_type":"task","created_at":"2026-01-11T13:56:46.014029-06:00","created_by":"travisbrown","updated_at":"2026-01-11T15:16:09.461332-06:00","closed_at":"2026-01-11T15:16:09.461332-06:00","close_reason":"Closed"}
{"id":"connectivity-8tq","title":"Review: Adaptive payload sizing","notes":"Reference: docs/websocket-best-practices.md item 19\nTask: Review current implementation against this practice\nOutput: Update docs/websocket-recommendations.md with findings","status":"closed","priority":3,"issue_type":"task","created_at":"2026-01-11T13:56:52.040355-06:00","created_by":"travisbrown","updated_at":"2026-01-11T16:37:58.478759-06:00","closed_at":"2026-01-11T16:37:58.478759-06:00","close_reason":"Closed"}
{"id":"connectivity-938","title":"Review: Slow vs dead connection detection","notes":"Reference: docs/websocket-best-practices.md item 16\nTask: Review current implementation against this practice\nOutput: Update docs/websocket-recommendations.md with findings","status":"closed","priority":3,"issue_type":"task","created_at":"2026-01-11T13:56:49.513207-06:00","created_by":"travisbrown","updated_at":"2026-01-11T16:00:40.808104-06:00","closed_at":"2026-01-11T16:00:40.808104-06:00","close_reason":"Reviewed item 16 (Slow vs dead connection detection). Status: Not Implemented. Found 6 gaps including no RTT tracking, no connection quality state machine, no progressive timeout escalation, and same reconnection strategy for all failures. Added 5 recommendations including connection quality state machine, progressive timeout escalation, adaptive behavior, UI indicator, and differentiated reconnection strategies."}
{"id":"connectivity-9ou","title":"Review: Path migration awareness","notes":"Reference: docs/websocket-best-practices.md item 30. Task: Review current implementation against this practice. Output: Update docs/websocket-recommendations.md with findings.","status":"closed","priority":3,"issue_type":"task","created_at":"2026-01-11T13:56:54.178129-06:00","created_by":"travisbrown","updated_at":"2026-01-11T16:58:29.533203-06:00","closed_at":"2026-01-11T16:58:29.533203-06:00","close_reason":"Review completed. Item 30 (Path migration awareness) added to websocket-recommendations.md. Status: Not Implemented. This requires RTT tracking (item 14) and interface change detection (item 29) as prerequisites. Added 4 gaps and 4 recommendations. Updated summary table from 2/3 to 3/3 for Network Transition Handling."}
{"id":"connectivity-a8m","title":"Review: Application-level timeouts","notes":"Reference: docs/websocket-best-practices.md item 15\nTask: Review current implementation against this practice\nOutput: Update docs/websocket-recommendations.md with findings","status":"closed","priority":3,"issue_type":"task","created_at":"2026-01-11T13:56:48.698808-06:00","created_by":"travisbrown","updated_at":"2026-01-11T15:56:10.72588-06:00","closed_at":"2026-01-11T15:56:10.72588-06:00","close_reason":"Documented item 15 (Application-level timeouts) findings in docs/websocket-recommendations.md"}
{"id":"connectivity-b80","title":"Review: Early authentication in connection lifecycle","notes":"Reference: docs/websocket-best-practices.md item 6\nTask: Review current implementation against this practice\nOutput: Update docs/websocket-recommendations.md with findings","status":"closed","priority":3,"issue_type":"task","created_at":"2026-01-11T13:56:44.277336-06:00","created_by":"travisbrown","updated_at":"2026-01-11T14:50:27.736488-06:00","closed_at":"2026-01-11T14:50:27.736488-06:00","close_reason":"Closed"}
{"id":"connectivity-bbl","title":"Review: Clear error responses","notes":"Reference: docs/websocket-best-practices.md item 13\nTask: Review current implementation against this practice\nOutput: Update docs/websocket-recommendations.md with findings","status":"closed","priority":3,"issue_type":"task","created_at":"2026-01-11T13:56:46.597938-06:00","created_by":"travisbrown","updated_at":"2026-01-11T15:21:30.597456-06:00","closed_at":"2026-01-11T15:21:30.597456-06:00","close_reason":"Item 13 (Clear error responses): Status=Implemented, 0 gaps. Auth errors distinguished from protocol errors, domain-specific error types with context, actionable messages, defined recovery paths."}
{"id":"connectivity-dmj","title":"Review: Captive portal handling","notes":"Reference: docs/websocket-best-practices.md item 31\nTask: Review current implementation against this practice\nOutput: Update docs/websocket-recommendations.md with findings","status":"closed","priority":3,"issue_type":"task","created_at":"2026-01-11T13:56:45.334463-06:00","created_by":"travisbrown","updated_at":"2026-01-11T14:59:27.52255-06:00","closed_at":"2026-01-11T14:59:27.52255-06:00","close_reason":"Closed"}
{"id":"connectivity-e82","title":"Review: Connection lifecycle logging","notes":"Reference: docs/websocket-best-practices.md item 35\nTask: Review current implementation against this practice\nOutput: Update docs/websocket-recommendations.md with findings","status":"closed","priority":3,"issue_type":"task","created_at":"2026-01-11T13:56:48.594558-06:00","created_by":"travisbrown","updated_at":"2026-01-11T15:52:58.765774-06:00","closed_at":"2026-01-11T15:52:58.765774-06:00","close_reason":"Closed"}
{"id":"connectivity-ejq","title":"Review: Typed messages with clear structure","notes":"Reference: docs/websocket-best-practices.md item 11\nTask: Review current implementation against this practice\nOutput: Update docs/websocket-recommendations.md with findings","status":"closed","priority":3,"issue_type":"task","created_at":"2026-01-11T13:56:45.078741-06:00","created_by":"travisbrown","updated_at":"2026-01-11T14:55:06.106003-06:00","closed_at":"2026-01-11T14:55:06.106003-06:00","close_reason":"Review complete: typed messages fully implemented - type field in all messages, snake_case JSON convention with automatic conversion, protocol versioning via hello message"}
{"id":"connectivity-gq4","title":"Review: Delta sync implementation","notes":"Reference: docs/websocket-best-practices.md item 20\nTask: Review current implementation against this practice\nOutput: Update docs/websocket-recommendations.md with findings","status":"closed","priority":3,"issue_type":"task","created_at":"2026-01-11T13:56:52.685959-06:00","created_by":"travisbrown","updated_at":"2026-01-11T16:43:48.241497-06:00","closed_at":"2026-01-11T16:43:48.241497-06:00","close_reason":"Delta sync implementation fully reviewed - Status: Implemented with no gaps"}
{"id":"connectivity-gx8","title":"Review: Circuit breaker pattern","notes":"Reference: docs/websocket-best-practices.md item 34\nTask: Review current implementation against this practice\nOutput: Update docs/websocket-recommendations.md with findings","status":"closed","priority":3,"issue_type":"task","created_at":"2026-01-11T13:56:47.608763-06:00","created_by":"travisbrown","updated_at":"2026-01-11T15:38:02.694481-06:00","closed_at":"2026-01-11T15:38:02.694481-06:00","close_reason":"Reviewed circuit breaker pattern (item 34). Status: Partial implementation. We have max retry attempts (20) with exponential backoff, but lack proper circuit breaker states (open/half-open/closed), automatic recovery probes, and failure categorization. Documented 4 gaps and 5 recommendations in websocket-recommendations.md."}
{"id":"connectivity-ha9","title":"Review: Message acknowledgment system","notes":"Reference: docs/websocket-best-practices.md item 4\nTask: Review current implementation against this practice\nOutput: Update docs/websocket-recommendations.md with findings","status":"closed","priority":3,"issue_type":"task","created_at":"2026-01-11T13:56:42.753664-06:00","created_by":"travisbrown","updated_at":"2026-01-11T14:43:42.048648-06:00","closed_at":"2026-01-11T14:43:42.048648-06:00","close_reason":"Review completed - documented partial implementation with 2 gaps and 4 recommendations"}
{"id":"connectivity-is8","title":"Review: Message compression support","notes":"Reference: docs/websocket-best-practices.md item 18\nTask: Review current implementation against this practice\nOutput: Update docs/websocket-recommendations.md with findings","status":"closed","priority":3,"issue_type":"task","created_at":"2026-01-11T13:56:51.247422-06:00","created_by":"travisbrown","updated_at":"2026-01-11T16:27:51.530927-06:00","closed_at":"2026-01-11T16:27:51.530927-06:00","close_reason":"Closed"}
{"id":"connectivity-mdu","title":"Fix refresh session list breaking connectivity","description":"## Design Document\n@docs/design/refresh-session-list-fix.md\n\n## Overview\nFix the refresh button on the iOS home page that currently breaks WebSocket connectivity when tapped. The root cause is that `requestSessionList()` sends a `connect` message without the required `api_key`, triggering authentication failure and connection closure.\n\nThe solution introduces a new `refresh_sessions` WebSocket message type that allows authenticated clients to request an updated session list without re-authentication.\n\n## Acceptance Criteria\n1. Tapping the refresh button sends `refresh_sessions` (not `connect`)\n2. Refresh button only works when `isAuthenticated == true`\n3. Session list updates after tapping refresh\n4. WebSocket connection remains open after refresh\n5. Backend returns `auth_error` for `refresh_sessions` without prior authentication\n6. Existing `connect` flow unchanged (still requires `api_key`)\n7. Pull-to-refresh works correctly (uses same mechanism)\n\n## Components\n- Backend: Add `refresh_sessions` handler in `server.clj`\n- iOS: Update `requestSessionList()` in `VoiceCodeClient.swift`\n- Tests: Backend and iOS unit tests\n- Docs: Update STANDARDS.md with new message type","status":"closed","priority":1,"issue_type":"epic","created_at":"2026-01-11T17:04:10.070858-06:00","created_by":"travisbrown","updated_at":"2026-01-11T18:22:06.997199-06:00","closed_at":"2026-01-11T18:22:06.997199-06:00","close_reason":"Closed","dependencies":[{"issue_id":"connectivity-mdu","depends_on_id":"connectivity-mdu.1","type":"blocks","created_at":"2026-01-11T17:52:30.970337-06:00","created_by":"travisbrown"},{"issue_id":"connectivity-mdu","depends_on_id":"connectivity-mdu.2","type":"blocks","created_at":"2026-01-11T17:52:36.185995-06:00","created_by":"travisbrown"},{"issue_id":"connectivity-mdu","depends_on_id":"connectivity-mdu.3","type":"blocks","created_at":"2026-01-11T17:52:41.270073-06:00","created_by":"travisbrown"}]}
{"id":"connectivity-mdu.1","title":"Add refresh_sessions handler to backend","description":"## Design Reference\n@docs/design/refresh-session-list-fix.md#backend-handler\n\n## Context\nThis is the foundation task for the refresh fix. The backend must support the new `refresh_sessions` message type before the iOS client can be updated. Per the rollout strategy, this must be deployed first.\n\n## Requirements\n- [ ] Add handler for `refresh_sessions` message type in `handle-message`\n- [ ] Check `channel-authenticated?` before processing\n- [ ] Send `session_list` response with sessions\n- [ ] Send `recent_sessions` response\n- [ ] Send `available_commands` if working directory is set\n- [ ] Return `auth_error` and close connection if not authenticated\n\n## Technical Approach\n- File to modify: `backend/src/voice_code/server.clj`\n- Add new clause in `handle-message` cond for `\"refresh_sessions\"`\n- Reuse existing `send-recent-sessions!` and `send-available-commands!` functions\n- Use `channel-authenticated?` for auth check\n- Use `send-auth-error!` for unauthenticated requests\n\nImplementation pattern from design:\n```clojure\n(= msg-type \"refresh_sessions\")\n(if (channel-authenticated? channel)\n  (do\n    (log/info \"Client requested session list refresh\")\n    (let [limit (or (:recent-sessions-limit data) 5)]\n      ;; Send session list, recent sessions, available commands\n      ))\n  (send-auth-error! channel \"Not authenticated\"))\n```\n\n## Verification\n- [ ] Unit tests pass (created in sibling task)\n- [ ] Manual: Connect with authenticated client, send `refresh_sessions`, verify response\n- [ ] Manual: Send `refresh_sessions` without auth, verify `auth_error` received\n\n## Acceptance Criteria\n- Backend returns `auth_error` for `refresh_sessions` without prior authentication\n- Existing `connect` flow unchanged (still requires `api_key`)\n\n## Parallelization\nCan be worked alongside: \"Update STANDARDS.md with refresh_sessions message type\"","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-11T17:05:08.921949-06:00","created_by":"travisbrown","updated_at":"2026-01-11T18:22:06.993314-06:00","closed_at":"2026-01-11T18:22:06.993314-06:00","close_reason":"Closed"}
{"id":"connectivity-mdu.2","title":"Write backend unit tests for refresh_sessions","description":"## Design Reference\n@docs/design/refresh-session-list-fix.md#test-examples\n\n## Context\nUnit tests validate the backend handler behavior before iOS client changes are made. Tests must pass before proceeding with iOS implementation.\n\n## Requirements\n- [ ] Test: `refresh_sessions` returns session list when authenticated\n- [ ] Test: `refresh_sessions` returns `auth_error` when not authenticated\n- [ ] Test: `refresh_sessions` respects `recent_sessions_limit` parameter\n- [ ] All tests follow existing `server_auth_test.clj` patterns\n\n## Technical Approach\n- New file: `backend/test/voice_code/refresh_sessions_test.clj`\n- Use same test fixture pattern as `server_auth_test.clj`\n- Define local `test-api-key` and `with-test-api-key` fixture\n- Use `with-redefs` to mock `org.httpkit.server/send!`, `org.httpkit.server/close`\n- Use `server/handle-message`, `server/generate-json`, `server/parse-json`\n\nKey test cases from design:\n1. Authenticate first, then send `refresh_sessions` → should receive `session_list`\n2. Send `refresh_sessions` without auth → should receive `auth_error`, connection closed\n\n## Verification\n- [ ] Run `make test` - all tests pass\n- [ ] New test file follows codebase conventions\n- [ ] Tests cover happy path and error cases\n\n## Acceptance Criteria\n- Backend returns `auth_error` for `refresh_sessions` without prior authentication\n\n## Dependencies\n- Depends on: \"Add refresh_sessions handler to backend\"","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-11T17:05:20.650488-06:00","created_by":"travisbrown","updated_at":"2026-01-11T18:22:06.995388-06:00","closed_at":"2026-01-11T18:22:06.995388-06:00","close_reason":"Closed","dependencies":[{"issue_id":"connectivity-mdu.2","depends_on_id":"connectivity-mdu.1","type":"blocks","created_at":"2026-01-11T17:05:55.505023-06:00","created_by":"travisbrown"}]}
{"id":"connectivity-mdu.3","title":"Update requestSessionList() to use refresh_sessions message","description":"## Design Reference\n@docs/design/refresh-session-list-fix.md#ios-client-changes\n\n## Context\nThis is the core iOS fix. The current `requestSessionList()` sends a `connect` message without `api_key`, breaking connectivity. After backend supports `refresh_sessions`, this task updates the iOS client to use the new message type.\n\n## Requirements\n- [ ] Add `isAuthenticated` guard at function start\n- [ ] Change message type from `\"connect\"` to `\"refresh_sessions\"`\n- [ ] Keep existing `recent_sessions_limit` parameter\n- [ ] Keep existing timeout handling (5 seconds)\n- [ ] Log appropriate messages for debugging\n\n## Technical Approach\n- File to modify: `ios/VoiceCode/Managers/VoiceCodeClient.swift`\n- Function: `requestSessionList()` (around lines 1182-1212)\n\nImplementation from design:\n```swift\nfunc requestSessionList() async {\n    guard isAuthenticated else {\n        print(\"⚠️ [VoiceCodeClient] Cannot refresh sessions - not authenticated\")\n        return\n    }\n\n    await withCheckedContinuation { ... in\n        var message: [String: Any] = [\n            \"type\": \"refresh_sessions\"  // Changed from \"connect\"\n        ]\n        // ... rest unchanged\n    }\n}\n```\n\n## Verification\n- [ ] Unit tests pass (created in sibling task)\n- [ ] Manual: Tap refresh button while connected → session list updates\n- [ ] Manual: Verify connection status remains \"connected\" after refresh\n- [ ] Manual: Pull-to-refresh works correctly\n\n## Acceptance Criteria\n- Tapping the refresh button sends `refresh_sessions` (not `connect`)\n- Refresh button only works when `isAuthenticated == true`\n- Session list updates after tapping refresh\n- WebSocket connection remains open after refresh\n- Pull-to-refresh works correctly (uses same mechanism)\n\n## Dependencies\n- Depends on: Backend handler must be deployed first (connectivity-mdu.1)","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-11T17:05:31.538992-06:00","created_by":"travisbrown","updated_at":"2026-01-11T18:22:06.996378-06:00","closed_at":"2026-01-11T18:22:06.996378-06:00","close_reason":"Closed","dependencies":[{"issue_id":"connectivity-mdu.3","depends_on_id":"connectivity-mdu.1","type":"blocks","created_at":"2026-01-11T17:05:59.735733-06:00","created_by":"travisbrown"}]}
{"id":"connectivity-mdu.4","title":"Write iOS unit tests for refresh_sessions","description":"## Design Reference\n@docs/design/refresh-session-list-fix.md#test-examples\n\n## Context\nUnit tests validate the iOS client sends the correct message type and respects authentication state. Tests ensure the fix works as designed.\n\n## Requirements\n- [ ] Test: `requestSessionList()` sends `refresh_sessions` message type when authenticated\n- [ ] Test: `requestSessionList()` does NOT send any message when not authenticated\n- [ ] Tests follow existing `MockVoiceCodeClient` subclass pattern\n\n## Technical Approach\n- New file: `ios/VoiceCodeTests/RefreshSessionsTests.swift`\n- Create `MockVoiceCodeClientForRefresh` subclass with `sentMessages` array\n- Override `sendMessage()` to capture messages\n- Use `setupObservers: false` in init\n- Use `handleMessage()` to simulate authentication flow\n- Use XCTest expectations for async operations\n\nKey test cases from design:\n1. Authenticated client calls `requestSessionList()` → sends `refresh_sessions`\n2. Unauthenticated client calls `requestSessionList()` → no message sent\n\n## Verification\n- [ ] Run iOS tests - all tests pass\n- [ ] New test file follows codebase conventions\n- [ ] Tests use proper async/await patterns with expectations\n\n## Acceptance Criteria\n- Tapping the refresh button sends `refresh_sessions` (not `connect`)\n- Refresh button only works when `isAuthenticated == true`\n\n## Dependencies\n- Depends on: \"Update requestSessionList() to use refresh_sessions message\"","status":"closed","priority":1,"issue_type":"task","created_at":"2026-01-11T17:05:40.220266-06:00","created_by":"travisbrown","updated_at":"2026-01-11T17:20:00.119239-06:00","closed_at":"2026-01-11T17:20:00.119239-06:00","close_reason":"Closed","dependencies":[{"issue_id":"connectivity-mdu.4","depends_on_id":"connectivity-mdu","type":"parent-child","created_at":"2026-01-11T17:05:40.220892-06:00","created_by":"travisbrown"},{"issue_id":"connectivity-mdu.4","depends_on_id":"connectivity-mdu.3","type":"blocks","created_at":"2026-01-11T17:06:03.797942-06:00","created_by":"travisbrown"}]}
{"id":"connectivity-mdu.5","title":"Update STANDARDS.md with refresh_sessions message type","description":"## Design Reference\n@docs/design/refresh-session-list-fix.md#protocol-changes\n\n## Context\nSTANDARDS.md documents the WebSocket protocol. The new `refresh_sessions` message type needs to be added for protocol completeness and future reference.\n\n## Requirements\n- [ ] Add `refresh_sessions` to Client → Backend message types section\n- [ ] Document message format with JSON example\n- [ ] Document fields (type, recent_sessions_limit)\n- [ ] Document preconditions (must be authenticated)\n- [ ] Document response (session_list, recent_sessions)\n\n## Technical Approach\n- File to modify: `STANDARDS.md`\n- Add new subsection under \"Message Types\" → \"Client → Backend\"\n- Follow existing message documentation format\n\nContent to add:\n```markdown\n**Refresh Sessions Request**\n\\`\\`\\`json\n{\n  \"type\": \"refresh_sessions\",\n  \"recent_sessions_limit\": 10\n}\n\\`\\`\\`\n\n**Fields:**\n- `type` (required): Always `\"refresh_sessions\"`\n- `recent_sessions_limit` (optional): Maximum number of recent sessions to return (default: 5)\n\n**Preconditions:**\n- Client must be authenticated (sent `connect` with valid `api_key` and received `connected`)\n- If not authenticated, backend sends `auth_error`\n\n**Response:**\nBackend responds with `session_list` and `recent_sessions` messages (same as after `connect`).\n```\n\n## Verification\n- [ ] Documentation is clear and complete\n- [ ] Format matches existing message type documentation\n- [ ] JSON examples are syntactically correct\n\n## Acceptance Criteria\n- Protocol documentation is complete and accurate\n\n## Parallelization\nCan be worked alongside: \"Add refresh_sessions handler to backend\"","status":"closed","priority":2,"issue_type":"task","created_at":"2026-01-11T17:05:51.26842-06:00","created_by":"travisbrown","updated_at":"2026-01-11T17:23:41.580751-06:00","closed_at":"2026-01-11T17:23:41.580751-06:00","close_reason":"Closed","dependencies":[{"issue_id":"connectivity-mdu.5","depends_on_id":"connectivity-mdu","type":"parent-child","created_at":"2026-01-11T17:05:51.268995-06:00","created_by":"travisbrown"}]}
{"id":"connectivity-mrc","title":"Review: Request coalescing","notes":"Reference: docs/websocket-best-practices.md item 23. Task: Review current implementation against this practice. Output: Update docs/websocket-recommendations.md with findings.","status":"closed","priority":3,"issue_type":"task","created_at":"2026-01-11T13:56:46.887441-06:00","created_by":"travisbrown","updated_at":"2026-01-11T15:25:51.546805-06:00","closed_at":"2026-01-11T15:25:51.546805-06:00","close_reason":"Reviewed request coalescing (item 23). Status: Not Implemented. Found 4 gaps - no outgoing message queue, no batch subscribe protocol, no request deduplication, reconnection sends burst of individual messages. Documented in websocket-recommendations.md with recommendations for batch subscribe protocol and request deduplication."}
{"id":"connectivity-q82","title":"Review: Offline-first design","notes":"Reference: docs/websocket-best-practices.md item 21. Task: Review current implementation against this practice. Output: Update docs/websocket-recommendations.md with findings.","status":"closed","priority":3,"issue_type":"task","created_at":"2026-01-11T13:56:45.446442-06:00","created_by":"travisbrown","updated_at":"2026-01-11T15:03:00.361988-06:00","closed_at":"2026-01-11T15:03:00.361988-06:00","close_reason":"Reviewed offline-first design (item 21). Status: Partial. Key findings: File uploads ARE queued offline (ResourcesManager), message status UI EXISTS (clock/exclamation icons), optimistic UI works. Gaps: Prompts not queued when offline (silently dropped), no retry mechanism for failed sends. Added 4 recommendations including prompt queue and offline indicator."}
{"id":"connectivity-s5w","title":"Review: Persist pending messages to disk","notes":"Reference: docs/websocket-best-practices.md item 25. Task: Review current implementation against this practice. Output: Update docs/websocket-recommendations.md with findings.","status":"closed","priority":3,"issue_type":"task","created_at":"2026-01-11T13:56:48.505698-06:00","created_by":"travisbrown","updated_at":"2026-01-11T15:47:53.604698-06:00","closed_at":"2026-01-11T15:47:53.604698-06:00","close_reason":"Reviewed item 25 (Persist pending messages to disk) - found partial implementation with optimistic messages persisted to CoreData but gaps in retry queue, orphan detection, and error handling. Added findings to docs/websocket-recommendations.md."}
{"id":"connectivity-tvm","title":"Review: Client-side metrics tracking","notes":"Reference: docs/websocket-best-practices.md item 36\nTask: Review current implementation against this practice\nOutput: Update docs/websocket-recommendations.md with findings","status":"closed","priority":3,"issue_type":"task","created_at":"2026-01-11T13:56:49.529519-06:00","created_by":"travisbrown","updated_at":"2026-01-11T16:04:52.16163-06:00","closed_at":"2026-01-11T16:04:52.16163-06:00","close_reason":"Closed"}
{"id":"connectivity-u8x","title":"Review: Reconnection auth design","notes":"Reference: docs/websocket-best-practices.md item 7\nTask: Review current implementation against this practice\nOutput: Update docs/websocket-recommendations.md with findings","status":"closed","priority":3,"issue_type":"task","created_at":"2026-01-11T13:56:45.037222-06:00","created_by":"travisbrown","updated_at":"2026-01-11T14:52:07.819799-06:00","closed_at":"2026-01-11T14:52:07.819799-06:00","close_reason":"Reviewed reconnection auth design - implementation fully meets best practice with Keychain storage, automatic credential retrieval on reconnection, and clear separation of auth vs connection failures"}
{"id":"connectivity-udt","title":"Review: WiFi to Cellular handoff handling","notes":"Reference: docs/websocket-best-practices.md item 29. Task: Review current implementation against this practice. Output: Update docs/websocket-recommendations.md with findings.","status":"closed","priority":3,"issue_type":"task","created_at":"2026-01-11T13:56:52.773353-06:00","created_by":"travisbrown","updated_at":"2026-01-11T16:48:28.569286-06:00","closed_at":"2026-01-11T16:48:28.569286-06:00","close_reason":"Closed"}
{"id":"connectivity-uou","title":"Review: Server-side connection draining","notes":"Reference: docs/websocket-best-practices.md item 32\nTask: Review current implementation against this practice\nOutput: Update docs/websocket-recommendations.md with findings","status":"closed","priority":3,"issue_type":"task","created_at":"2026-01-11T13:56:45.991287-06:00","created_by":"travisbrown","updated_at":"2026-01-11T15:10:32.163076-06:00","closed_at":"2026-01-11T15:10:32.163076-06:00","close_reason":"Closed"}
{"id":"connectivity-v0d","title":"Review: Battery optimization","notes":"Reference: docs/websocket-best-practices.md item 10\nTask: Review current implementation against this practice\nOutput: Update docs/websocket-recommendations.md with findings","status":"closed","priority":3,"issue_type":"task","created_at":"2026-01-11T13:56:47.784398-06:00","created_by":"travisbrown","updated_at":"2026-01-11T15:41:01.329888-06:00","closed_at":"2026-01-11T15:41:01.329888-06:00","close_reason":"Reviewed item 10 (Battery optimization) - status: Partial. Has 30s ping interval, exponential backoff with jitter, UI debouncing. Missing: network-aware reconnection, push notifications (by design), background disconnect. Added 4 gaps and 4 recommendations."}
{"id":"connectivity-vpm","title":"Review: Message corruption handling","notes":"Reference: docs/websocket-best-practices.md item 40\nTask: Review current implementation against this practice\nOutput: Update docs/websocket-recommendations.md with findings","status":"closed","priority":3,"issue_type":"task","created_at":"2026-01-11T13:56:53.633507-06:00","created_by":"travisbrown","updated_at":"2026-01-11T16:53:46.940413-06:00","closed_at":"2026-01-11T16:53:46.940413-06:00","close_reason":"Closed"}
{"id":"connectivity-vuo","title":"Review: User-visible connection status","notes":"Reference: docs/websocket-best-practices.md item 37\nTask: Review current implementation against this practice\nOutput: Update docs/websocket-recommendations.md with findings","status":"closed","priority":3,"issue_type":"task","created_at":"2026-01-11T13:56:50.253129-06:00","created_by":"travisbrown","updated_at":"2026-01-11T16:14:23.027525-06:00","closed_at":"2026-01-11T16:14:23.027525-06:00","close_reason":"Closed"}
{"id":"connectivity-wlq","title":"Review: Network transition handling (reachability)","notes":"Reference: docs/websocket-best-practices.md item 2\nTask: Review current implementation against this practice\nOutput: Update docs/websocket-recommendations.md with findings","status":"closed","priority":3,"issue_type":"task","created_at":"2026-01-11T13:56:41.308834-06:00","created_by":"travisbrown","updated_at":"2026-01-11T14:38:56.21068-06:00","closed_at":"2026-01-11T14:38:56.21068-06:00","close_reason":"Reviewed item 2 (Network transition handling). Found gap: no NWPathMonitor implementation. Added findings and recommendations to docs/websocket-recommendations.md."}
{"id":"connectivity-xa6","title":"Review: Background execution time for cleanup","notes":"Reference: docs/websocket-best-practices.md item 28. Task: Review current implementation against this practice. Output: Update docs/websocket-recommendations.md with findings.","status":"closed","priority":3,"issue_type":"task","created_at":"2026-01-11T13:56:51.826892-06:00","created_by":"travisbrown","updated_at":"2026-01-11T16:33:55.00002-06:00","closed_at":"2026-01-11T16:33:55.00002-06:00","close_reason":"Reviewed item 28 (Request background execution time for cleanup). Status: Not Implemented. Added 5 gaps and 3 recommendations to docs/websocket-recommendations.md."}
{"id":"connectivity-y5w","title":"Review: Idempotent operations design","notes":"Reference: docs/websocket-best-practices.md item 12\nTask: Review current implementation against this practice\nOutput: Update docs/websocket-recommendations.md with findings","status":"closed","priority":3,"issue_type":"task","created_at":"2026-01-11T13:56:45.83344-06:00","created_by":"travisbrown","updated_at":"2026-01-11T15:07:16.244368-06:00","closed_at":"2026-01-11T15:07:16.244368-06:00","close_reason":"Reviewed idempotent operations design - partial implementation with session locking, UUID deduplication, and idempotent stop operations; gaps in response message IDs and prompt idempotency"}
{"id":"connectivity-yln","title":"Review: Message prioritization","notes":"Reference: docs/websocket-best-practices.md item 17\nTask: Review current implementation against this practice\nOutput: Update docs/websocket-recommendations.md with findings","status":"closed","priority":3,"issue_type":"task","created_at":"2026-01-11T13:56:50.374936-06:00","created_by":"travisbrown","updated_at":"2026-01-11T16:17:05.892384-06:00","closed_at":"2026-01-11T16:17:05.892384-06:00","close_reason":"Reviewed item 17 (message prioritization). Status: Not Implemented. Key gaps: no outgoing message queue, no priority classification, no congestion detection. Added to docs/websocket-recommendations.md."}
{"id":"connectivity-z79","title":"Review: Clock skew handling","notes":"Reference: docs/websocket-best-practices.md item 38\nTask: Review current implementation against this practice\nOutput: Update docs/websocket-recommendations.md with findings","status":"closed","priority":3,"issue_type":"task","created_at":"2026-01-11T13:56:51.625931-06:00","created_by":"travisbrown","updated_at":"2026-01-11T16:30:20.939696-06:00","closed_at":"2026-01-11T16:30:20.939696-06:00","close_reason":"Closed"}
{"id":"connectivity-zg4","title":"Review: Graceful degradation on background","notes":"Reference: docs/websocket-best-practices.md item 27. Task: Review current implementation against this practice. Output: Update docs/websocket-recommendations.md with findings.","status":"closed","priority":3,"issue_type":"task","created_at":"2026-01-11T13:56:50.375351-06:00","created_by":"travisbrown","updated_at":"2026-01-11T16:20:34.224132-06:00","closed_at":"2026-01-11T16:20:34.224132-06:00","close_reason":"Reviewed item 27 (Graceful degradation on background). Status: Partial. Key gaps: no proactive WebSocket close on background, no graceful close code sent. Strengths: good delta sync implementation for state restoration on foreground."}
{"id":"connectivity-zlt","title":"Review: Replay attack protection","notes":"Reference: docs/websocket-best-practices.md item 39\nTask: Review current implementation against this practice\nOutput: Update docs/websocket-recommendations.md with findings","status":"closed","priority":3,"issue_type":"task","created_at":"2026-01-11T13:56:52.414203-06:00","created_by":"travisbrown","updated_at":"2026-01-11T16:41:16.783995-06:00","closed_at":"2026-01-11T16:41:16.783995-06:00","close_reason":"Closed"}
