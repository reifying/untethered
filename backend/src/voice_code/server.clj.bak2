(ns voice-code.server
  "Main entry point and WebSocket server for voice-code backend."
  (:require [org.httpkit.server :as http]
            [clojure.core.async :as async]
            [cheshire.core :as json]
            [clojure.tools.logging :as log]
            [clojure.edn :as edn]
            [clojure.java.io :as io]
            [clojure.string :as str]
            [voice-code.claude :as claude]
            [voice-code.replication :as repl])
  (:gen-class))

;; JSON key conversion utilities
;; Following STANDARDS.md: JSON uses snake_case, Clojure uses kebab-case

(defn snake->kebab
  "Convert snake_case string to kebab-case keyword"
  [s]
  (keyword (str/replace s #"_" "-")))

(defn kebab->snake
  "Convert kebab-case keyword to snake_case string"
  [k]
  (str/replace (name k) #"-" "_"))

(defn parse-json
  "Parse JSON string, converting snake_case keys to kebab-case keywords"
  [s]
  (json/parse-string s snake->kebab))

(defn generate-json
  "Generate JSON string, converting kebab-case keywords to snake_case keys"
  [data]
  (json/generate-string data {:key-fn kebab->snake}))

(defonce server-state (atom nil))

(defn ensure-config-file
  "Ensure config.edn exists, creating with defaults if needed.
  Only works in development (not when running from JAR).
  
  Accepts optional config-path for testing purposes."
  ([]
   (ensure-config-file "resources/config.edn"))
  ([config-path]
   (let [config-file (io/file config-path)]
     (when-not (.exists config-file)
       (log/info "Creating default config.edn at" config-path)
       (io/make-parents config-file)
       (spit config-file
             (str "{:server {:port 8080\n"
                  "          :host \"0.0.0.0\"}\n\n"
                  " :claude {:cli-path \"claude\"\n"
                  "          :default-timeout 86400000}  ; 24 hours in milliseconds\n\n"
                  " :logging {:level :info}}\n"))))))

(defn load-config
  "Load configuration from resources/config.edn, creating with defaults if needed"
  []
  (ensure-config-file)
  (if-let [config-resource (io/resource "config.edn")]
    (-> config-resource
        slurp
        edn/read-string)
    ;; Fallback to defaults if resource not found (e.g., in JAR)
    (do
      (log/warn "config.edn not found on classpath, using defaults")
      {:server {:port 8080
                :host "0.0.0.0"}
       :claude {:cli-path "claude"
                :default-timeout 86400000}
       :logging {:level :info}})))

;; Ephemeral mapping: WebSocket channel -> iOS session UUID
;; This is just for routing messages during an active connection
;; Persistent session data is stored via voice-code.storage

(defonce connected-clients
  ;; Track all connected WebSocket clients: channel -> {:session-id, :deleted-sessions #{}}
  (atom {}))

(defn unregister-channel!
  "Remove WebSocket channel from connected clients"
  [channel]
  (swap! connected-clients dissoc channel))

(defn generate-message-id
  "Generate a UUID v4 for message tracking"
  []
  (str (java.util.UUID/randomUUID)))

(defn broadcast-to-all-clients!
  "Broadcast a message to all connected clients"
  [message-data]
  (doseq [[channel _client-info] @connected-clients]
    (try
      (http/send! channel (generate-json message-data))
      (catch Exception e
        (log/warn e "Failed to broadcast to client")))))

(defn send-to-client!
  "Send message to a specific channel if it's connected"
  [channel message-data]
  (if (contains? @connected-clients channel)
    (do
      (log/info "Sending message to client" {:type (:type message-data)})
      (try
        (http/send! channel (generate-json message-data))
        (log/info "Message sent successfully" {:type (:type message-data)})
        (catch Exception e
          (log/warn e "Failed to send to client"))))
    (log/warn "Channel not in connected-clients, skipping send" {:type (:type message-data)})))

(defn is-session-deleted-for-client?
  "Check if a client has deleted a session locally"
  [channel session-id]
  (let [client-info (get @connected-clients channel)]
    (contains? (:deleted-sessions client-info) session-id)))

(defn mark-session-deleted-for-client!
  "Mark a session as deleted for a specific client"
  [channel session-id]
  (swap! connected-clients update-in [channel :deleted-sessions] (fnil conj #{}) session-id)
  (log/debug "Marked session as deleted for client" {:session-id session-id}))

;; Filesystem watcher callbacks

(defn on-session-created
  "Called when a new session file is detected"
  [session-metadata]
  (log/info "Broadcasting new session" {:session-id (:session-id session-metadata)})
  ;; Broadcast to clients who haven't deleted this session
  (doseq [[channel client-info] @connected-clients]
    (when-not (is-session-deleted-for-client? channel (:session-id session-metadata))
      (send-to-client! channel
                       {:type "session-created"
                        :session-id (:session-id session-metadata)
                        :name (:name session-metadata)
                        :working-directory (:working-directory session-metadata)
                        :last-modified (:last-modified session-metadata)
                        :message-count (:message-count session-metadata)
                        :preview (:preview session-metadata)}))))

(defn on-session-updated
  "Called when a subscribed session has new messages"
  [session-id new-messages]
  (log/debug "Broadcasting session update" {:session-id session-id :message-count (count new-messages)})
  ;; Send to all clients subscribed to this session (and haven't deleted it)
  (doseq [[channel client-info] @connected-clients]
    (when-not (is-session-deleted-for-client? channel session-id)
      (send-to-client! channel
                       {:type "session-updated"
                        :session-id session-id
                        :messages new-messages}))))

(defn on-session-deleted
  "Called when a session file is deleted from filesystem"
  [session-id]
  (log/info "Session deleted from filesystem" {:session-id session-id})
  ;; This is informational - we don't broadcast deletes since it's just local cleanup
  )

;; Message handling
(defn handle-message
  "Handle incoming WebSocket message"
  [channel msg]
  (try
    (let [data (parse-json msg)]
      (log/debug "Received message" {:type (:type data)})

      (case (:type data)
        "ping"
        (do
          (log/debug "Handling ping")
          (http/send! channel (generate-json {:type "pong"})))

        "connect"
        ;; New protocol: no session-id needed, just send session list
        (do
          (log/info "Client connected")

          ;; Register client (no session-id needed in new architecture)
          (swap! connected-clients assoc channel {:deleted-sessions #{}})

          ;; Send session list (limit to 50 most recent, lightweight fields only)
          (let [all-sessions (repl/get-all-sessions)
                ;; Sort by last-modified descending, take 50
                recent-sessions (->> all-sessions
                                     (sort-by :last-modified >)
                                     (take 50)
                                     ;; Remove heavy fields to reduce payload size
                                     (mapv #(select-keys % [:session-id :name :working-directory
                                                            :last-modified :message-count])))]
            (log/info "Sending session list" {:count (count recent-sessions) :total (count all-sessions)})
            (http/send! channel
                        (generate-json
                         {:type :session-list
                          :sessions recent-sessions
                          :total-count (count all-sessions)}))))

        "subscribe"
        ;; Client requests full history for a session
        (let [session-id (:session-id data)]
          (if-not session-id
            (http/send! channel
                        (generate-json
                         {:type "error"
                          :message "session_id required in subscribe message"}))
            (do
              (log/info "Client subscribing to session" {:session-id session-id})

              ;; Subscribe in replication system
              (repl/subscribe-to-session! session-id)

              ;; Get session metadata
              (if-let [metadata (repl/get-session-metadata session-id)]
                (let [file-path (:file metadata)
                      all-messages (repl/parse-jsonl-file file-path)
;; Limit to most recent 20 messages to prevent payload size issues
                      messages (vec (take-last 20 all-messages))]
                  (log/info "Sending session history" {:session-id session-id :message-count (count messages) :total (count all-messages)})
                  (http/send! channel
                              (generate-json
                               {:type "session-history"
                                :session-id session-id
                                :messages messages
                                :total-count (count all-messages)})))
                (do
                  (log/warn "Session not found" {:session-id session-id})
                  (http/send! channel
                              (generate-json
                               {:type "error"
                                :message (str "Session not found: " session-id)})))))))

        "unsubscribe"
        ;; Client stops watching a session
        (let [session-id (:session-id data)]
          (when session-id
            (log/info "Client unsubscribing from session" {:session-id session-id})
            (repl/unsubscribe-from-session! session-id)))

        "session-deleted"
        ;; Client marks session as deleted locally
        (let [session-id (:session-id data)]
          (when session-id
            (log/info "Client deleted session locally" {:session-id session-id})
            (mark-session-deleted-for-client! channel session-id)
            (repl/unsubscribe-from-session! session-id)))

        "prompt"
        ;; Updated to use new_session_id vs resume_session_id
        (let [new-session-id (:new-session-id data)
              resume-session-id (:resume-session-id data)
              prompt-text (:text data)
              working-dir (:working-directory data)]

          (cond
            ;; Check if client has connected first
            (not (contains? @connected-clients channel))
            (http/send! channel
                        (generate-json
                         {:type "error"
                          :message "Must send connect message first"}))

            (not prompt-text)
            (http/send! channel
                        (generate-json
                         {:type "error"
                          :message "text required in prompt message"}))

            (and new-session-id resume-session-id)
            (http/send! channel
                        (generate-json
                         {:type "error"
                          :message "Cannot specify both new_session_id and resume_session_id"}))

            :else
            (do
              (log/info "Received prompt"
                        {:text (subs prompt-text 0 (min 50 (count prompt-text)))
                         :new-session-id new-session-id
                         :resume-session-id resume-session-id
                         :working-directory working-dir})

              ;; Send immediate acknowledgment
              (http/send! channel
                          (generate-json
                           {:type "ack"
                            :message "Processing prompt..."}))

              ;; Invoke Claude asynchronously
              (claude/invoke-claude-async
               prompt-text
               (fn [response]
                 ;; Send response back to client
                 (if (:success response)
                   (let [usage (:usage response)
                         input-tokens (get usage :input_tokens 0)
                         output-tokens (get usage :output_tokens 0)
                         ;; Claude CLI pricing (approximate for Sonnet)
                         input-cost-per-token 0.000003
                         output-cost-per-token 0.000015
                         input-cost (* input-tokens input-cost-per-token)
                         output-cost (* output-tokens output-cost-per-token)
                         total-cost (or (:cost response) (+ input-cost output-cost))]
                     (log/info "Prompt completed successfully"
                               {:session-id (:session-id response)})
                     (send-to-client! channel
                                      {:type "response"
                                       :message-id (generate-message-id)
                                       :success true
                                       :text (:result response)
                                       :session-id (:session-id response)
                                       :usage usage
                                       :cost {:input-cost input-cost
                                              :output-cost output-cost
                                              :total-cost total-cost}}))
                   (do
                     (log/error "Prompt failed" {:error (:error response)})
                     (send-to-client! channel
                                      {:type "response"
                                       :success false
                                       :error (:error response)}))))
               :new-session-id new-session-id
               :resume-session-id resume-session-id
               :working-directory working-dir
               :timeout-ms 86400000))))

        "set-directory"
        (let [path (:path data)]
          (if-not path
            (http/send! channel
                        (generate-json
                         {:type "error"
                          :message "path required in set-directory message"}))
            (do
              (log/info "Working directory set" {:path path})
              (http/send! channel
                          (generate-json
                           {:type "ack"
                            :message (str "Working directory set to: " path)})))))

        "message-ack"
        (let [message-id (:message-id data)]
          (log/debug "Message acknowledged" {:message-id message-id}))

        ;; Unknown message type
        (do
          (log/warn "Unknown message type" {:type (:type data)})
          (http/send! channel
                      (generate-json
                       {:type "error"
                        :message (str "Unknown message type: " (:type data))})))))

    (catch Exception e
      (log/error e "Error handling message")
      (http/send! channel
                  (generate-json
                   {:type "error"
                    :message (str "Error processing message: " (ex-message e))})))))

;; WebSocket handler
(defn websocket-handler
  "Handle WebSocket connections"
  [request]
  (http/with-channel request channel
    (if (http/websocket? channel)
      (do
        (log/info "WebSocket connection established" {:remote-addr (:remote-addr request)})

        ;; Send hello message
        (http/send! channel
                    (generate-json
                     {:type "hello"
                      :message "Welcome to voice-code backend"
                      :version "0.2.0"}))

        ;; Handle incoming messages
        (http/on-receive channel
                         (fn [msg]
                           (handle-message channel msg)))

        ;; Handle connection close
        (http/on-close channel
                       (fn [status]
                         (log/info "WebSocket connection closed" {:status status})
                         (unregister-channel! channel))))

      ;; Not a WebSocket request
      (http/send! channel
                  {:status 400
                   :headers {"Content-Type" "text/plain"}
                   :body "This endpoint requires WebSocket connection"}))))

(defn -main
  "Start the WebSocket server"
  [& args]
  (let [config (load-config)
        port (get-in config [:server :port] 8080)
        host (get-in config [:server :host] "0.0.0.0")
        default-dir (get-in config [:claude :default-working-directory])]

    ;; Initialize replication system
    (log/info "Initializing session replication system")
    (repl/initialize-index!)

    ;; Start filesystem watcher
    (try
      (repl/start-watcher!
       :on-session-created on-session-created
       :on-session-updated on-session-updated
       :on-session-deleted on-session-deleted)
      (log/info "Filesystem watcher started successfully")
      (catch Exception e
        (log/error e "Failed to start filesystem watcher")))

    (log/info "Starting voice-code server"
              {:port port
               :host host
               :default-working-directory default-dir})

    (let [server (http/run-server websocket-handler {:port port :host host})]
      (reset! server-state server)

      ;; Add graceful shutdown hook
      (.addShutdownHook
       (Runtime/getRuntime)
       (Thread. (fn []
                  (log/info "Shutting down voice-code server gracefully")
                  ;; Stop filesystem watcher
                  (repl/stop-watcher!)
                  ;; Save session index
                  (repl/save-index! @repl/session-index)
                  ;; Stop HTTP server with 100ms timeout
                  (when @server-state
                    (@server-state :timeout 100))
                  (log/info "Server shutdown complete"))))

      (println (format "âœ“ Voice-code WebSocket server running on ws://%s:%d" host port))
      (when default-dir
        (println (format "  Default working directory: %s" default-dir)))
      (println "  Ready for connections. Press Ctrl+C to stop.")

      ;; Keep main thread alive
      @(promise))))
