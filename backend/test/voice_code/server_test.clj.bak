(ns voice-code.server-test
  (:require [clojure.test :refer :all]
            [voice-code.server :as server]
            [cheshire.core :as json]
            [clojure.java.io :as io]))

(deftest test-load-config
  (testing "Configuration loading from resources"
    (let [config (server/load-config)]
      (is (map? config))
      (is (contains? config :server))
      (is (= 8080 (get-in config [:server :port]))))))

(deftest test-ensure-config-file
  (testing "Creates default config.edn when missing and doesn't overwrite existing"
    (let [temp-dir (str (System/getProperty "java.io.tmpdir") "/voice-code-test-" (System/currentTimeMillis))
          test-resources-dir (str temp-dir "/resources")
          test-config-path (str test-resources-dir "/config.edn")
          test-config-file (clojure.java.io/file test-config-path)]

      (try
        ;; Ensure clean slate
        (.mkdirs (clojure.java.io/file test-resources-dir))
        (when (.exists test-config-file)
          (.delete test-config-file))

        ;; Verify file doesn't exist initially
        (is (not (.exists test-config-file)) "Config should not exist initially")

        ;; First call should create the file - testing the REAL function
        (server/ensure-config-file test-config-path)
        (is (.exists test-config-file) "Config file should be created")

        ;; Verify content is valid EDN with correct default values
        (let [config (clojure.edn/read-string (slurp test-config-file))]
          (is (map? config))
          (is (= 8080 (get-in config [:server :port])))
          (is (= "0.0.0.0" (get-in config [:server :host])))
          (is (= "claude" (get-in config [:claude :cli-path])))
          (is (= 86400000 (get-in config [:claude :default-timeout])))
          (is (= :info (get-in config [:logging :level]))))

        ;; Modify the file to verify ensure-config-file doesn't overwrite
        (spit test-config-path "{:modified true :custom-value 42}")

        ;; Second call should NOT overwrite existing file
        (server/ensure-config-file test-config-path)
        (let [config (clojure.edn/read-string (slurp test-config-file))]
          (is (= true (:modified config)) "Should not overwrite existing config")
          (is (= 42 (:custom-value config)) "Custom values should be preserved"))

        (finally
          ;; Clean up temp directory
          (when (.exists test-config-file)
            (.delete test-config-file))
          (let [resources-dir (clojure.java.io/file test-resources-dir)]
            (when (.exists resources-dir)
              (.delete resources-dir)))
          (let [temp-dir-file (clojure.java.io/file temp-dir)]
            (when (.exists temp-dir-file)
              (.delete temp-dir-file))))))))

(deftest test-load-config-with-fallback
  (testing "Falls back to defaults when config.edn not found"
    (with-redefs [clojure.java.io/resource (constantly nil)
                  server/ensure-config-file (fn
                                              ([] nil)
                                              ([_] nil))]
      (let [config (server/load-config)]
        (is (map? config))
        (is (= 8080 (get-in config [:server :port])))
        (is (= "0.0.0.0" (get-in config [:server :host])))
        (is (= "claude" (get-in config [:claude :cli-path])))
        (is (= 86400000 (get-in config [:claude :default-timeout])))
        (is (= :info (get-in config [:logging :level])))))))

(deftest test-json-key-conversion
  (testing "snake_case to kebab-case conversion"
    (is (= :session-id (server/snake->kebab "session_id")))
    (is (= :working-directory (server/snake->kebab "working_directory")))
    (is (= :claude-session-id (server/snake->kebab "claude_session_id")))
    (is (= :type (server/snake->kebab "type"))))

  (testing "kebab-case to snake_case conversion"
    (is (= "session_id" (server/kebab->snake :session-id)))
    (is (= "working_directory" (server/kebab->snake :working-directory)))
    (is (= "claude_session_id" (server/kebab->snake :claude-session-id)))
    (is (= "type" (server/kebab->snake :type))))

  (testing "parse-json converts snake_case to kebab-case"
    (let [json-str "{\"session_id\":\"abc123\",\"working_directory\":\"/tmp\",\"type\":\"prompt\"}"
          parsed (server/parse-json json-str)]
      (is (= "abc123" (:session-id parsed)))
      (is (= "/tmp" (:working-directory parsed)))
      (is (= "prompt" (:type parsed)))
      (is (nil? (:session_id parsed)))))

  (testing "generate-json converts kebab-case to snake_case"
    (let [data {:session-id "abc123"
                :working-directory "/tmp"
                :type "prompt"}
          json-str (server/generate-json data)
          parsed (json/parse-string json-str true)]
      (is (= "abc123" (:session_id parsed)))
      (is (= "/tmp" (:working_directory parsed)))
      (is (= "prompt" (:type parsed)))
      (is (nil? (:session-id parsed)))))

  (testing "Round-trip conversion"
    (let [original-data {:session-id "test-123"
                         :working-directory "/home/user"
                         :type "prompt"
                         :text "Hello"}
          json-str (server/generate-json original-data)
          parsed-back (server/parse-json json-str)]
      (is (= original-data parsed-back)))))

(deftest test-message-buffering
  (testing "Message buffering and acknowledgment"
    (let [test-path (str (System/getProperty "java.io.tmpdir")
                         "/voice-code-server-test-"
                         (System/currentTimeMillis)
                         "/sessions.edn")]
      (try
        (with-redefs [storage/storage-file test-path]
          (reset! server/channel-to-session {})
          (reset! storage/sessions-atom {:sessions {}})
          (storage/ensure-storage-file test-path)

          (let [ios-session-id "test-ios-uuid-buffering"]
            ;; Create session
            (storage/create-session! ios-session-id "/tmp")

            ;; Buffer a message
            (let [msg (server/buffer-message! ios-session-id
                                              :assistant
                                              "Test response"
                                              "claude-session-123")]
              ;; Verify message has UUID
              (is (some? (:id msg)) "Message should have UUID")
              (is (= :assistant (:role msg)))
              (is (= "Test response" (:text msg)))
              (is (= "claude-session-123" (:session-id msg)))

              ;; Verify message is in undelivered queue
              (let [undelivered (storage/get-undelivered-messages ios-session-id)]
                (is (= 1 (count undelivered)))
                (is (= (:id msg) (:id (first undelivered)))))

              ;; Acknowledge message (simulating iOS receipt)
              (storage/remove-undelivered-message! ios-session-id (:id msg))

              ;; Verify message removed from queue
              (let [undelivered-after (storage/get-undelivered-messages ios-session-id)]
                (is (= 0 (count undelivered-after)) "Queue should be empty after ack")))))

        (finally
          (let [file (io/file test-path)]
            (when (.exists file)
              (.delete file))
            (when-let [parent (.getParentFile file)]
              (when (.exists parent)
                (.delete parent))))))))

  (testing "Generate unique message IDs"
    (let [id1 (server/generate-message-id)
          id2 (server/generate-message-id)]
      (is (string? id1) "Message ID should be a string")
      (is (string? id2) "Message ID should be a string")
      (is (not= id1 id2) "Message IDs should be unique")
      ;; Verify UUID v4 format (loose check)
      (is (re-matches #"[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}" id1)
          "Should be valid UUID format")))

  (testing "Multiple undelivered messages"
    (let [test-path (str (System/getProperty "java.io.tmpdir")
                         "/voice-code-server-test-"
                         (System/currentTimeMillis)
                         "/sessions.edn")]
      (try
        (with-redefs [storage/storage-file test-path]
          (reset! storage/sessions-atom {:sessions {}})
          (storage/ensure-storage-file test-path)

          (let [ios-session-id "test-ios-uuid-multi"]
            (storage/create-session! ios-session-id "/tmp")

            ;; Buffer three messages
            (let [msg1 (server/buffer-message! ios-session-id :assistant "Response 1" "session-1")
                  msg2 (server/buffer-message! ios-session-id :assistant "Response 2" "session-2")
                  msg3 (server/buffer-message! ios-session-id :assistant "Response 3" "session-3")]

              ;; Verify all three in queue
              (let [undelivered (storage/get-undelivered-messages ios-session-id)]
                (is (= 3 (count undelivered))))

              ;; Acknowledge middle message
              (storage/remove-undelivered-message! ios-session-id (:id msg2))

              ;; Verify only msg1 and msg3 remain
              (let [undelivered (storage/get-undelivered-messages ios-session-id)]
                (is (= 2 (count undelivered)))
                (is (some #(= (:id msg1) (:id %)) undelivered))
                (is (some #(= (:id msg3) (:id %)) undelivered))
                (is (not (some #(= (:id msg2) (:id %)) undelivered)))))))

        (finally
          (let [file (io/file test-path)]
            (when (.exists file)
              (.delete file))
            (when-let [parent (.getParentFile file)]
              (when (.exists parent)
                (.delete parent)))))))))

(deftest test-reconnection-and-replay
  (testing "Reconnection replays undelivered messages"
    (let [test-path (str (System/getProperty "java.io.tmpdir")
                         "/voice-code-server-test-"
                         (System/currentTimeMillis)
                         "/sessions.edn")
          sent-messages (atom [])]
      (try
        (with-redefs [storage/storage-file test-path
                      ;; Mock http/send! to capture sent messages
                      org.httpkit.server/send! (fn [channel msg]
                                                 (swap! sent-messages conj msg))]
          (reset! server/channel-to-session {})
          (reset! storage/sessions-atom {:sessions {}})
          (storage/ensure-storage-file test-path)

          (let [ios-session-id "test-reconnection-uuid"
                channel1 :channel-1
                channel2 :channel-2]

            ;; Initial connection
            (storage/create-session! ios-session-id "/tmp")

            ;; Buffer some undelivered messages (simulating messages sent while disconnected)
            (server/buffer-message! ios-session-id :assistant "Message 1" "session-1")
            (server/buffer-message! ios-session-id :assistant "Message 2" "session-2")
            (server/buffer-message! ios-session-id :assistant "Message 3" "session-3")

            ;; Verify 3 messages in queue
            (is (= 3 (count (storage/get-undelivered-messages ios-session-id))))

            ;; Simulate reconnection - replay should happen
            (reset! sent-messages [])
            (server/replay-undelivered-messages! channel2 ios-session-id)

            ;; Verify 3 replay messages were sent
            (is (= 3 (count @sent-messages)) "Should replay 3 messages")

            ;; Verify replay message format
            (let [first-replay (json/parse-string (first @sent-messages) true)]
              (is (= "replay" (:type first-replay)))
              (is (some? (:message_id first-replay)))
              (is (= "assistant" (get-in first-replay [:message :role])))
              (is (= "Message 1" (get-in first-replay [:message :text])))
              (is (= "session-1" (get-in first-replay [:message :session_id]))))))

        (finally
          (let [file (io/file test-path)]
            (when (.exists file)
              (.delete file))
            (when-let [parent (.getParentFile file)]
              (when (.exists parent)
                (.delete parent))))))))

  (testing "Replay sends messages in order"
    (let [test-path (str (System/getProperty "java.io.tmpdir")
                         "/voice-code-server-test-"
                         (System/currentTimeMillis)
                         "/sessions.edn")
          sent-messages (atom [])]
      (try
        (with-redefs [storage/storage-file test-path
                      org.httpkit.server/send! (fn [channel msg]
                                                 (swap! sent-messages conj msg))]
          (reset! storage/sessions-atom {:sessions {}})
          (storage/ensure-storage-file test-path)

          (let [ios-session-id "test-replay-order"]
            (storage/create-session! ios-session-id "/tmp")

            ;; Buffer messages in specific order
            (server/buffer-message! ios-session-id :assistant "First" "s1")
            (server/buffer-message! ios-session-id :assistant "Second" "s2")
            (server/buffer-message! ios-session-id :assistant "Third" "s3")

            ;; Replay
            (reset! sent-messages [])
            (server/replay-undelivered-messages! :test-channel ios-session-id)

            ;; Verify order preserved
            (let [messages (map #(json/parse-string % true) @sent-messages)
                  texts (map #(get-in % [:message :text]) messages)]
              (is (= ["First" "Second" "Third"] texts) "Messages should be replayed in order"))))

        (finally
          (let [file (io/file test-path)]
            (when (.exists file)
              (.delete file))
            (when-let [parent (.getParentFile file)]
              (when (.exists parent)
                (.delete parent))))))))

  (testing "No replay when queue is empty"
    (let [test-path (str (System/getProperty "java.io.tmpdir")
                         "/voice-code-server-test-"
                         (System/currentTimeMillis)
                         "/sessions.edn")
          sent-messages (atom [])]
      (try
        (with-redefs [storage/storage-file test-path
                      org.httpkit.server/send! (fn [channel msg]
                                                 (swap! sent-messages conj msg))]
          (reset! storage/sessions-atom {:sessions {}})
          (storage/ensure-storage-file test-path)

          (let [ios-session-id "test-empty-queue"]
            (storage/create-session! ios-session-id "/tmp")

            ;; No messages buffered
            (is (= 0 (count (storage/get-undelivered-messages ios-session-id))))

            ;; Attempt replay
            (reset! sent-messages [])
            (server/replay-undelivered-messages! :test-channel ios-session-id)

            ;; Verify no messages sent
            (is (= 0 (count @sent-messages)) "Should not send any messages when queue empty")))

        (finally
          (let [file (io/file test-path)]
            (when (.exists file)
              (.delete file))
            (when-let [parent (.getParentFile file)]
              (when (.exists parent)
                (.delete parent)))))))))

(deftest test-session-lifecycle
  (testing "Sessions persist across simulated server restarts"
    (let [test-path (str (System/getProperty "java.io.tmpdir")
                         "/voice-code-server-test-"
                         (System/currentTimeMillis)
                         "/sessions.edn")]
      (try
        (with-redefs [storage/storage-file test-path]
          ;; Simulate server startup
          (reset! storage/sessions-atom {:sessions {}})
          (storage/ensure-storage-file test-path)
          (storage/initialize! test-path)

          ;; Create some sessions during server operation
          (let [ios-uuid-1 "ios-session-1"
                ios-uuid-2 "ios-session-2"]
            (storage/create-session! ios-uuid-1 "/project1")
            (storage/create-session! ios-uuid-2 "/project2")

            ;; Update sessions with activity
            (storage/update-session! ios-uuid-1 {:claude-session-id "claude-123"})
            (server/buffer-message! ios-uuid-1 :assistant "Response 1" "claude-123")
            (server/buffer-message! ios-uuid-2 :assistant "Response 2" nil)

            ;; Verify sessions exist
            (is (= 2 (count (:sessions @storage/sessions-atom))))

            ;; Simulate graceful shutdown - save sessions
            (storage/save-sessions! @storage/sessions-atom test-path)

            ;; Verify file was written
            (is (.exists (io/file test-path)))

            ;; Simulate server restart - clear memory
            (reset! storage/sessions-atom {:sessions {}})
            (reset! server/channel-to-session {})

            ;; Verify memory is empty
            (is (= 0 (count (:sessions @storage/sessions-atom))))

            ;; Simulate server startup - load from disk
            (storage/initialize! test-path)

            ;; Verify sessions were restored
            (is (= 2 (count (:sessions @storage/sessions-atom)))
                "Should restore 2 sessions from disk")

            ;; Verify session data is intact
            (let [session1 (storage/get-session ios-uuid-1)
                  session2 (storage/get-session ios-uuid-2)]
              (is (= "claude-123" (:claude-session-id session1))
                  "Session 1 should have Claude session ID")
              (is (= "/project1" (:working-directory session1))
                  "Session 1 should have working directory")
              (is (= 1 (count (:undelivered-messages session1)))
                  "Session 1 should have 1 undelivered message")
              (is (nil? (:claude-session-id session2))
                  "Session 2 should have nil Claude session ID")
              (is (= 1 (count (:undelivered-messages session2)))
                  "Session 2 should have 1 undelivered message"))))

        (finally
          (let [file (io/file test-path)]
            (when (.exists file)
              (.delete file))
            (when-let [parent (.getParentFile file)]
              (when (.exists parent)
                (.delete parent))))))))

  (testing "Session metadata tracked correctly"
    (let [test-path (str (System/getProperty "java.io.tmpdir")
                         "/voice-code-server-test-"
                         (System/currentTimeMillis)
                         "/sessions.edn")]
      (try
        (with-redefs [storage/storage-file test-path]
          (reset! storage/sessions-atom {:sessions {}})
          (storage/ensure-storage-file test-path)

          (let [ios-uuid "metadata-test-uuid"
                session (storage/create-session! ios-uuid "/tmp")]
            ;; Verify initial metadata
            (is (some? (:created-at session)) "Should have created-at timestamp")
            (is (some? (:last-active session)) "Should have initial last-active timestamp")

            (let [initial-last-active (:last-active session)]
              ;; Wait a bit to ensure timestamp difference
              (Thread/sleep 10)

              ;; Update session
              (storage/update-session! ios-uuid {:claude-session-id "new-id"})

              ;; Verify last-active was updated
              (let [updated-session (storage/get-session ios-uuid)]
                (is (.after (:last-active updated-session) initial-last-active)
                    "last-active should be updated on session update")
                (is (= (:created-at session) (:created-at updated-session))
                    "created-at should not change on update")))))

        (finally
          (let [file (io/file test-path)]
            (when (.exists file)
              (.delete file))
            (when-let [parent (.getParentFile file)]
              (when (.exists parent)
                (.delete parent)))))))))

;; ============================================================================
;; New Protocol Handler Tests (Session Replication)
;; ============================================================================

(deftest test-broadcast-functions
  (testing "Broadcast to all clients"
    (reset! server/connected-clients {:ch1 {:deleted-sessions #{}}
                                      :ch2 {:deleted-sessions #{}}})
    (let [sent-messages (atom {})]
      (with-redefs [org.httpkit.server/send! (fn [channel msg]
                                               (swap! sent-messages assoc channel msg))]
        (server/broadcast-to-all-clients! {:type "test" :data "hello"})

        ;; Verify both clients received message
        (is (= 2 (count @sent-messages)))
        (is (contains? @sent-messages :ch1))
        (is (contains? @sent-messages :ch2))

        ;; Verify message content
        (let [msg1 (json/parse-string (get @sent-messages :ch1) true)]
          (is (= "test" (:type msg1)))
          (is (= "hello" (:data msg1)))))))

  (testing "Send to specific client"
    (reset! server/connected-clients {:ch1 {:deleted-sessions #{}}})
    (let [sent-message (atom nil)]
      (with-redefs [org.httpkit.server/send! (fn [channel msg]
                                               (reset! sent-message msg))]
        (server/send-to-client! :ch1 {:type "test" :data "specific"})

        ;; Verify message sent
        (is (some? @sent-message))
        (let [msg (json/parse-string @sent-message true)]
          (is (= "test" (:type msg)))
          (is (= "specific" (:data msg))))

        ;; Try sending to non-existent client
        (reset! sent-message nil)
        (server/send-to-client! :ch-nonexistent {:type "test"})
        (is (nil? @sent-message) "Should not send to non-existent client")))))

(deftest test-session-deletion-tracking
  (testing "Mark session as deleted for client"
    (reset! server/connected-clients {:ch1 {:deleted-sessions #{}}})

    ;; Initially not deleted
    (is (not (server/is-session-deleted-for-client? :ch1 "session-1")))

    ;; Mark as deleted
    (server/mark-session-deleted-for-client! :ch1 "session-1")

    ;; Verify marked as deleted
    (is (server/is-session-deleted-for-client? :ch1 "session-1"))
    (is (not (server/is-session-deleted-for-client? :ch1 "session-2")))

    ;; Multiple deletions
    (server/mark-session-deleted-for-client! :ch1 "session-2")
    (is (server/is-session-deleted-for-client? :ch1 "session-1"))
    (is (server/is-session-deleted-for-client? :ch1 "session-2")))

  (testing "Deleted sessions are client-specific"
    (reset! server/connected-clients {:ch1 {:deleted-sessions #{}}
                                      :ch2 {:deleted-sessions #{}}})

    ;; Mark deleted for ch1 only
    (server/mark-session-deleted-for-client! :ch1 "session-1")

    ;; Verify only ch1 sees it as deleted
    (is (server/is-session-deleted-for-client? :ch1 "session-1"))
    (is (not (server/is-session-deleted-for-client? :ch2 "session-1")))))

(deftest test-watcher-callbacks
  (testing "on-session-created broadcasts to all clients"
    (reset! server/connected-clients {:ch1 {:deleted-sessions #{}}
                                      :ch2 {:deleted-sessions #{}}})
    (let [sent-messages (atom {})]
      (with-redefs [org.httpkit.server/send! (fn [channel msg]
                                               (swap! sent-messages assoc channel msg))]
        (server/on-session-created {:session-id "new-session-123"
                                    :name "Test Session"
                                    :working-directory "/tmp"
                                    :last-modified 1234567890
                                    :message-count 0
                                    :preview ""})

        ;; Verify broadcast to both clients
        (is (= 2 (count @sent-messages)))

        ;; Verify message format
        (let [msg (json/parse-string (get @sent-messages :ch1) true)]
          (is (= "session-created" (:type msg)))
          (is (= "new-session-123" (:session_id msg)))
          (is (= "Test Session" (:name msg)))))))

  (testing "on-session-updated respects deleted sessions"
    (reset! server/connected-clients {:ch1 {:deleted-sessions #{"session-1"}}
                                      :ch2 {:deleted-sessions #{}}})
    (let [sent-messages (atom {})]
      (with-redefs [org.httpkit.server/send! (fn [channel msg]
                                               (swap! sent-messages assoc channel msg))]
        (server/on-session-updated "session-1" [{:role "user" :text "test"}])

        ;; ch1 deleted it, should not receive update
        (is (not (contains? @sent-messages :ch1)))

        ;; ch2 should receive update
        (is (contains? @sent-messages :ch2))
        (let [msg (json/parse-string (get @sent-messages :ch2) true)]
          (is (= "session-updated" (:type msg)))
          (is (= "session-1" (:session_id msg)))
          (is (= 1 (count (:messages msg)))))))))

(deftest test-new-protocol-connect
  (testing "Connect message returns session list"
    (with-redefs [voice-code.replication/get-all-sessions
                  (fn [] [{:session-id "s1" :name "Session 1"}
                          {:session-id "s2" :name "Session 2"}])]
      (reset! server/connected-clients {})
      (let [sent-message (atom nil)]
        (with-redefs [org.httpkit.server/send! (fn [channel msg]
                                                 (reset! sent-message msg))]
          (server/handle-message :test-ch "{\"type\":\"connect\"}")

          ;; Verify client registered
          (is (contains? @server/connected-clients :test-ch))

          ;; Verify session list sent
          (is (some? @sent-message))
          (let [msg (json/parse-string @sent-message true)]
            (is (= "session-list" (:type msg)))
            (is (= 2 (count (:sessions msg))))
            (is (= "s1" (:session_id (first (:sessions msg)))))))))))

(deftest test-prompt-session-id-distinction
  (testing "Prompt with new_session_id uses --session-id flag"
    (let [claude-args (atom nil)]
      (with-redefs [voice-code.claude/invoke-claude-async
                    (fn [prompt callback & {:keys [new-session-id resume-session-id]}]
                      (reset! claude-args {:new-session-id new-session-id
                                           :resume-session-id resume-session-id})
                      ;; Call callback immediately for test
                      (callback {:success true :session-id "test-123"}))
                    org.httpkit.server/send! (fn [_ _] nil)]
        (server/handle-message :test-ch "{\"type\":\"prompt\",\"text\":\"hello\",\"new_session_id\":\"new-123\"}")

        (is (= "new-123" (:new-session-id @claude-args)))
        (is (nil? (:resume-session-id @claude-args))))))

  (testing "Prompt with resume_session_id uses --resume flag"
    (let [claude-args (atom nil)]
      (with-redefs [voice-code.claude/invoke-claude-async
                    (fn [prompt callback & {:keys [new-session-id resume-session-id]}]
                      (reset! claude-args {:new-session-id new-session-id
                                           :resume-session-id resume-session-id})
                      ;; Call callback immediately for test
                      (callback {:success true :session-id "test-456"}))
                    org.httpkit.server/send! (fn [_ _] nil)]
        (server/handle-message :test-ch "{\"type\":\"prompt\",\"text\":\"continue\",\"resume_session_id\":\"resume-456\"}")

        (is (nil? (:new-session-id @claude-args)))
        (is (= "resume-456" (:resume-session-id @claude-args)))))))

