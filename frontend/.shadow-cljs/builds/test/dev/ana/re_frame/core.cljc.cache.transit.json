["^ ","~:output",["^ ","~:js","goog.provide('re_frame.core');\n/**\n * Queue `event` for processing (handling).\n * \n *   `event` is a vector and the first element is typically a keyword\n *   which identifies the kind of event.\n * \n *   The event will be added to a FIFO processing queue, so event\n *   handling does not happen immediately. It will happen 'very soon'\n *   but not now. And if the queue already contains events, they\n *   will be processed first.\n * \n *   Usage:\n * \n *    #!clj\n *    (dispatch [:order \"pizza\" {:supreme 2 :meatlovers 1 :veg 1}])\n *   \n */\nre_frame.core.dispatch = (function re_frame$core$dispatch(event){\nreturn re_frame.router.dispatch(event);\n});\n/**\n * Synchronously (immediately) process `event`. It does **not** queue\n *   the event for handling later as `dispatch` does.\n * \n *   `event` is a vector and the first element is typically a keyword\n *   which identifies the kind of event.\n * \n *   It is an error to use `dispatch-sync` within an event handler because\n *   you can't immediately process an new event when one is already\n *   part way through being processed.\n * \n *   Generally, avoid using this function, and instead, use `dispatch`.\n *   Only use it in the narrow set of cases where any delay in\n *   processing is a problem:\n * \n *  1. the `:on-change` handler of a text field where we are expecting fast typing\n *  2. when initialising your app - see 'main' in examples/todomvc/src/core.cljs\n *  3. in a unit test where immediate, synchronous processing is useful\n * \n *   Usage:\n * \n *    #!clj\n *    (dispatch-sync [:sing :falsetto \"piano accordion\"])\n *   \n */\nre_frame.core.dispatch_sync = (function re_frame$core$dispatch_sync(event){\nreturn re_frame.router.dispatch_sync(event);\n});\n/**\n * Register the given event `handler` (function) for the given `id`. Optionally, provide\n *   an `interceptors` chain:\n * \n *  - `id` is typically a namespaced keyword  (but can be anything)\n *  - `handler` is a function: (db event) -> db\n *  - `interceptors` is a collection of interceptors. Will be flattened and nils removed.\n * \n *   Example Usage:\n * \n *    #!clj\n *    (reg-event-db\n *      :token\n *      (fn [db event]\n *        (assoc db :some-key (get event 2)))  ;; return updated db\n * \n *   Or perhaps:\n * \n *    #!clj\n *    (reg-event-db\n *      :namespaced/id           ;; <-- namespaced keywords are often used\n *      [one two three]          ;; <-- a seq of interceptors\n *      (fn [db [_ arg1 arg2]]   ;; <-- event vector is destructured\n *        (-> db\n *          (dissoc arg1)\n *          (update :key + arg2))))   ;; return updated db\n *   \n */\nre_frame.core.reg_event_db = (function re_frame$core$reg_event_db(var_args){\nvar G__11373 = arguments.length;\nswitch (G__11373) {\ncase 2:\nreturn re_frame.core.reg_event_db.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ncase 3:\nreturn re_frame.core.reg_event_db.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ndefault:\nthrow (new Error([\"Invalid arity: \",arguments.length].join(\"\")));\n\n}\n});\n\n(re_frame.core.reg_event_db.cljs$core$IFn$_invoke$arity$2 = (function (id,handler){\nreturn re_frame.core.reg_event_db.cljs$core$IFn$_invoke$arity$3(id,null,handler);\n}));\n\n(re_frame.core.reg_event_db.cljs$core$IFn$_invoke$arity$3 = (function (id,interceptors,handler){\nreturn re_frame.events.register(id,new cljs.core.PersistentVector(null, 5, 5, cljs.core.PersistentVector.EMPTY_NODE, [re_frame.cofx.inject_db,re_frame.fx.do_fx,re_frame.std_interceptors.inject_global_interceptors,interceptors,re_frame.std_interceptors.db_handler__GT_interceptor(handler)], null));\n}));\n\n(re_frame.core.reg_event_db.cljs$lang$maxFixedArity = 3);\n\n/**\n * Register the given event `handler` (function) for the given `id`. Optionally, provide\n *   an `interceptors` chain:\n * \n *  - `id` is typically a namespaced keyword  (but can be anything)\n *  - `handler` is a function: (coeffects-map event-vector) -> effects-map\n *  - `interceptors` is a collection of interceptors. Will be flattened and nils removed.\n * \n * \n *   Example Usage:\n * \n *    #!clj\n *    (reg-event-fx\n *      :event-id\n *      (fn [cofx event]\n *        {:db (assoc (:db cofx) :some-key (get event 2))}))   ;; return a map of effects\n * \n * \n *   Or perhaps:\n * \n *    #!clj\n *    (reg-event-fx\n *      :namespaced/id           ;; <-- namespaced keywords are often used\n *      [one two three]          ;; <-- a seq of interceptors\n *      (fn [{:keys [db] :as cofx} [_ arg1 arg2]] ;; destructure both arguments\n *        {:db (assoc db :some-key arg1)          ;; return a map of effects\n *         :fx [[:dispatch [:some-event arg2]]]}))\n *   \n */\nre_frame.core.reg_event_fx = (function re_frame$core$reg_event_fx(var_args){\nvar G__11382 = arguments.length;\nswitch (G__11382) {\ncase 2:\nreturn re_frame.core.reg_event_fx.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ncase 3:\nreturn re_frame.core.reg_event_fx.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ndefault:\nthrow (new Error([\"Invalid arity: \",arguments.length].join(\"\")));\n\n}\n});\n\n(re_frame.core.reg_event_fx.cljs$core$IFn$_invoke$arity$2 = (function (id,handler){\nreturn re_frame.core.reg_event_fx.cljs$core$IFn$_invoke$arity$3(id,null,handler);\n}));\n\n(re_frame.core.reg_event_fx.cljs$core$IFn$_invoke$arity$3 = (function (id,interceptors,handler){\nreturn re_frame.events.register(id,new cljs.core.PersistentVector(null, 5, 5, cljs.core.PersistentVector.EMPTY_NODE, [re_frame.cofx.inject_db,re_frame.fx.do_fx,re_frame.std_interceptors.inject_global_interceptors,interceptors,re_frame.std_interceptors.fx_handler__GT_interceptor(handler)], null));\n}));\n\n(re_frame.core.reg_event_fx.cljs$lang$maxFixedArity = 3);\n\n/**\n * Register the given event `handler` (function) for the given `id`. Optionally, provide\n *   an `interceptors` chain:\n * \n *  - `id` is typically a namespaced keyword  (but can be anything)\n *  - `handler` is a function: context-map -> context-map\n * \n *   You can explore what is provided in `context` [here](https://day8.github.io/re-frame/Interceptors/#what-is-context).\n * \n *   Example Usage:\n * \n *    #!clj\n *    (reg-event-ctx\n *      :event-id\n *      (fn [{:keys [coeffects] :as context}]\n *        (let [initial  {:db     (:db coeffects)\n *                        :event  (:event coeffects)\n *                        :fx     []}\n *              result   (-> initial\n *                           function1\n *                           function2\n *                           function3)\n *              effects  (select-keys result [:db :fx])]\n *           (assoc context :effects effects))))\n *   \n */\nre_frame.core.reg_event_ctx = (function re_frame$core$reg_event_ctx(var_args){\nvar G__11394 = arguments.length;\nswitch (G__11394) {\ncase 2:\nreturn re_frame.core.reg_event_ctx.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ncase 3:\nreturn re_frame.core.reg_event_ctx.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ndefault:\nthrow (new Error([\"Invalid arity: \",arguments.length].join(\"\")));\n\n}\n});\n\n(re_frame.core.reg_event_ctx.cljs$core$IFn$_invoke$arity$2 = (function (id,handler){\nreturn re_frame.core.reg_event_ctx.cljs$core$IFn$_invoke$arity$3(id,null,handler);\n}));\n\n(re_frame.core.reg_event_ctx.cljs$core$IFn$_invoke$arity$3 = (function (id,interceptors,handler){\nreturn re_frame.events.register(id,new cljs.core.PersistentVector(null, 5, 5, cljs.core.PersistentVector.EMPTY_NODE, [re_frame.cofx.inject_db,re_frame.fx.do_fx,re_frame.std_interceptors.inject_global_interceptors,interceptors,re_frame.std_interceptors.ctx_handler__GT_interceptor(handler)], null));\n}));\n\n(re_frame.core.reg_event_ctx.cljs$lang$maxFixedArity = 3);\n\n/**\n * Unregisters event handlers (presumably registered previously via the use of `reg-event-db` or `reg-event-fx`).\n * \n *   When called with no args, it will unregister all currently registered event handlers.\n * \n *   When given one arg, assumed to be the `id` of a previously registered\n *   event handler, it will unregister the associated handler. Will produce a warning to\n *   console if it finds no matching registration.\n */\nre_frame.core.clear_event = (function re_frame$core$clear_event(var_args){\nvar G__11436 = arguments.length;\nswitch (G__11436) {\ncase 0:\nreturn re_frame.core.clear_event.cljs$core$IFn$_invoke$arity$0();\n\nbreak;\ncase 1:\nreturn re_frame.core.clear_event.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ndefault:\nthrow (new Error([\"Invalid arity: \",arguments.length].join(\"\")));\n\n}\n});\n\n(re_frame.core.clear_event.cljs$core$IFn$_invoke$arity$0 = (function (){\nreturn re_frame.registrar.clear_handlers.cljs$core$IFn$_invoke$arity$1(re_frame.events.kind);\n}));\n\n(re_frame.core.clear_event.cljs$core$IFn$_invoke$arity$1 = (function (id){\nreturn re_frame.registrar.clear_handlers.cljs$core$IFn$_invoke$arity$2(re_frame.events.kind,id);\n}));\n\n(re_frame.core.clear_event.cljs$lang$maxFixedArity = 1);\n\n/**\n * A call to `reg-sub` associates a `query-id` WITH two functions.\n * \n *   The two functions provide 'a mechanism' for creating a node\n *   in the Signal Graph. When a node of type `query-id` is needed,\n *   the two functions can be used to create it.\n * \n *   The three arguments are:\n * \n *  - `query-id` - typically a namespaced keyword (later used in subscribe)\n *  - optionally, an `input signals` function which returns the input data\n *    flows required by this kind of node.\n *  - a `computation function` which computes the value (output) of the\n *    node (from the input data flows)\n * \n *   Later, during app execution, a call to `(subscribe [:sub-id 3 :blue])`,\n *   will trigger the need for a new `:sub-id` Signal Graph node (matching the\n *   query `[:sub-id 3 :blue]`). And, to create that node the two functions\n *   associated with `:sub-id` will be looked up and used.\n * \n *   Just to be clear: calling `reg-sub` does not immediately create a node.\n *   It only registers 'a mechanism' (the two functions) by which nodes\n *   can be created later, when a node is bought into existence by the\n *   use of `subscribe` in a `View Function`.\n * \n *   `reg-sub` arguments are:\n * \n *  - a `query-id` (typically a namespaced keyword)\n *  - a function which returns the inputs required by this kind of node (can be supplied  in one of three ways)\n *  - a function which computes the value of this kind of node (can be supplied in one of three ways)\n * \n *   The `computation function` is always the last argument supplied and has three ways to be called.\n *   Two of these methods are syntactic sugar to provide easier access to functional abstractions around your data.\n * \n *   1. A function that will accept two parameters, the `input-values` and `query-vector`. This is the\n *   standard way to provide a `computation-function`\n * \n *        #!clj\n *        (reg-sub\n *          :query-id\n *          (fn [input-values query-vector]\n *            (:foo input-values)))\n * \n *   2. A single sugary tuple of `:->` and a 1-arity `computation-function`:\n * \n *        #!clj\n *        (reg-sub\n *          :query-id\n *          :-> computation-fn)\n * \n *    This sugary variation allows you to pass a function that will expect only one parameter,\n *    namely the `input-values` and entirely omit the `query-vector`. A typical `computation-function`\n *    expects two parameters which can cause unfortunate results when attempting to use\n *    clojure standard library functions, or other functions, in a functional manner.\n * \n *    For example, a significant number of subscriptions exist only to get a value\n *    from the `input-values`. As shown below, this subscription will simply retrieve\n *    the value associated with the `:foo` key in our db:\n * \n *        #!clj\n *        (reg-sub\n *          :query-id\n *          (fn [db _]    ;; :<---- trivial boilerplate we might want to skip over\n *            (:foo db)))\n * \n *    This is slightly more boilerplate than we might like to do,\n *    as we can use a keyword directly as a function, and we might like to do this:\n * \n *        #!clj\n *        (reg-sub\n *          :query-id\n *          :foo)  ;; :<---- This could be dangerous. If `:foo` is not in db, we get the `query-vector` instead of `nil`.\n * \n *    By using `:->` our function would not contain the `query-vector`, and any\n *    missing keys would be represented as such:\n * \n *        #!clj\n *        (reg-sub\n *          :query-id\n *          :-> :foo)\n * \n *    This form allows us to ignore the `query-vector` if our `computation-function`\n *    has no need for it, and be safe from any accidents. Any 1-arity function can be provided,\n *    and for more complicated use cases, `partial`, `comp`, and anonymous functions can still be used.\n * \n *   3. A single sugary tuple of `:=>` and a multi-arity `computation-function`\n * \n *        #!clj\n *        (reg-sub\n *          :query-id\n *          :=> computation-fn)\n * \n *    The `query-vector` can be broken into two components `[query-id & optional-values]`, and\n *    some subscriptions require the `optional-values` for extra work within the subscription.\n *    To use them in variation #1, we need to destructure our `computation-function` parameters\n *    in order to use them.\n * \n *        #!clj\n *        (reg-sub\n *          :query-id\n *          (fn [db [_ foo]]\n *            [db foo]))\n * \n *    Again we are writing boilerplate just to reach our values, and we might prefer to\n *    have direction access through a parameter vector like `[input-values optional-values]`\n *    instead, so we might be able to use a multi-arity function directly as our `computation-function`.\n *    A rewrite of the above sub using this sugary syntax would look like this:\n * \n *        #!clj\n *        (reg-sub\n *          :query-id\n *          :=> vector)  ;; :<---- Could also be `(fn [db foo] [db foo])`\n * \n *   The `computation function` is expected to take two arguments:\n * \n *  - `input-values` - the values which flow into this node (how is it wired into the graph?)\n *  - `query-vector` - the vector given to `subscribe`\n * \n *   and it returns a computed value (which then becomes the output of the node)\n * \n *   When `computation function` is called, the 2nd `query-vector` argument will be that\n *   vector supplied to the `subscribe`. So, if the call was `(subscribe [:sub-id 3 :blue])`,\n *   then the `query-vector` supplied to the computation function will be `[:sub-id 3 :blue]`.\n * \n *   The argument(s) supplied to `reg-sub` between `query-id` and the `computation-function`\n *   can vary in 3 ways, but whatever is there defines the `input signals` part\n *   of `the mechanism`, specifying what input values \"flow into\" the\n *   `computation function` (as the 1st argument) when it is called.\n * \n *   So, `reg-sub` can be called in one of three ways, because there are three ways\n *   to define the input signals part. But note, the 2nd method, in which a\n *   `signals function` is explicitly supplied, is the most canonical and\n *   instructive. The other two are really just sugary variations.\n * \n *   **First variation** - no input signal function given:\n * \n *    #!clj\n *    (reg-sub\n *      :query-id\n *      a-computation-fn)   ;; has signature:  (fn [db query-vec]  ... ret-value)\n * \n *   In the absence of an explicit `signals function`, the node's input signal defaults to `app-db`\n *   and, as a result, the value within `app-db` (a map) is\n *   given as the 1st argument when `a-computation-fn` is called.\n * \n * \n *   **Second variation** - a signal function is explicitly supplied:\n * \n *    #!clj\n *    (reg-sub\n *      :query-id\n *      signal-fn     ;; <-- here\n *      computation-fn)\n * \n *   This is the most canonical and instructive of the three variations.\n * \n *   When a node is created from the template, the `signal function` will be called and it\n *   is expected to return the input signal(s) as either a singleton, if there is only\n *   one, or a sequence if there are many, or a map with the signals as the values.\n * \n *   The current values of the returned signals will be supplied as the 1st argument to\n *   the `a-computation-fn` when it is called - and subject to what this `signal-fn` returns,\n *   this value will be either a singleton, sequence or map of them (paralleling\n *   the structure returned by the `signal function`).\n * \n *   This example `signal function` returns a 2-vector of input signals.\n * \n *    #!clj\n *    (fn [query-vec dynamic-vec]\n *       [(subscribe [:a-sub])\n *        (subscribe [:b-sub])])\n * \n *   The associated computation function must be written\n *   to expect a 2-vector of values for its first argument:\n * \n *    #!clj\n *    (fn [[a b] query-vec]     ;; 1st argument is a seq of two values\n *      ....)\n * \n *   If, on the other hand, the signal function was simpler and returned a singleton, like this:\n * \n *    #!clj\n *    (fn [query-vec dynamic-vec]\n *      (subscribe [:a-sub]))      ;; <-- returning a singleton\n * \n *   then the associated computation function must be written to expect a single value\n *   as the 1st argument:\n * \n *    #!clj\n *    (fn [a query-vec]       ;; 1st argument is a single value\n *       ...)\n * \n *   Further Note: variation #1 above, in which an `signal-fn` was not supplied, like this:\n * \n *    #!clj\n *    (reg-sub\n *      :query-id\n *      a-computation-fn)   ;; has signature:  (fn [db query-vec]  ... ret-value)\n * \n *   is the equivalent of using this\n *   2nd variation and explicitly supplying a `signal-fn` which returns `app-db`:\n * \n *    #!clj\n *    (reg-sub\n *      :query-id\n *      (fn [_ _]  re-frame/app-db)   ;; <--- explicit signal-fn\n *      a-computation-fn)             ;; has signature:  (fn [db query-vec]  ... ret-value)\n * \n *   **Third variation** - syntax Sugar\n * \n *    #!clj\n *    (reg-sub\n *      :a-b-sub\n *      :<- [:a-sub]\n *      :<- [:b-sub]\n *      (fn [[a b] query-vec]    ;; 1st argument is a seq of two values\n *        {:a a :b b}))\n * \n *   This 3rd variation is just syntactic sugar for the 2nd.  Instead of providing an\n *   `signals-fn` you provide one or more pairs of `:<-` and a subscription vector.\n * \n *   If you supply only one pair a singleton will be supplied to the computation function,\n *   as if you had supplied a `signal-fn` returning only a single value:\n * \n *    #!clj\n *    (reg-sub\n *      :a-sub\n *      :<- [:a-sub]\n *      (fn [a query-vec]      ;; only one pair, so 1st argument is a single value\n *        ...))\n * \n *   Syntactic sugar for both the `signal-fn` and `computation-fn` can be used together\n *   and the direction of arrows shows the flow of data and functions. The example from\n *   directly above is reproduced here:\n * \n *    #!clj\n *    (reg-sub\n *      :a-b-sub\n *      :<- [:a-sub]\n *      :<- [:b-sub]\n *      :-> (partial zipmap [:a :b]))\n * \n *   For further understanding, read the tutorials, and look at the detailed comments in\n *   /examples/todomvc/src/subs.cljs.\n * \n *   See also: `subscribe`\n *   \n */\nre_frame.core.reg_sub = (function re_frame$core$reg_sub(var_args){\nvar args__5882__auto__ = [];\nvar len__5876__auto___11882 = arguments.length;\nvar i__5877__auto___11884 = (0);\nwhile(true){\nif((i__5877__auto___11884 < len__5876__auto___11882)){\nargs__5882__auto__.push((arguments[i__5877__auto___11884]));\n\nvar G__11885 = (i__5877__auto___11884 + (1));\ni__5877__auto___11884 = G__11885;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar argseq__5883__auto__ = ((((1) < args__5882__auto__.length))?(new cljs.core.IndexedSeq(args__5882__auto__.slice((1)),(0),null)):null);\nreturn re_frame.core.reg_sub.cljs$core$IFn$_invoke$arity$variadic((arguments[(0)]),argseq__5883__auto__);\n});\n\n(re_frame.core.reg_sub.cljs$core$IFn$_invoke$arity$variadic = (function (query_id,args){\nreturn cljs.core.apply.cljs$core$IFn$_invoke$arity$3(re_frame.subs.reg_sub,query_id,args);\n}));\n\n(re_frame.core.reg_sub.cljs$lang$maxFixedArity = (1));\n\n/** @this {Function} */\n(re_frame.core.reg_sub.cljs$lang$applyTo = (function (seq11483){\nvar G__11484 = cljs.core.first(seq11483);\nvar seq11483__$1 = cljs.core.next(seq11483);\nvar self__5861__auto__ = this;\nreturn self__5861__auto__.cljs$core$IFn$_invoke$arity$variadic(G__11484,seq11483__$1);\n}));\n\n/**\n * Given a `query` vector, returns a Reagent `reaction` which will, over\n *   time, reactively deliver a stream of values. So, in FRP-ish terms,\n *   it returns a `Signal`.\n * \n *   To obtain the current value from the Signal, it must be dereferenced:\n * \n *    #!clj\n *    (let [signal (subscribe [:items])\n *          value  (deref signal)]     ;; could be written as @signal\n *      ...)\n * \n * which is typically written tersely as simple:\n * \n *    #!clj\n *    (let [items  @(subscribe [:items])]\n *      ...)\n * \n * \n *   `query` is a vector of at least one element. The first element is the\n *   `query-id`, typically a namespaced keyword. The rest of the vector's\n *   elements are optional, additional values which parameterise the query\n *   performed.\n * \n *   `dynv` exists for historical reasons and is borderline deprecated these days.\n *   It is a vector of signals. Re-frame will dereference each of them and pass a\n *   vector of their values to your subscription handler as a third argument.\n *   If there's logic determing __what__ query to subscribe __to__, consider\n *   expressing it in a `signal function`, or use `reg-sub-raw`. Failing that, `dynv`\n *   allows you to colocate this logic with the `subscribe` call.\n * \n *   **Example Usage**:\n * \n *    #!clj\n *    (subscribe [:items])\n *    (subscribe [:items \"blue\" :small])\n *    (subscribe [:items {:colour \"blue\"  :size :small}])\n * \n *   Note: for any given call to `subscribe` there must have been a previous call\n *   to `reg-sub`, registering the query handler (functions) associated with\n *   `query-id`.\n * \n *   **Hint**\n * \n *   When used in a view function BE SURE to `deref` the returned value.\n *   In fact, to avoid any mistakes, some prefer to define:\n * \n *    #!clj\n *    (def <sub  (comp deref re-frame.core/subscribe))\n * \n *   And then, within their views, they call  `(<sub [:items :small])` rather\n *   than using `subscribe` directly.\n * \n *   **De-duplication**\n * \n *   Two, or more, concurrent subscriptions for the same query will\n *   source reactive updates from the one executing handler.\n * \n *   See also: `reg-sub`\n *   \n */\nre_frame.core.subscribe = (function re_frame$core$subscribe(var_args){\nvar G__11536 = arguments.length;\nswitch (G__11536) {\ncase 1:\nreturn re_frame.core.subscribe.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase 2:\nreturn re_frame.core.subscribe.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ndefault:\nthrow (new Error([\"Invalid arity: \",arguments.length].join(\"\")));\n\n}\n});\n\n(re_frame.core.subscribe.cljs$core$IFn$_invoke$arity$1 = (function (query){\nreturn re_frame.subs.subscribe.cljs$core$IFn$_invoke$arity$1(query);\n}));\n\n(re_frame.core.subscribe.cljs$core$IFn$_invoke$arity$2 = (function (query,dynv){\nreturn re_frame.subs.subscribe.cljs$core$IFn$_invoke$arity$2(query,dynv);\n}));\n\n(re_frame.core.subscribe.cljs$lang$maxFixedArity = 2);\n\n/**\n * Unregisters subscription handlers (presumably registered previously via the use of `reg-sub`).\n * \n *   When called with no args, it will unregister all currently registered subscription handlers.\n * \n *   When given one arg, assumed to be the `id` of a previously registered\n *   subscription handler, it will unregister the associated handler. Will produce a warning to\n *   console if it finds no matching registration.\n * \n *   NOTE: Depending on the usecase, it may be necessary to call `clear-subscription-cache!` afterwards\n */\nre_frame.core.clear_sub = (function re_frame$core$clear_sub(var_args){\nvar G__11563 = arguments.length;\nswitch (G__11563) {\ncase 0:\nreturn re_frame.core.clear_sub.cljs$core$IFn$_invoke$arity$0();\n\nbreak;\ncase 1:\nreturn re_frame.core.clear_sub.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ndefault:\nthrow (new Error([\"Invalid arity: \",arguments.length].join(\"\")));\n\n}\n});\n\n(re_frame.core.clear_sub.cljs$core$IFn$_invoke$arity$0 = (function (){\nreturn re_frame.registrar.clear_handlers.cljs$core$IFn$_invoke$arity$1(re_frame.subs.kind);\n}));\n\n(re_frame.core.clear_sub.cljs$core$IFn$_invoke$arity$1 = (function (query_id){\nreturn re_frame.registrar.clear_handlers.cljs$core$IFn$_invoke$arity$2(re_frame.subs.kind,query_id);\n}));\n\n(re_frame.core.clear_sub.cljs$lang$maxFixedArity = 1);\n\n/**\n * This is a low level, advanced function.  You should probably be\n *   using `reg-sub` instead.\n * \n *   Some explanation is available in the docs at\n *   <a href=\"http://day8.github.io/re-frame/flow-mechanics/\" target=\"_blank\">http://day8.github.io/re-frame/flow-mechanics/</a>\n */\nre_frame.core.reg_sub_raw = (function re_frame$core$reg_sub_raw(query_id,handler_fn){\nreturn re_frame.registrar.register_handler(re_frame.subs.kind,query_id,handler_fn);\n});\n/**\n * Removes all subscriptions from the cache.\n * \n *   This function can be used at development time or test time. Useful when hot reloading\n *   namespaces containing subscription handlers. Also call it after a React/render exception,\n *   because React components won't have been cleaned up properly. And this, in turn, means\n *   the subscriptions within those components won't have been cleaned up correctly. So this\n *   forces the issue.\n *   \n */\nre_frame.core.clear_subscription_cache_BANG_ = (function re_frame$core$clear_subscription_cache_BANG_(){\nreturn re_frame.subs.clear_subscription_cache_BANG_();\n});\n/**\n * Register the given effect `handler` for the given `id`:\n * \n *  - `id` is keyword, often namespaced.\n *  - `handler` is a side-effecting function which takes a single argument and whose return\n *    value is ignored.\n * \n *   To use, first, associate `:effect2` with a handler:\n * \n *    #!clj\n *    (reg-fx\n *       :effect2\n *       (fn [value]\n *          ... do something side-effect-y))\n * \n *   Then, later, if an event handler were to return this effects map:\n * \n *    #!clj\n *    {:effect2  [1 2]}\n * \n *   then the `handler` `fn` we registered previously, using `reg-fx`, will be\n *   called with an argument of `[1 2]`.\n *   \n */\nre_frame.core.reg_fx = (function re_frame$core$reg_fx(id,handler){\nreturn re_frame.fx.reg_fx(id,handler);\n});\n/**\n * Unregisters effect handlers (presumably registered previously via the use of `reg-fx`).\n * \n *   When called with no args, it will unregister all currently registered effect handlers.\n * \n *   When given one arg, assumed to be the `id` of a previously registered\n *   effect handler, it will unregister the associated handler. Will produce a warning to\n *   console if it finds no matching registration.\n *   \n */\nre_frame.core.clear_fx = (function re_frame$core$clear_fx(var_args){\nvar G__11585 = arguments.length;\nswitch (G__11585) {\ncase 0:\nreturn re_frame.core.clear_fx.cljs$core$IFn$_invoke$arity$0();\n\nbreak;\ncase 1:\nreturn re_frame.core.clear_fx.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ndefault:\nthrow (new Error([\"Invalid arity: \",arguments.length].join(\"\")));\n\n}\n});\n\n(re_frame.core.clear_fx.cljs$core$IFn$_invoke$arity$0 = (function (){\nreturn re_frame.registrar.clear_handlers.cljs$core$IFn$_invoke$arity$1(re_frame.fx.kind);\n}));\n\n(re_frame.core.clear_fx.cljs$core$IFn$_invoke$arity$1 = (function (id){\nreturn re_frame.registrar.clear_handlers.cljs$core$IFn$_invoke$arity$2(re_frame.fx.kind,id);\n}));\n\n(re_frame.core.clear_fx.cljs$lang$maxFixedArity = 1);\n\n/**\n * Register the given coeffect `handler` for the given `id`, for later use\n *   within `inject-cofx`:\n * \n *  - `id` is keyword, often namespaced.\n *  - `handler` is a function which takes either one or two arguments, the first of which is\n *     always `coeffects` and which returns an updated `coeffects`.\n * \n *   See also: `inject-cofx`\n *   \n */\nre_frame.core.reg_cofx = (function re_frame$core$reg_cofx(id,handler){\nreturn re_frame.cofx.reg_cofx(id,handler);\n});\n/**\n * Given an `id`, and an optional, arbitrary `value`, returns an interceptor\n *   whose `:before` adds to the `:coeffects` (map) by calling a pre-registered\n *   'coeffect handler' identified by the `id`.\n * \n *   The previous association of a `coeffect handler` with an `id` will have\n *   happened via a call to `re-frame.core/reg-cofx` - generally on program startup.\n * \n *   Within the created interceptor, this 'looked up' `coeffect handler` will\n *   be called (within the `:before`) with two arguments:\n * \n *   - the current value of `:coeffects`\n *   - optionally, the originally supplied arbitrary `value`\n * \n *   This `coeffect handler` is expected to modify and return its first, `coeffects` argument.\n * \n *   **Example of `inject-cofx` and `reg-cofx` working together**\n * \n * \n *   First - Early in app startup, you register a `coeffect handler` for `:datetime`:\n * \n *    #!clj\n *    (re-frame.core/reg-cofx\n *      :datetime                        ;; usage  (inject-cofx :datetime)\n *      (fn coeffect-handler\n *        [coeffect]\n *        (assoc coeffect :now (js/Date.))))   ;; modify and return first arg\n * \n *   Second - Later, add an interceptor to an -fx event handler, using `inject-cofx`:\n * \n *    #!clj\n *    (re-frame.core/reg-event-fx            ;; when registering an event handler\n *      :event-id\n *      [ ... (inject-cofx :datetime) ... ]  ;; <-- create an injecting interceptor\n *      (fn event-handler\n *        [coeffect event]\n *          ;;... in here can access (:now coeffect) to obtain current datetime ...\n *        )))\n * \n *   **Background**\n * \n *   `coeffects` are the input resources required by an event handler\n *   to perform its job. The two most obvious ones are `db` and `event`.\n *   But sometimes an event handler might need other resources.\n * \n *   Perhaps an event handler needs a random number or a GUID or the current\n *   datetime. Perhaps it needs access to a DataScript database connection.\n * \n *   If an event handler directly accesses these resources, it stops being\n *   pure and, consequently, it becomes harder to test, etc. So we don't\n *   want that.\n * \n *   Instead, the interceptor created by this function is a way to 'inject'\n *   'necessary resources' into the `:coeffects` (map) subsequently given\n *   to the event handler at call time.\n * \n *   See also `reg-cofx`\n *   \n */\nre_frame.core.inject_cofx = (function re_frame$core$inject_cofx(var_args){\nvar G__11593 = arguments.length;\nswitch (G__11593) {\ncase 1:\nreturn re_frame.core.inject_cofx.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase 2:\nreturn re_frame.core.inject_cofx.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ndefault:\nthrow (new Error([\"Invalid arity: \",arguments.length].join(\"\")));\n\n}\n});\n\n(re_frame.core.inject_cofx.cljs$core$IFn$_invoke$arity$1 = (function (id){\nreturn re_frame.cofx.inject_cofx.cljs$core$IFn$_invoke$arity$1(id);\n}));\n\n(re_frame.core.inject_cofx.cljs$core$IFn$_invoke$arity$2 = (function (id,value){\nreturn re_frame.cofx.inject_cofx.cljs$core$IFn$_invoke$arity$2(id,value);\n}));\n\n(re_frame.core.inject_cofx.cljs$lang$maxFixedArity = 2);\n\n/**\n * Unregisters coeffect handlers (presumably registered previously via the use of `reg-cofx`).\n * \n *   When called with no args, it will unregister all currently registered coeffect handlers.\n * \n *   When given one arg, assumed to be the `id` of a previously registered\n *   coeffect handler, it will unregister the associated handler. Will produce a warning to\n *   console if it finds no matching registration.\n */\nre_frame.core.clear_cofx = (function re_frame$core$clear_cofx(var_args){\nvar G__11614 = arguments.length;\nswitch (G__11614) {\ncase 0:\nreturn re_frame.core.clear_cofx.cljs$core$IFn$_invoke$arity$0();\n\nbreak;\ncase 1:\nreturn re_frame.core.clear_cofx.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ndefault:\nthrow (new Error([\"Invalid arity: \",arguments.length].join(\"\")));\n\n}\n});\n\n(re_frame.core.clear_cofx.cljs$core$IFn$_invoke$arity$0 = (function (){\nreturn re_frame.registrar.clear_handlers.cljs$core$IFn$_invoke$arity$1(re_frame.cofx.kind);\n}));\n\n(re_frame.core.clear_cofx.cljs$core$IFn$_invoke$arity$1 = (function (id){\nreturn re_frame.registrar.clear_handlers.cljs$core$IFn$_invoke$arity$2(re_frame.cofx.kind,id);\n}));\n\n(re_frame.core.clear_cofx.cljs$lang$maxFixedArity = 1);\n\n/**\n * Register the given event error `handler` (function) that will catch unhandled exceptions\n *   thrown in the interceptors/handler chain.\n * \n *   Only one `handler` can be registered. Registering a new `handler` clears the existing `handler`.\n * \n *   This `handler` function has the signature:\n * \n *   `(handler [original-error re-frame-error])`\n * \n *   - `original-error`: A plaform-native Error object.\n *   Represents the original error thrown by user code.\n *   this is the error you see when no `handler` is registered.\n * \n *   - `re-frame-error`: A clojure ExceptionInfo object.\n *   Includes the stacktrace of re-frame's internal functions,\n *   and extra data about the interceptor process.\n *   Call `(ex-data re-frame-error)` to get this info.\n * \n *   The data includes:\n * \n *   - `:interceptor`: the `:id` of the throwing interceptor.\n *   - `:direction`: `:before` or `:after`.\n *   - `:event-v`: the re-frame event which invoked this interceptor.\n */\nre_frame.core.reg_event_error_handler = (function re_frame$core$reg_event_error_handler(handler){\nreturn re_frame.registrar.register_handler(new cljs.core.Keyword(null,\"error\",\"error\",-978969032),new cljs.core.Keyword(null,\"event-handler\",\"event-handler\",-487718843),handler);\n});\nre_frame.core.reg_event_error_handler(re_frame.interceptor.default_error_handler);\n/**\n * An interceptor which logs/instruments an event handler's actions to\n *   `re-frame/console` at the `:log` level.\n * \n *   Output includes:\n * \n *  1. the event vector\n *  2. a `clojure.data/diff` of db, before vs after, which shows\n *     the changes caused by the event handler. To understand the output,\n *     you should understand:\n *     <a href=\"https://clojuredocs.org/clojure.data/diff\" target=\"_blank\">https://clojuredocs.org/clojure.data/diff</a>.\n * \n *   You'd typically include this interceptor after (to the right of) any\n *   `path` interceptor.\n * \n *   Warning:  calling `clojure.data/diff` on large, complex data structures\n *   can be slow. So, you won't want this interceptor present in production\n *   code. So, you should condition it out like this:\n * \n *    #!clj\n *    (re-frame.core/reg-event-db\n *      :evt-id\n *      [(when ^boolean goog.DEBUG re-frame.core/debug)]  ;; <-- conditional\n *      (fn [db v]\n *         ...))\n * \n *   To make this code fragment work, you'll also have to set `goog.DEBUG` to\n *   `false` in your production builds. For an example, look in `project.clj` of /examples/todomvc.\n *   \n */\nre_frame.core.debug = re_frame.std_interceptors.debug;\n/**\n * Returns an interceptor which acts somewhat like `clojure.core/update-in`, in the sense that\n *   the event handler is given a specific part of `app-db` to change, not all of `app-db`.\n * \n *   The interceptor has both a `:before` and `:after` functions. The `:before` replaces\n *   the `:db` key within coeffects with a sub-path within `app-db`. The `:after` reverses the process,\n *   and it grafts the handler's return value back into db, at the right path.\n * \n *   Examples:\n * \n *    #!clj\n *    (path :some :path)\n *    (path [:some :path])\n *    (path [:some :path] :to :here)\n *    (path [:some :path] [:to] :here)\n * \n *   Example Use:\n * \n *    #!clj\n *    (reg-event-db\n *      :event-id\n *      (path [:a :b])  ;; <-- used here, in interceptor chain\n *      (fn [b v]       ;; 1st arg is not db. Is the value from path [:a :b] within db\n *        ... new-b))   ;; returns a new value for that path (not the entire db)\n * \n *   Notes:\n * \n *  1. `path` may appear more than once in an interceptor chain. Progressive narrowing.\n *  2. if `:effects` contains no `:db` effect, can't graft a value back in.\n *   \n */\nre_frame.core.path = (function re_frame$core$path(var_args){\nvar args__5882__auto__ = [];\nvar len__5876__auto___11903 = arguments.length;\nvar i__5877__auto___11906 = (0);\nwhile(true){\nif((i__5877__auto___11906 < len__5876__auto___11903)){\nargs__5882__auto__.push((arguments[i__5877__auto___11906]));\n\nvar G__11907 = (i__5877__auto___11906 + (1));\ni__5877__auto___11906 = G__11907;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar argseq__5883__auto__ = ((((0) < args__5882__auto__.length))?(new cljs.core.IndexedSeq(args__5882__auto__.slice((0)),(0),null)):null);\nreturn re_frame.core.path.cljs$core$IFn$_invoke$arity$variadic(argseq__5883__auto__);\n});\n\n(re_frame.core.path.cljs$core$IFn$_invoke$arity$variadic = (function (args){\nreturn cljs.core.apply.cljs$core$IFn$_invoke$arity$2(re_frame.std_interceptors.path,args);\n}));\n\n(re_frame.core.path.cljs$lang$maxFixedArity = (0));\n\n/** @this {Function} */\n(re_frame.core.path.cljs$lang$applyTo = (function (seq11621){\nvar self__5862__auto__ = this;\nreturn self__5862__auto__.cljs$core$IFn$_invoke$arity$variadic(cljs.core.seq(seq11621));\n}));\n\n/**\n * Returns an interceptor which will run the given function `f` in the `:after`\n *   position.\n * \n *   `f` is called with two arguments: `db` and `event`, and is expected to\n *   return a modified `db`.\n * \n *   Unlike the `after` interceptor which is only about side effects, `enrich`\n *   expects `f` to process and alter the given `db` coeffect in some useful way,\n *   contributing to the derived data, flowing vibe.\n * \n *   If `f` returns `nil`, the `db` value passed to `f` will be returned instead.\n * \n *   #### Example Use:\n * \n *   Imagine that todomvc needed to do duplicate detection - if any two todos had\n *   the same text, then highlight their background, and report them via a warning\n *   at the bottom of the panel.\n * \n *   Almost any user action (edit text, add new todo, remove a todo) requires a\n *   complete reassessment of duplication errors and warnings. E.g. that edit\n *   just made might have introduced a new duplicate, or removed one. Same with\n *   any todo removal. So we need to re-calculate warnings after any CRUD events\n *   associated with the todos list.\n * \n *   Unless we are careful, we might end up coding subtly different checks\n *   for each kind of CRUD operation.  The duplicates check made after\n *   'delete todo' event might be subtly different to that done after an\n *   editing operation. Nice and efficient, but fiddly. A bug generator\n *   approach.\n * \n *   So, instead, we create an `f` which recalculates ALL warnings from scratch\n *   every time there is ANY change. It will inspect all the todos, and\n *   reset ALL FLAGS every time (overwriting what was there previously)\n *   and fully recalculate the list of duplicates (displayed at the bottom?).\n * \n *   <a href=\"https://twitter.com/nathanmarz/status/879722740776939520\" target=\"_blank\">https://twitter.com/nathanmarz/status/879722740776939520</a>\n * \n *   By applying `f` in an `:enrich` interceptor, after every CRUD event,\n *   we keep the handlers simple and yet we ensure this important step\n *   (of getting warnings right) is not missed on any change.\n * \n *   We can test `f` easily - it is a pure function - independently of\n *   any CRUD operation.\n * \n *   This brings huge simplicity at the expense of some re-computation\n *   each time. This may be a very satisfactory trade-off in many cases.\n * \n *   #### Returning nil\n * \n *   In some cases, it's useful to apply a change to specific situations that can\n *   be determined at runtime instead of when defining the handler with an\n *   `:enrich` interceptor. Instead of forcing you to return the `db` from every\n *   non-applicable branch, you can return `nil` to use the given `db` value:\n * \n *    #!clj\n *    (def set-last-update\n *      (core/enrich\n *        (fn [{db :db} [_ {user :user}]]\n *          (when (active-user? user)  ;; <- Only perform an update if user is active\n *            ...))))\n *   \n */\nre_frame.core.enrich = (function re_frame$core$enrich(f){\nreturn re_frame.std_interceptors.enrich(f);\n});\n/**\n * > New in v1.2.0\n * \n * An interceptor which decreases the amount of destructuring necessary in an\n * event handler where the event is structured as a 2-vector of\n * [event-id payload-map].\n * \n * It promotes the `payload-map` part to be the event ultimately given to the\n * event handler. Should you want the full original event, it can be found in\n * `coeffects` under the key `:original-event`.\n * \n * If a dispatch looked like this:\n * \n *    #!clj\n *     (dispatch [:event-id {:x 1 :y 2 :z 3}])\n * \n * Your event handlers can look like this:\n * \n *    #!clj\n *     (reg-event-fx\n *       :event-id\n *       [... unwrap ...]                    ;; <-- added to the interceptors\n *       (fn [{:keys [db]} {:keys [x y z]}]  ;; <-- instead of [_ {:keys [x y z]}]\n *         ...)\n * \n */\nre_frame.core.unwrap = re_frame.std_interceptors.unwrap;\n/**\n * An interceptor which removes the first element of the event vector,\n *   before it is supplied to the event handler, allowing you to write more\n * aesthetically pleasing event handlers. No leading underscore on the event-v!\n * \n *   Should you want the full original event, it can be found in `coeffects` under\n *   the key `:original-event`.\n * \n *   Your event handlers will look like this:\n * \n *    #!clj\n *    (reg-event-db\n *      :event-id\n *      [... trim-v ...]    ;; <-- added to the interceptors\n *      (fn [db [x y z]]    ;; <-- instead of [_ x y z]\n *        ...)\n *  \n */\nre_frame.core.trim_v = re_frame.std_interceptors.trim_v;\n/**\n * Returns an interceptor which runs the given function `f` in the `:after`\n *   position, presumably for side effects.\n * \n *   `f` is called with two arguments: the `:effects` value for `:db`\n *   (or the `:coeffect` value of `:db` if no `:db` effect is returned) and the event.\n *   Its return value is ignored, so `f` can only side-effect.\n * \n *   An example of use can be seen in the re-frame github repo in `/examples/todomvc/events.cljs`:\n * \n *   - `f` runs schema validation (reporting any errors found).\n *   - `f` writes to localstorage.\n */\nre_frame.core.after = (function re_frame$core$after(f){\nreturn re_frame.std_interceptors.after(f);\n});\n/**\n * Returns an interceptor which will observe N paths within `db`, and if any of them\n *   test not `identical?` to their previous value  (as a result of a event handler\n *   being run), then it will run `f` to compute a new value, which is then assoc-ed\n *   into the given `out-path` within `db`.\n * \n *   Example Usage:\n * \n *    #!clj\n *    (defn my-f\n *      [a-val b-val]\n *      ... some computation on a and b in here)\n * \n *    ;; use it\n *    (def my-interceptor (on-changes my-f [:c] [:a] [:b]))\n * \n *    (reg-event-db\n *      :event-id\n *      [... my-interceptor ...]  ;; <-- ultimately used here\n *      (fn [db v]\n *         ...))\n * \n * \n *   If you put this interceptor on handlers which might change paths `:a` or `:b`,\n *   it will:\n * \n *  - call `f` each time the value at path `[:a]` or `[:b]` changes\n *  - call `f` with the values extracted from `[:a]` `[:b]`\n *  - assoc the return value from `f` into the path  `[:c]`\n *   \n */\nre_frame.core.on_changes = (function re_frame$core$on_changes(var_args){\nvar args__5882__auto__ = [];\nvar len__5876__auto___11909 = arguments.length;\nvar i__5877__auto___11912 = (0);\nwhile(true){\nif((i__5877__auto___11912 < len__5876__auto___11909)){\nargs__5882__auto__.push((arguments[i__5877__auto___11912]));\n\nvar G__11913 = (i__5877__auto___11912 + (1));\ni__5877__auto___11912 = G__11913;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar argseq__5883__auto__ = ((((2) < args__5882__auto__.length))?(new cljs.core.IndexedSeq(args__5882__auto__.slice((2)),(0),null)):null);\nreturn re_frame.core.on_changes.cljs$core$IFn$_invoke$arity$variadic((arguments[(0)]),(arguments[(1)]),argseq__5883__auto__);\n});\n\n(re_frame.core.on_changes.cljs$core$IFn$_invoke$arity$variadic = (function (f,out_path,in_paths){\nreturn cljs.core.apply.cljs$core$IFn$_invoke$arity$4(re_frame.std_interceptors.on_changes,f,out_path,in_paths);\n}));\n\n(re_frame.core.on_changes.cljs$lang$maxFixedArity = (2));\n\n/** @this {Function} */\n(re_frame.core.on_changes.cljs$lang$applyTo = (function (seq11645){\nvar G__11646 = cljs.core.first(seq11645);\nvar seq11645__$1 = cljs.core.next(seq11645);\nvar G__11647 = cljs.core.first(seq11645__$1);\nvar seq11645__$2 = cljs.core.next(seq11645__$1);\nvar self__5861__auto__ = this;\nreturn self__5861__auto__.cljs$core$IFn$_invoke$arity$variadic(G__11646,G__11647,seq11645__$2);\n}));\n\n/**\n * Registers the given `interceptor` as a global interceptor. Global interceptors are\n * included in the processing chain of every event.\n * \n * When you register an event handler, you have the option of supplying an\n * interceptor chain. Any global interceptors you register are effectively\n * prepending to this chain.\n * \n * Global interceptors are run in the order that they are registered.\n * \n * Global interceptors are unique by :id. If a global interceptor with the same :id\n * key as `interceptor` is already registered, `interceptor` will take its place in the\n * global interceptor chain. This facilitates hot-reloading.\n * \n * Note: members of re-frame.std-interceptors do not have unique ids. To register\n * more than one, consider:\n * \n *   (reg-global-interceptor (-> (re-frame.std-interceptors/on-changes + [:a] [:b])\n *                            (assoc :id :my-unique-id)))\n */\nre_frame.core.reg_global_interceptor = (function re_frame$core$reg_global_interceptor(interceptor){\nreturn re_frame.settings.reg_global_interceptor(interceptor);\n});\n/**\n * Unregisters global interceptors (presumably registered previously via the use of `reg-global-interceptor`).\n * \n *   When called with no args, it will unregister all currently registered global interceptors.\n * \n *   When given one arg, assumed to be the `id` of a previously registered\n *   global interceptors, it will unregister the associated interceptor. Will produce a warning to\n *   console if it finds no matching registration.\n */\nre_frame.core.clear_global_interceptor = (function re_frame$core$clear_global_interceptor(var_args){\nvar G__11672 = arguments.length;\nswitch (G__11672) {\ncase 0:\nreturn re_frame.core.clear_global_interceptor.cljs$core$IFn$_invoke$arity$0();\n\nbreak;\ncase 1:\nreturn re_frame.core.clear_global_interceptor.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ndefault:\nthrow (new Error([\"Invalid arity: \",arguments.length].join(\"\")));\n\n}\n});\n\n(re_frame.core.clear_global_interceptor.cljs$core$IFn$_invoke$arity$0 = (function (){\nreturn re_frame.settings.clear_global_interceptors.cljs$core$IFn$_invoke$arity$0();\n}));\n\n(re_frame.core.clear_global_interceptor.cljs$core$IFn$_invoke$arity$1 = (function (id){\nreturn re_frame.settings.clear_global_interceptors.cljs$core$IFn$_invoke$arity$1(id);\n}));\n\n(re_frame.core.clear_global_interceptor.cljs$lang$maxFixedArity = 1);\n\n/**\n * A utility function for creating interceptors.\n * \n *   Accepts three optional, named arguments:\n * \n *   - `:id` - an id for the interceptor (decorative only)\n *   - `:before` - the interceptor's before function\n *   - `:after`  - the interceptor's after function\n * \n *   Example use:\n * \n *    #!clj\n *    (def my-interceptor\n *      (->interceptor\n *       :id     :my-interceptor\n *       :before (fn [context]\n *                 ... modifies and returns `context`)\n *       :after  (fn [context]\n *                 ... modifies and returns `context`)))\n * \n *   Notes:\n * \n *  - `:before` functions modify and return their `context` argument. Sometimes they\n *    only side effect, in which case, they'll perform the side effect and return\n *    `context` unchanged.\n *  - `:before` functions often modify the `:coeffects` map within `context` and,\n *    if they do, then they should use the utility functions `get-coeffect` and\n *    `assoc-coeffect`.\n *  - `:after` functions modify and return their `context` argument. Sometimes they\n *    only side effect, in which case, they'll perform the side effect and return\n *    `context` unchanged.\n *  - `:after` functions often modify the `:effects` map within `context` and,\n *    if they do, then they should use the utility functions `get-effect`\n *    and `assoc-effect`\n */\nre_frame.core.__GT_interceptor = (function re_frame$core$__GT_interceptor(var_args){\nvar args__5882__auto__ = [];\nvar len__5876__auto___11917 = arguments.length;\nvar i__5877__auto___11918 = (0);\nwhile(true){\nif((i__5877__auto___11918 < len__5876__auto___11917)){\nargs__5882__auto__.push((arguments[i__5877__auto___11918]));\n\nvar G__11919 = (i__5877__auto___11918 + (1));\ni__5877__auto___11918 = G__11919;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar argseq__5883__auto__ = ((((0) < args__5882__auto__.length))?(new cljs.core.IndexedSeq(args__5882__auto__.slice((0)),(0),null)):null);\nreturn re_frame.core.__GT_interceptor.cljs$core$IFn$_invoke$arity$variadic(argseq__5883__auto__);\n});\n\n(re_frame.core.__GT_interceptor.cljs$core$IFn$_invoke$arity$variadic = (function (p__11694){\nvar map__11695 = p__11694;\nvar map__11695__$1 = cljs.core.__destructure_map(map__11695);\nvar m = map__11695__$1;\nvar id = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__11695__$1,new cljs.core.Keyword(null,\"id\",\"id\",-1388402092));\nvar before = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__11695__$1,new cljs.core.Keyword(null,\"before\",\"before\",-1633692388));\nvar after = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__11695__$1,new cljs.core.Keyword(null,\"after\",\"after\",594996914));\nreturn re_frame.utils.apply_kw.cljs$core$IFn$_invoke$arity$variadic(re_frame.interceptor.__GT_interceptor,cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([m], 0));\n}));\n\n(re_frame.core.__GT_interceptor.cljs$lang$maxFixedArity = (0));\n\n/** @this {Function} */\n(re_frame.core.__GT_interceptor.cljs$lang$applyTo = (function (seq11685){\nvar self__5862__auto__ = this;\nreturn self__5862__auto__.cljs$core$IFn$_invoke$arity$variadic(cljs.core.seq(seq11685));\n}));\n\n/**\n * A utility function, typically used when writing an interceptor's `:before` function.\n * \n * When called with one argument, it returns the `:coeffects` map from within that `context`.\n * \n * When called with two or three arguments, behaves like `clojure.core/get` and\n * returns the value mapped to `key` in the `:coeffects` map within `context`, `not-found` or\n * `nil` if `key` is not present.\n */\nre_frame.core.get_coeffect = (function re_frame$core$get_coeffect(var_args){\nvar G__11709 = arguments.length;\nswitch (G__11709) {\ncase 1:\nreturn re_frame.core.get_coeffect.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase 2:\nreturn re_frame.core.get_coeffect.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ncase 3:\nreturn re_frame.core.get_coeffect.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ndefault:\nthrow (new Error([\"Invalid arity: \",arguments.length].join(\"\")));\n\n}\n});\n\n(re_frame.core.get_coeffect.cljs$core$IFn$_invoke$arity$1 = (function (context){\nreturn re_frame.interceptor.get_coeffect.cljs$core$IFn$_invoke$arity$1(context);\n}));\n\n(re_frame.core.get_coeffect.cljs$core$IFn$_invoke$arity$2 = (function (context,key){\nreturn re_frame.interceptor.get_coeffect.cljs$core$IFn$_invoke$arity$2(context,key);\n}));\n\n(re_frame.core.get_coeffect.cljs$core$IFn$_invoke$arity$3 = (function (context,key,not_found){\nreturn re_frame.interceptor.get_coeffect.cljs$core$IFn$_invoke$arity$3(context,key,not_found);\n}));\n\n(re_frame.core.get_coeffect.cljs$lang$maxFixedArity = 3);\n\n/**\n * A utility function, typically used when writing an interceptor's `:before` function.\n * \n * Adds or updates a key/value pair in the `:coeffects` map within `context`. \n */\nre_frame.core.assoc_coeffect = (function re_frame$core$assoc_coeffect(context,key,value){\nreturn re_frame.interceptor.assoc_coeffect(context,key,value);\n});\n/**\n * A utility function, used when writing interceptors, typically within an `:after` function.\n * \n * When called with one argument, returns the `:effects` map from the `context`.\n * \n * When called with two or three arguments, behaves like `clojure.core/get` and\n * returns the value mapped to `key` in the effects map, `not-found` or\n * `nil` if `key` is not present.\n */\nre_frame.core.get_effect = (function re_frame$core$get_effect(var_args){\nvar G__11727 = arguments.length;\nswitch (G__11727) {\ncase 1:\nreturn re_frame.core.get_effect.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase 2:\nreturn re_frame.core.get_effect.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ncase 3:\nreturn re_frame.core.get_effect.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ndefault:\nthrow (new Error([\"Invalid arity: \",arguments.length].join(\"\")));\n\n}\n});\n\n(re_frame.core.get_effect.cljs$core$IFn$_invoke$arity$1 = (function (context){\nreturn re_frame.interceptor.get_effect.cljs$core$IFn$_invoke$arity$1(context);\n}));\n\n(re_frame.core.get_effect.cljs$core$IFn$_invoke$arity$2 = (function (context,key){\nreturn re_frame.interceptor.get_effect.cljs$core$IFn$_invoke$arity$2(context,key);\n}));\n\n(re_frame.core.get_effect.cljs$core$IFn$_invoke$arity$3 = (function (context,key,not_found){\nreturn re_frame.interceptor.get_effect.cljs$core$IFn$_invoke$arity$3(context,key,not_found);\n}));\n\n(re_frame.core.get_effect.cljs$lang$maxFixedArity = 3);\n\n/**\n * A utility function, typically used when writing an interceptor's `:after` function.\n * \n * Adds or updates a key/value pair in the `:effects` map within `context`. \n */\nre_frame.core.assoc_effect = (function re_frame$core$assoc_effect(context,key,value){\nreturn re_frame.interceptor.assoc_effect(context,key,value);\n});\n/**\n * A utility function, used when writing an interceptor's `:before` function.\n * \n *   Adds the given collection of `interceptors` to those already in `context's`\n *   execution `:queue`. It returns the updated `context`.\n * \n *   So, it provides a way for one interceptor to add more interceptors to the\n *   currently executing interceptor chain.\n *   \n */\nre_frame.core.enqueue = (function re_frame$core$enqueue(context,interceptors){\nreturn re_frame.interceptor.enqueue(context,interceptors);\n});\n/**\n * re-frame outputs warnings and errors via the API function `console`\n * which, by default, delegates to `js/console`'s default implementation for\n *   `log`, `error`, `warn`, `debug`, `group` and `groupEnd`. But, using this function,\n * you can override that behaviour with your own functions.\n * \n *   The argument `new-loggers` should be a map containing a subset of they keys\n *   for the standard `loggers`, namely  `:log` `:error` `:warn` `:debug` `:group`\n *   or `:groupEnd`.\n * \n *   Example Usage:\n * \n *    #!clj\n *    (defn my-logger      ;; my alternative logging function\n *      [& args]\n *      (post-it-somewhere (apply str args)))\n * \n *    ;; now install my alternative loggers\n *    (re-frame.core/set-loggers!  {:warn my-logger :log my-logger})\n * \n */\nre_frame.core.set_loggers_BANG_ = (function re_frame$core$set_loggers_BANG_(new_loggers){\nreturn re_frame.loggers.set_loggers_BANG_(new_loggers);\n});\n/**\n * A utility logging function which is used internally within re-frame to produce\n *   warnings and other output. It can also be used by libraries which\n *   extend re-frame, such as effect handlers.\n * \n *   By default, it will output the given `args` to `js/console` at the given log `level`.\n *   However, an application using re-frame can redirect `console` output via `set-loggers!`.\n * \n *   `level` can be one of `:log`, `:error`, `:warn`, `:debug`, `:group` or `:groupEnd`.\n * \n *   Example usage:\n * \n *    #!clj\n *    (console :error \"Sure enough it happened:\" a-var \"and\" another)\n *    (console :warn \"Possible breach of containment wall at:\" dt)\n *   \n */\nre_frame.core.console = (function re_frame$core$console(var_args){\nvar args__5882__auto__ = [];\nvar len__5876__auto___11932 = arguments.length;\nvar i__5877__auto___11933 = (0);\nwhile(true){\nif((i__5877__auto___11933 < len__5876__auto___11932)){\nargs__5882__auto__.push((arguments[i__5877__auto___11933]));\n\nvar G__11935 = (i__5877__auto___11933 + (1));\ni__5877__auto___11933 = G__11935;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar argseq__5883__auto__ = ((((1) < args__5882__auto__.length))?(new cljs.core.IndexedSeq(args__5882__auto__.slice((1)),(0),null)):null);\nreturn re_frame.core.console.cljs$core$IFn$_invoke$arity$variadic((arguments[(0)]),argseq__5883__auto__);\n});\n\n(re_frame.core.console.cljs$core$IFn$_invoke$arity$variadic = (function (level,args){\nreturn cljs.core.apply.cljs$core$IFn$_invoke$arity$3(re_frame.loggers.console,level,args);\n}));\n\n(re_frame.core.console.cljs$lang$maxFixedArity = (1));\n\n/** @this {Function} */\n(re_frame.core.console.cljs$lang$applyTo = (function (seq11737){\nvar G__11738 = cljs.core.first(seq11737);\nvar seq11737__$1 = cljs.core.next(seq11737);\nvar self__5861__auto__ = this;\nreturn self__5861__auto__.cljs$core$IFn$_invoke$arity$variadic(G__11738,seq11737__$1);\n}));\n\n/**\n * This is a utility function, typically used in testing.\n * \n *   It checkpoints the current state of re-frame and returns a function which, when\n *   later called, will restore re-frame to the checkpointed state.\n * \n *   The checkpoint includes `app-db`, all registered handlers and all subscriptions.\n *   \n */\nre_frame.core.make_restore_fn = (function re_frame$core$make_restore_fn(){\nvar handlers = cljs.core.deref(re_frame.registrar.kind__GT_id__GT_handler);\nvar app_db = cljs.core.deref(re_frame.db.app_db);\nvar subs_cache = cljs.core.deref(re_frame.subs.query__GT_reaction);\nreturn (function (){\nvar original_subs_11939 = cljs.core.set(cljs.core.vals(subs_cache));\nvar current_subs_11940 = cljs.core.set(cljs.core.vals(cljs.core.deref(re_frame.subs.query__GT_reaction)));\nvar seq__11750_11941 = cljs.core.seq(clojure.set.difference.cljs$core$IFn$_invoke$arity$2(current_subs_11940,original_subs_11939));\nvar chunk__11751_11942 = null;\nvar count__11752_11943 = (0);\nvar i__11753_11944 = (0);\nwhile(true){\nif((i__11753_11944 < count__11752_11943)){\nvar sub_11945 = chunk__11751_11942.cljs$core$IIndexed$_nth$arity$2(null,i__11753_11944);\nre_frame.interop.dispose_BANG_(sub_11945);\n\n\nvar G__11946 = seq__11750_11941;\nvar G__11947 = chunk__11751_11942;\nvar G__11948 = count__11752_11943;\nvar G__11949 = (i__11753_11944 + (1));\nseq__11750_11941 = G__11946;\nchunk__11751_11942 = G__11947;\ncount__11752_11943 = G__11948;\ni__11753_11944 = G__11949;\ncontinue;\n} else {\nvar temp__5823__auto___11950 = cljs.core.seq(seq__11750_11941);\nif(temp__5823__auto___11950){\nvar seq__11750_11951__$1 = temp__5823__auto___11950;\nif(cljs.core.chunked_seq_QMARK_(seq__11750_11951__$1)){\nvar c__5673__auto___11953 = cljs.core.chunk_first(seq__11750_11951__$1);\nvar G__11954 = cljs.core.chunk_rest(seq__11750_11951__$1);\nvar G__11955 = c__5673__auto___11953;\nvar G__11956 = cljs.core.count(c__5673__auto___11953);\nvar G__11957 = (0);\nseq__11750_11941 = G__11954;\nchunk__11751_11942 = G__11955;\ncount__11752_11943 = G__11956;\ni__11753_11944 = G__11957;\ncontinue;\n} else {\nvar sub_11958 = cljs.core.first(seq__11750_11951__$1);\nre_frame.interop.dispose_BANG_(sub_11958);\n\n\nvar G__11959 = cljs.core.next(seq__11750_11951__$1);\nvar G__11960 = null;\nvar G__11961 = (0);\nvar G__11962 = (0);\nseq__11750_11941 = G__11959;\nchunk__11751_11942 = G__11960;\ncount__11752_11943 = G__11961;\ni__11753_11944 = G__11962;\ncontinue;\n}\n} else {\n}\n}\nbreak;\n}\n\ncljs.core.reset_BANG_(re_frame.registrar.kind__GT_id__GT_handler,handlers);\n\ncljs.core.reset_BANG_(re_frame.db.app_db,app_db);\n\nreturn null;\n});\n});\n/**\n * Removes all events currently queued for processing\n */\nre_frame.core.purge_event_queue = (function re_frame$core$purge_event_queue(){\nreturn re_frame.router.event_queue.re_frame$router$IEventQueue$purge$arity$1(null);\n});\n/**\n * Registers the given function `f` to be called after each event is processed.\n * \n * `f` will be called with two arguments:\n * \n *  - `event`: a vector. The event just processed.\n *  - `queue`: a PersistentQueue, possibly empty, of events yet to be processed.\n * \n * This facility is useful in advanced cases like:\n * \n *   - you are implementing a complex bootstrap pipeline\n *   - you want to create your own handling infrastructure, with perhaps multiple\n *     handlers for the one event, etc.  Hook in here.\n *   - libraries providing 'isomorphic javascript' rendering on  Nodejs or Nashorn.\n * \n *   `id` is typically a keyword. If it supplied when an `f` is added, it can be\n *   subsequently be used to identify it for removal. See `remove-post-event-callback`.\n *   \n */\nre_frame.core.add_post_event_callback = (function re_frame$core$add_post_event_callback(var_args){\nvar G__11768 = arguments.length;\nswitch (G__11768) {\ncase 1:\nreturn re_frame.core.add_post_event_callback.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase 2:\nreturn re_frame.core.add_post_event_callback.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ndefault:\nthrow (new Error([\"Invalid arity: \",arguments.length].join(\"\")));\n\n}\n});\n\n(re_frame.core.add_post_event_callback.cljs$core$IFn$_invoke$arity$1 = (function (f){\nreturn re_frame.core.add_post_event_callback.cljs$core$IFn$_invoke$arity$2(f,f);\n}));\n\n(re_frame.core.add_post_event_callback.cljs$core$IFn$_invoke$arity$2 = (function (id,f){\nreturn re_frame.router.event_queue.re_frame$router$IEventQueue$add_post_event_callback$arity$3(null,id,f);\n}));\n\n(re_frame.core.add_post_event_callback.cljs$lang$maxFixedArity = 2);\n\n/**\n * Unregisters a post event callback function, identified by `id`.\n * \n *   Such a function must have been previously registered via `add-post-event-callback`\n */\nre_frame.core.remove_post_event_callback = (function re_frame$core$remove_post_event_callback(id){\nreturn re_frame.router.event_queue.re_frame$router$IEventQueue$remove_post_event_callback$arity$2(null,id);\n});\n/**\n * Deprecated. Use `reg-event-db` instead.\n */\nre_frame.core.register_handler = (function re_frame$core$register_handler(var_args){\nvar args__5882__auto__ = [];\nvar len__5876__auto___11965 = arguments.length;\nvar i__5877__auto___11966 = (0);\nwhile(true){\nif((i__5877__auto___11966 < len__5876__auto___11965)){\nargs__5882__auto__.push((arguments[i__5877__auto___11966]));\n\nvar G__11967 = (i__5877__auto___11966 + (1));\ni__5877__auto___11966 = G__11967;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar argseq__5883__auto__ = ((((0) < args__5882__auto__.length))?(new cljs.core.IndexedSeq(args__5882__auto__.slice((0)),(0),null)):null);\nreturn re_frame.core.register_handler.cljs$core$IFn$_invoke$arity$variadic(argseq__5883__auto__);\n});\n\n(re_frame.core.register_handler.cljs$core$IFn$_invoke$arity$variadic = (function (args){\nre_frame.core.console.cljs$core$IFn$_invoke$arity$variadic(new cljs.core.Keyword(null,\"warn\",\"warn\",-436710552),cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([\"re-frame: \\\"register-handler\\\" has been renamed \\\"reg-event-db\\\" (look for registration of \",(\"\"+cljs.core.str.cljs$core$IFn$_invoke$arity$1(cljs.core.first(args))),\")\"], 0));\n\nreturn cljs.core.apply.cljs$core$IFn$_invoke$arity$2(re_frame.core.reg_event_db,args);\n}));\n\n(re_frame.core.register_handler.cljs$lang$maxFixedArity = (0));\n\n/** @this {Function} */\n(re_frame.core.register_handler.cljs$lang$applyTo = (function (seq11771){\nvar self__5862__auto__ = this;\nreturn self__5862__auto__.cljs$core$IFn$_invoke$arity$variadic(cljs.core.seq(seq11771));\n}));\n\n/**\n * Deprecated. Use `reg-sub-raw` instead.\n */\nre_frame.core.register_sub = (function re_frame$core$register_sub(var_args){\nvar args__5882__auto__ = [];\nvar len__5876__auto___11969 = arguments.length;\nvar i__5877__auto___11970 = (0);\nwhile(true){\nif((i__5877__auto___11970 < len__5876__auto___11969)){\nargs__5882__auto__.push((arguments[i__5877__auto___11970]));\n\nvar G__11971 = (i__5877__auto___11970 + (1));\ni__5877__auto___11970 = G__11971;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar argseq__5883__auto__ = ((((0) < args__5882__auto__.length))?(new cljs.core.IndexedSeq(args__5882__auto__.slice((0)),(0),null)):null);\nreturn re_frame.core.register_sub.cljs$core$IFn$_invoke$arity$variadic(argseq__5883__auto__);\n});\n\n(re_frame.core.register_sub.cljs$core$IFn$_invoke$arity$variadic = (function (args){\nre_frame.core.console.cljs$core$IFn$_invoke$arity$variadic(new cljs.core.Keyword(null,\"warn\",\"warn\",-436710552),cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([\"re-frame: \\\"register-sub\\\" is used to register the event \",(\"\"+cljs.core.str.cljs$core$IFn$_invoke$arity$1(cljs.core.first(args))),\" but it is a deprecated part of the API. Please use \\\"reg-sub-raw\\\" instead.\"], 0));\n\nreturn cljs.core.apply.cljs$core$IFn$_invoke$arity$2(re_frame.core.reg_sub_raw,args);\n}));\n\n(re_frame.core.register_sub.cljs$lang$maxFixedArity = (0));\n\n/** @this {Function} */\n(re_frame.core.register_sub.cljs$lang$applyTo = (function (seq11809){\nvar self__5862__auto__ = this;\nreturn self__5862__auto__.cljs$core$IFn$_invoke$arity$variadic(cljs.core.seq(seq11809));\n}));\n\n","~:ns-info",["^ ","~:rename-macros",null,"~:renames",["^ "],"~:meta",["^ ","~:file","re_frame/core.cljc","~:line",1,"~:column",5,"~:end-line",1,"~:end-column",18],"~:ns-aliases",["^ ","~$cljs.loader","~$shadow.loader","~$react","~$shadow.js.shim.module$react"],"~:use-macros",null,"~:excludes",["~#set",[]],"~:name","~$re-frame.core","~:reader-aliases",["^ "],"~:op","~:ns","~:imports",null,"~:requires",["^ ","~$re-frame.interop","^J","~$subs","~$re-frame.subs","~$set","~$clojure.set","~$cofx","~$re-frame.cofx","~$re-frame.interceptor","^Q","~$fx","~$re-frame.fx","~$re-frame.events","^T","~$loggers","~$re-frame.loggers","~$re-frame.settings","^W","^S","^S","~$re-frame.registrar","^X","~$cljs.core","^Y","~$interceptor","^Q","~$goog","^[","~$router","~$re-frame.router","~$db","~$re-frame.db","~$registrar","^X","^11","^11","~$re-frame.utils","^15","^N","^N","~$events","^T","~$settings","^W","~$re-frame.std-interceptors","^18","^V","^V","^L","^L","~$interop","^J","~$utils","^15","~$std-interceptors","^18","^P","^P","^13","^13"],"~:seen",["^B",["~:require"]],"~:uses",["^ ","~$db-handler->interceptor","^18","~$fx-handler->interceptor","^18","~$ctx-handler->interceptor","^18"],"~:require-macros",["^ ","^Y","^Y"],"~:form",["~#list",["~$ns","^D",["^1D",["^1=",["^T","~:as","^16"],["^L","^1F","^K"],["^J","^1F","^19"],["^13","^1F","^12"],["^S","^1F","^R"],["^P","^1F","^O"],["^11","^1F","^10"],["^W","^1F","^17"],["^V","^1F","^U"],["^X","^1F","^14"],["^Q","^1F","^Z"],["^18","^1F","^1;","~:refer",["^1?","^1@","^1A"]],["^15","^1F","^1:"],["^N","^1F","^M"]]]]],"~:flags",["^ ","^1=",["^B",[]]],"~:js-deps",[],"~:deps",["^[","^Y","^T","^L","^J","^13","^S","^P","^11","^W","^V","^X","^Q","^18","^15","^N"]],"^G","^D","~:resource-id",["~:shadow.build.classpath/resource","re_frame/core.cljc"],"~:compiled-at",1768666793770,"^E",["^ ","^J","^J","^K","^L","^M","^N","^O","^P","^Q","^Q","^R","^S","^T","^T","^U","^V","^W","^W","^S","^S","^X","^X","^Y","^Y","^Z","^Q","^[","^[","^10","^11","^12","^13","^14","^X","^11","^11","^15","^15","^N","^N","^16","^T","^17","^W","^18","^18","^V","^V","^L","^L","^19","^J","^1:","^15","^1;","^18","^P","^P","^13","^13"],"~:resource-name","re_frame/core.cljc","~:warnings",[],"~:source","(ns re-frame.core\n  (:require\n   [re-frame.events           :as events]\n   [re-frame.subs             :as subs]\n   [re-frame.interop          :as interop]\n   [re-frame.db               :as db]\n   [re-frame.fx               :as fx]\n   [re-frame.cofx             :as cofx]\n   [re-frame.router           :as router]\n   [re-frame.settings         :as settings]\n   [re-frame.loggers          :as loggers]\n   [re-frame.registrar        :as registrar]\n   [re-frame.interceptor      :as interceptor]\n   [re-frame.std-interceptors :as std-interceptors :refer [db-handler->interceptor\n                                                           fx-handler->interceptor\n                                                           ctx-handler->interceptor]]\n   [re-frame.utils            :as utils]\n   [clojure.set               :as set]))\n\n;; -- dispatch ----------------------------------------------------------------\n\n(defn dispatch\n  \"Queue `event` for processing (handling).\n\n  `event` is a vector and the first element is typically a keyword\n  which identifies the kind of event.\n\n  The event will be added to a FIFO processing queue, so event\n  handling does not happen immediately. It will happen 'very soon'\n  but not now. And if the queue already contains events, they\n  will be processed first.\n\n  Usage:\n\n      #!clj\n      (dispatch [:order \\\"pizza\\\" {:supreme 2 :meatlovers 1 :veg 1}])\n  \"\n  {:api-docs/heading \"Dispatching Events\"}\n  [event]\n  (router/dispatch event))\n\n(defn dispatch-sync\n  \"Synchronously (immediately) process `event`. It does **not** queue\n  the event for handling later as `dispatch` does.\n\n  `event` is a vector and the first element is typically a keyword\n  which identifies the kind of event.\n\n  It is an error to use `dispatch-sync` within an event handler because\n  you can't immediately process an new event when one is already\n  part way through being processed.\n\n  Generally, avoid using this function, and instead, use `dispatch`.\n  Only use it in the narrow set of cases where any delay in\n  processing is a problem:\n\n    1. the `:on-change` handler of a text field where we are expecting fast typing\n    2. when initialising your app - see 'main' in examples/todomvc/src/core.cljs\n    3. in a unit test where immediate, synchronous processing is useful\n\n  Usage:\n\n      #!clj\n      (dispatch-sync [:sing :falsetto \\\"piano accordion\\\"])\n  \"\n  {:api-docs/heading \"Dispatching Events\"}\n  [event]\n  (router/dispatch-sync event))\n\n;; -- Events ------------------------------------------------------------------\n\n(defn reg-event-db\n  \"Register the given event `handler` (function) for the given `id`. Optionally, provide\n  an `interceptors` chain:\n\n    - `id` is typically a namespaced keyword  (but can be anything)\n    - `handler` is a function: (db event) -> db\n    - `interceptors` is a collection of interceptors. Will be flattened and nils removed.\n\n  Example Usage:\n\n      #!clj\n      (reg-event-db\n        :token\n        (fn [db event]\n          (assoc db :some-key (get event 2)))  ;; return updated db\n\n  Or perhaps:\n\n      #!clj\n      (reg-event-db\n        :namespaced/id           ;; <-- namespaced keywords are often used\n        [one two three]          ;; <-- a seq of interceptors\n        (fn [db [_ arg1 arg2]]   ;; <-- event vector is destructured\n          (-> db\n            (dissoc arg1)\n            (update :key + arg2))))   ;; return updated db\n  \"\n  {:api-docs/heading \"Event Handlers\"}\n  ([id handler]\n   (reg-event-db id nil handler))\n  ([id interceptors handler]\n   (events/register id [cofx/inject-db fx/do-fx std-interceptors/inject-global-interceptors interceptors (db-handler->interceptor handler)])))\n\n(defn reg-event-fx\n  \"Register the given event `handler` (function) for the given `id`. Optionally, provide\n  an `interceptors` chain:\n\n    - `id` is typically a namespaced keyword  (but can be anything)\n    - `handler` is a function: (coeffects-map event-vector) -> effects-map\n    - `interceptors` is a collection of interceptors. Will be flattened and nils removed.\n\n\n  Example Usage:\n\n      #!clj\n      (reg-event-fx\n        :event-id\n        (fn [cofx event]\n          {:db (assoc (:db cofx) :some-key (get event 2))}))   ;; return a map of effects\n\n\n  Or perhaps:\n\n      #!clj\n      (reg-event-fx\n        :namespaced/id           ;; <-- namespaced keywords are often used\n        [one two three]          ;; <-- a seq of interceptors\n        (fn [{:keys [db] :as cofx} [_ arg1 arg2]] ;; destructure both arguments\n          {:db (assoc db :some-key arg1)          ;; return a map of effects\n           :fx [[:dispatch [:some-event arg2]]]}))\n  \"\n  {:api-docs/heading \"Event Handlers\"}\n  ([id handler]\n   (reg-event-fx id nil handler))\n  ([id interceptors handler]\n   (events/register id [cofx/inject-db fx/do-fx std-interceptors/inject-global-interceptors interceptors (fx-handler->interceptor handler)])))\n\n(defn reg-event-ctx\n  \"Register the given event `handler` (function) for the given `id`. Optionally, provide\n  an `interceptors` chain:\n\n    - `id` is typically a namespaced keyword  (but can be anything)\n    - `handler` is a function: context-map -> context-map\n\n  You can explore what is provided in `context` [here](https://day8.github.io/re-frame/Interceptors/#what-is-context).\n\n  Example Usage:\n\n      #!clj\n      (reg-event-ctx\n        :event-id\n        (fn [{:keys [coeffects] :as context}]\n          (let [initial  {:db     (:db coeffects)\n                          :event  (:event coeffects)\n                          :fx     []}\n                result   (-> initial\n                             function1\n                             function2\n                             function3)\n                effects  (select-keys result [:db :fx])]\n             (assoc context :effects effects))))\n  \"\n  {:api-docs/heading \"Event Handlers\"}\n  ([id handler]\n   (reg-event-ctx id nil handler))\n  ([id interceptors handler]\n   (events/register id [cofx/inject-db fx/do-fx std-interceptors/inject-global-interceptors interceptors (ctx-handler->interceptor handler)])))\n\n(defn clear-event\n  \"Unregisters event handlers (presumably registered previously via the use of `reg-event-db` or `reg-event-fx`).\n\n  When called with no args, it will unregister all currently registered event handlers.\n\n  When given one arg, assumed to be the `id` of a previously registered\n  event handler, it will unregister the associated handler. Will produce a warning to\n  console if it finds no matching registration.\"\n  {:api-docs/heading \"Event Handlers\"}\n  ([]\n   (registrar/clear-handlers events/kind))\n  ([id]\n   (registrar/clear-handlers events/kind id)))\n\n;; -- subscriptions -----------------------------------------------------------\n\n(defn reg-sub\n  \"A call to `reg-sub` associates a `query-id` WITH two functions.\n\n  The two functions provide 'a mechanism' for creating a node\n  in the Signal Graph. When a node of type `query-id` is needed,\n  the two functions can be used to create it.\n\n  The three arguments are:\n\n    - `query-id` - typically a namespaced keyword (later used in subscribe)\n    - optionally, an `input signals` function which returns the input data\n      flows required by this kind of node.\n    - a `computation function` which computes the value (output) of the\n      node (from the input data flows)\n\n  Later, during app execution, a call to `(subscribe [:sub-id 3 :blue])`,\n  will trigger the need for a new `:sub-id` Signal Graph node (matching the\n  query `[:sub-id 3 :blue]`). And, to create that node the two functions\n  associated with `:sub-id` will be looked up and used.\n\n  Just to be clear: calling `reg-sub` does not immediately create a node.\n  It only registers 'a mechanism' (the two functions) by which nodes\n  can be created later, when a node is bought into existence by the\n  use of `subscribe` in a `View Function`.\n\n  `reg-sub` arguments are:\n\n    - a `query-id` (typically a namespaced keyword)\n    - a function which returns the inputs required by this kind of node (can be supplied  in one of three ways)\n    - a function which computes the value of this kind of node (can be supplied in one of three ways)\n\n  The `computation function` is always the last argument supplied and has three ways to be called.\n  Two of these methods are syntactic sugar to provide easier access to functional abstractions around your data.\n\n  1. A function that will accept two parameters, the `input-values` and `query-vector`. This is the\n     standard way to provide a `computation-function`\n\n          #!clj\n          (reg-sub\n            :query-id\n            (fn [input-values query-vector]\n              (:foo input-values)))\n\n  2. A single sugary tuple of `:->` and a 1-arity `computation-function`:\n\n          #!clj\n          (reg-sub\n            :query-id\n            :-> computation-fn)\n\n      This sugary variation allows you to pass a function that will expect only one parameter,\n      namely the `input-values` and entirely omit the `query-vector`. A typical `computation-function`\n      expects two parameters which can cause unfortunate results when attempting to use\n      clojure standard library functions, or other functions, in a functional manner.\n\n      For example, a significant number of subscriptions exist only to get a value\n      from the `input-values`. As shown below, this subscription will simply retrieve\n      the value associated with the `:foo` key in our db:\n\n          #!clj\n          (reg-sub\n            :query-id\n            (fn [db _]    ;; :<---- trivial boilerplate we might want to skip over\n              (:foo db)))\n\n      This is slightly more boilerplate than we might like to do,\n      as we can use a keyword directly as a function, and we might like to do this:\n\n          #!clj\n          (reg-sub\n            :query-id\n            :foo)  ;; :<---- This could be dangerous. If `:foo` is not in db, we get the `query-vector` instead of `nil`.\n\n      By using `:->` our function would not contain the `query-vector`, and any\n      missing keys would be represented as such:\n\n          #!clj\n          (reg-sub\n            :query-id\n            :-> :foo)\n\n      This form allows us to ignore the `query-vector` if our `computation-function`\n      has no need for it, and be safe from any accidents. Any 1-arity function can be provided,\n      and for more complicated use cases, `partial`, `comp`, and anonymous functions can still be used.\n\n  3. A single sugary tuple of `:=>` and a multi-arity `computation-function`\n\n          #!clj\n          (reg-sub\n            :query-id\n            :=> computation-fn)\n\n      The `query-vector` can be broken into two components `[query-id & optional-values]`, and\n      some subscriptions require the `optional-values` for extra work within the subscription.\n      To use them in variation #1, we need to destructure our `computation-function` parameters\n      in order to use them.\n\n          #!clj\n          (reg-sub\n            :query-id\n            (fn [db [_ foo]]\n              [db foo]))\n\n      Again we are writing boilerplate just to reach our values, and we might prefer to\n      have direction access through a parameter vector like `[input-values optional-values]`\n      instead, so we might be able to use a multi-arity function directly as our `computation-function`.\n      A rewrite of the above sub using this sugary syntax would look like this:\n\n          #!clj\n          (reg-sub\n            :query-id\n            :=> vector)  ;; :<---- Could also be `(fn [db foo] [db foo])`\n\n  The `computation function` is expected to take two arguments:\n\n    - `input-values` - the values which flow into this node (how is it wired into the graph?)\n    - `query-vector` - the vector given to `subscribe`\n\n  and it returns a computed value (which then becomes the output of the node)\n\n  When `computation function` is called, the 2nd `query-vector` argument will be that\n  vector supplied to the `subscribe`. So, if the call was `(subscribe [:sub-id 3 :blue])`,\n  then the `query-vector` supplied to the computation function will be `[:sub-id 3 :blue]`.\n\n  The argument(s) supplied to `reg-sub` between `query-id` and the `computation-function`\n  can vary in 3 ways, but whatever is there defines the `input signals` part\n  of `the mechanism`, specifying what input values \\\"flow into\\\" the\n  `computation function` (as the 1st argument) when it is called.\n\n  So, `reg-sub` can be called in one of three ways, because there are three ways\n  to define the input signals part. But note, the 2nd method, in which a\n  `signals function` is explicitly supplied, is the most canonical and\n  instructive. The other two are really just sugary variations.\n\n  **First variation** - no input signal function given:\n\n      #!clj\n      (reg-sub\n        :query-id\n        a-computation-fn)   ;; has signature:  (fn [db query-vec]  ... ret-value)\n\n     In the absence of an explicit `signals function`, the node's input signal defaults to `app-db`\n     and, as a result, the value within `app-db` (a map) is\n     given as the 1st argument when `a-computation-fn` is called.\n\n\n  **Second variation** - a signal function is explicitly supplied:\n\n      #!clj\n      (reg-sub\n        :query-id\n        signal-fn     ;; <-- here\n        computation-fn)\n\n  This is the most canonical and instructive of the three variations.\n\n  When a node is created from the template, the `signal function` will be called and it\n  is expected to return the input signal(s) as either a singleton, if there is only\n  one, or a sequence if there are many, or a map with the signals as the values.\n\n  The current values of the returned signals will be supplied as the 1st argument to\n  the `a-computation-fn` when it is called - and subject to what this `signal-fn` returns,\n  this value will be either a singleton, sequence or map of them (paralleling\n  the structure returned by the `signal function`).\n\n  This example `signal function` returns a 2-vector of input signals.\n\n      #!clj\n      (fn [query-vec dynamic-vec]\n         [(subscribe [:a-sub])\n          (subscribe [:b-sub])])\n\n  The associated computation function must be written\n  to expect a 2-vector of values for its first argument:\n\n      #!clj\n      (fn [[a b] query-vec]     ;; 1st argument is a seq of two values\n        ....)\n\n  If, on the other hand, the signal function was simpler and returned a singleton, like this:\n\n      #!clj\n      (fn [query-vec dynamic-vec]\n        (subscribe [:a-sub]))      ;; <-- returning a singleton\n\n  then the associated computation function must be written to expect a single value\n  as the 1st argument:\n\n      #!clj\n      (fn [a query-vec]       ;; 1st argument is a single value\n         ...)\n\n  Further Note: variation #1 above, in which an `signal-fn` was not supplied, like this:\n\n      #!clj\n      (reg-sub\n        :query-id\n        a-computation-fn)   ;; has signature:  (fn [db query-vec]  ... ret-value)\n\n  is the equivalent of using this\n  2nd variation and explicitly supplying a `signal-fn` which returns `app-db`:\n\n      #!clj\n      (reg-sub\n        :query-id\n        (fn [_ _]  re-frame/app-db)   ;; <--- explicit signal-fn\n        a-computation-fn)             ;; has signature:  (fn [db query-vec]  ... ret-value)\n\n  **Third variation** - syntax Sugar\n\n      #!clj\n      (reg-sub\n        :a-b-sub\n        :<- [:a-sub]\n        :<- [:b-sub]\n        (fn [[a b] query-vec]    ;; 1st argument is a seq of two values\n          {:a a :b b}))\n\n  This 3rd variation is just syntactic sugar for the 2nd.  Instead of providing an\n  `signals-fn` you provide one or more pairs of `:<-` and a subscription vector.\n\n  If you supply only one pair a singleton will be supplied to the computation function,\n  as if you had supplied a `signal-fn` returning only a single value:\n\n      #!clj\n      (reg-sub\n        :a-sub\n        :<- [:a-sub]\n        (fn [a query-vec]      ;; only one pair, so 1st argument is a single value\n          ...))\n\n  Syntactic sugar for both the `signal-fn` and `computation-fn` can be used together\n  and the direction of arrows shows the flow of data and functions. The example from\n  directly above is reproduced here:\n\n      #!clj\n      (reg-sub\n        :a-b-sub\n        :<- [:a-sub]\n        :<- [:b-sub]\n        :-> (partial zipmap [:a :b]))\n\n  For further understanding, read the tutorials, and look at the detailed comments in\n  /examples/todomvc/src/subs.cljs.\n\n  See also: `subscribe`\n  \"\n  {:api-docs/heading \"Subscriptions\"}\n  [query-id & args]\n  (apply subs/reg-sub query-id args))\n\n(defn subscribe\n  \"Given a `query` vector, returns a Reagent `reaction` which will, over\n  time, reactively deliver a stream of values. So, in FRP-ish terms,\n  it returns a `Signal`.\n\n  To obtain the current value from the Signal, it must be dereferenced:\n\n      #!clj\n      (let [signal (subscribe [:items])\n            value  (deref signal)]     ;; could be written as @signal\n        ...)\n\n   which is typically written tersely as simple:\n\n      #!clj\n      (let [items  @(subscribe [:items])]\n        ...)\n\n\n  `query` is a vector of at least one element. The first element is the\n  `query-id`, typically a namespaced keyword. The rest of the vector's\n  elements are optional, additional values which parameterise the query\n  performed.\n\n  `dynv` exists for historical reasons and is borderline deprecated these days.\n  It is a vector of signals. Re-frame will dereference each of them and pass a\n  vector of their values to your subscription handler as a third argument.\n  If there's logic determing __what__ query to subscribe __to__, consider\n  expressing it in a `signal function`, or use `reg-sub-raw`. Failing that, `dynv`\n  allows you to colocate this logic with the `subscribe` call.\n\n  **Example Usage**:\n\n      #!clj\n      (subscribe [:items])\n      (subscribe [:items \\\"blue\\\" :small])\n      (subscribe [:items {:colour \\\"blue\\\"  :size :small}])\n\n  Note: for any given call to `subscribe` there must have been a previous call\n  to `reg-sub`, registering the query handler (functions) associated with\n  `query-id`.\n\n  **Hint**\n\n  When used in a view function BE SURE to `deref` the returned value.\n  In fact, to avoid any mistakes, some prefer to define:\n\n      #!clj\n      (def <sub  (comp deref re-frame.core/subscribe))\n\n  And then, within their views, they call  `(<sub [:items :small])` rather\n  than using `subscribe` directly.\n\n  **De-duplication**\n\n  Two, or more, concurrent subscriptions for the same query will\n  source reactive updates from the one executing handler.\n\n  See also: `reg-sub`\n  \"\n  {:api-docs/heading \"Subscriptions\"}\n  ([query]\n   (subs/subscribe query))\n  ([query dynv]\n   (subs/subscribe query dynv)))\n\n(defn clear-sub ;; think unreg-sub\n  \"Unregisters subscription handlers (presumably registered previously via the use of `reg-sub`).\n\n  When called with no args, it will unregister all currently registered subscription handlers.\n\n  When given one arg, assumed to be the `id` of a previously registered\n  subscription handler, it will unregister the associated handler. Will produce a warning to\n  console if it finds no matching registration.\n\n  NOTE: Depending on the usecase, it may be necessary to call `clear-subscription-cache!` afterwards\"\n  {:api-docs/heading \"Subscriptions\"}\n  ([]\n   (registrar/clear-handlers subs/kind))\n  ([query-id]\n   (registrar/clear-handlers subs/kind query-id)))\n\n(defn reg-sub-raw\n  \"This is a low level, advanced function.  You should probably be\n  using `reg-sub` instead.\n\n  Some explanation is available in the docs at\n  <a href=\\\"http://day8.github.io/re-frame/flow-mechanics/\\\" target=\\\"_blank\\\">http://day8.github.io/re-frame/flow-mechanics/</a>\"\n  {:api-docs/heading \"Subscriptions\"}\n  [query-id handler-fn]\n  (registrar/register-handler subs/kind query-id handler-fn))\n\n;; XXX\n(defn clear-subscription-cache!\n  \"Removes all subscriptions from the cache.\n\n  This function can be used at development time or test time. Useful when hot reloading\n  namespaces containing subscription handlers. Also call it after a React/render exception,\n  because React components won't have been cleaned up properly. And this, in turn, means\n  the subscriptions within those components won't have been cleaned up correctly. So this\n  forces the issue.\n  \"\n  {:api-docs/heading \"Subscriptions\"}\n  []\n  (subs/clear-subscription-cache!))\n\n;; -- effects -----------------------------------------------------------------\n\n(defn reg-fx\n  \"Register the given effect `handler` for the given `id`:\n\n    - `id` is keyword, often namespaced.\n    - `handler` is a side-effecting function which takes a single argument and whose return\n      value is ignored.\n\n  To use, first, associate `:effect2` with a handler:\n\n      #!clj\n      (reg-fx\n         :effect2\n         (fn [value]\n            ... do something side-effect-y))\n\n  Then, later, if an event handler were to return this effects map:\n\n      #!clj\n      {:effect2  [1 2]}\n\n  then the `handler` `fn` we registered previously, using `reg-fx`, will be\n  called with an argument of `[1 2]`.\n  \"\n  {:api-docs/heading \"Effect Handlers\"}\n  [id handler]\n  (fx/reg-fx id handler))\n\n(defn clear-fx ;; think unreg-fx\n  \"Unregisters effect handlers (presumably registered previously via the use of `reg-fx`).\n\n  When called with no args, it will unregister all currently registered effect handlers.\n\n  When given one arg, assumed to be the `id` of a previously registered\n  effect handler, it will unregister the associated handler. Will produce a warning to\n  console if it finds no matching registration.\n  \"\n  {:api-docs/heading \"Effect Handlers\"}\n  ([]\n   (registrar/clear-handlers fx/kind))\n  ([id]\n   (registrar/clear-handlers fx/kind id)))\n\n;; -- coeffects ---------------------------------------------------------------\n\n(defn reg-cofx\n  \"Register the given coeffect `handler` for the given `id`, for later use\n  within `inject-cofx`:\n\n    - `id` is keyword, often namespaced.\n    - `handler` is a function which takes either one or two arguments, the first of which is\n       always `coeffects` and which returns an updated `coeffects`.\n\n  See also: `inject-cofx`\n  \"\n  {:api-docs/heading \"Coeffects\"}\n  [id handler]\n  (cofx/reg-cofx id handler))\n\n(defn inject-cofx\n  \"Given an `id`, and an optional, arbitrary `value`, returns an interceptor\n  whose `:before` adds to the `:coeffects` (map) by calling a pre-registered\n  'coeffect handler' identified by the `id`.\n\n  The previous association of a `coeffect handler` with an `id` will have\n  happened via a call to `re-frame.core/reg-cofx` - generally on program startup.\n\n  Within the created interceptor, this 'looked up' `coeffect handler` will\n  be called (within the `:before`) with two arguments:\n\n  - the current value of `:coeffects`\n  - optionally, the originally supplied arbitrary `value`\n\n  This `coeffect handler` is expected to modify and return its first, `coeffects` argument.\n\n  **Example of `inject-cofx` and `reg-cofx` working together**\n\n\n  First - Early in app startup, you register a `coeffect handler` for `:datetime`:\n\n      #!clj\n      (re-frame.core/reg-cofx\n        :datetime                        ;; usage  (inject-cofx :datetime)\n        (fn coeffect-handler\n          [coeffect]\n          (assoc coeffect :now (js/Date.))))   ;; modify and return first arg\n\n  Second - Later, add an interceptor to an -fx event handler, using `inject-cofx`:\n\n      #!clj\n      (re-frame.core/reg-event-fx            ;; when registering an event handler\n        :event-id\n        [ ... (inject-cofx :datetime) ... ]  ;; <-- create an injecting interceptor\n        (fn event-handler\n          [coeffect event]\n            ;;... in here can access (:now coeffect) to obtain current datetime ...\n          )))\n\n  **Background**\n\n  `coeffects` are the input resources required by an event handler\n  to perform its job. The two most obvious ones are `db` and `event`.\n  But sometimes an event handler might need other resources.\n\n  Perhaps an event handler needs a random number or a GUID or the current\n  datetime. Perhaps it needs access to a DataScript database connection.\n\n  If an event handler directly accesses these resources, it stops being\n  pure and, consequently, it becomes harder to test, etc. So we don't\n  want that.\n\n  Instead, the interceptor created by this function is a way to 'inject'\n  'necessary resources' into the `:coeffects` (map) subsequently given\n  to the event handler at call time.\n\n  See also `reg-cofx`\n  \"\n  {:api-docs/heading \"Coeffects\"}\n  ([id]\n   (cofx/inject-cofx id))\n  ([id value]\n   (cofx/inject-cofx id value)))\n\n(defn clear-cofx ;; think unreg-cofx\n  \"Unregisters coeffect handlers (presumably registered previously via the use of `reg-cofx`).\n\n  When called with no args, it will unregister all currently registered coeffect handlers.\n\n  When given one arg, assumed to be the `id` of a previously registered\n  coeffect handler, it will unregister the associated handler. Will produce a warning to\n  console if it finds no matching registration.\"\n  {:api-docs/heading \"Coeffects\"}\n  ([]\n   (registrar/clear-handlers cofx/kind))\n  ([id]\n   (registrar/clear-handlers cofx/kind id)))\n\n;; -- error handler ----------------------------------------------------------\n\n(defn reg-event-error-handler\n  \"Register the given event error `handler` (function) that will catch unhandled exceptions\n  thrown in the interceptors/handler chain.\n\n  Only one `handler` can be registered. Registering a new `handler` clears the existing `handler`.\n\n  This `handler` function has the signature:\n\n  `(handler [original-error re-frame-error])`\n\n  - `original-error`: A plaform-native Error object.\n     Represents the original error thrown by user code.\n     this is the error you see when no `handler` is registered.\n\n  - `re-frame-error`: A clojure ExceptionInfo object.\n     Includes the stacktrace of re-frame's internal functions,\n     and extra data about the interceptor process.\n     Call `(ex-data re-frame-error)` to get this info.\n\n     The data includes:\n\n     - `:interceptor`: the `:id` of the throwing interceptor.\n     - `:direction`: `:before` or `:after`.\n     - `:event-v`: the re-frame event which invoked this interceptor.\"\n  [handler]\n  (registrar/register-handler :error :event-handler handler))\n\n(reg-event-error-handler interceptor/default-error-handler)\n\n;; -- interceptors ------------------------------------------------------------\n\n(def ^{:api-docs/heading \"Interceptors\"} debug\n  \"An interceptor which logs/instruments an event handler's actions to\n  `re-frame/console` at the `:log` level.\n\n  Output includes:\n\n    1. the event vector\n    2. a `clojure.data/diff` of db, before vs after, which shows\n       the changes caused by the event handler. To understand the output,\n       you should understand:\n       <a href=\\\"https://clojuredocs.org/clojure.data/diff\\\" target=\\\"_blank\\\">https://clojuredocs.org/clojure.data/diff</a>.\n\n  You'd typically include this interceptor after (to the right of) any\n  `path` interceptor.\n\n  Warning:  calling `clojure.data/diff` on large, complex data structures\n  can be slow. So, you won't want this interceptor present in production\n  code. So, you should condition it out like this:\n\n      #!clj\n      (re-frame.core/reg-event-db\n        :evt-id\n        [(when ^boolean goog.DEBUG re-frame.core/debug)]  ;; <-- conditional\n        (fn [db v]\n           ...))\n\n  To make this code fragment work, you'll also have to set `goog.DEBUG` to\n  `false` in your production builds. For an example, look in `project.clj` of /examples/todomvc.\n  \"\n  std-interceptors/debug)\n\n(defn path\n  \"Returns an interceptor which acts somewhat like `clojure.core/update-in`, in the sense that\n  the event handler is given a specific part of `app-db` to change, not all of `app-db`.\n\n  The interceptor has both a `:before` and `:after` functions. The `:before` replaces\n  the `:db` key within coeffects with a sub-path within `app-db`. The `:after` reverses the process,\n  and it grafts the handler's return value back into db, at the right path.\n\n  Examples:\n\n      #!clj\n      (path :some :path)\n      (path [:some :path])\n      (path [:some :path] :to :here)\n      (path [:some :path] [:to] :here)\n\n  Example Use:\n\n      #!clj\n      (reg-event-db\n        :event-id\n        (path [:a :b])  ;; <-- used here, in interceptor chain\n        (fn [b v]       ;; 1st arg is not db. Is the value from path [:a :b] within db\n          ... new-b))   ;; returns a new value for that path (not the entire db)\n\n  Notes:\n\n    1. `path` may appear more than once in an interceptor chain. Progressive narrowing.\n    2. if `:effects` contains no `:db` effect, can't graft a value back in.\n  \"\n  {:api-docs/heading \"Interceptors\"}\n  [& args]\n  (apply std-interceptors/path args))\n\n(defn enrich\n  \"Returns an interceptor which will run the given function `f` in the `:after`\n  position.\n\n  `f` is called with two arguments: `db` and `event`, and is expected to\n  return a modified `db`.\n\n  Unlike the `after` interceptor which is only about side effects, `enrich`\n  expects `f` to process and alter the given `db` coeffect in some useful way,\n  contributing to the derived data, flowing vibe.\n\n  If `f` returns `nil`, the `db` value passed to `f` will be returned instead.\n\n  #### Example Use:\n\n  Imagine that todomvc needed to do duplicate detection - if any two todos had\n  the same text, then highlight their background, and report them via a warning\n  at the bottom of the panel.\n\n  Almost any user action (edit text, add new todo, remove a todo) requires a\n  complete reassessment of duplication errors and warnings. E.g. that edit\n  just made might have introduced a new duplicate, or removed one. Same with\n  any todo removal. So we need to re-calculate warnings after any CRUD events\n  associated with the todos list.\n\n  Unless we are careful, we might end up coding subtly different checks\n  for each kind of CRUD operation.  The duplicates check made after\n  'delete todo' event might be subtly different to that done after an\n  editing operation. Nice and efficient, but fiddly. A bug generator\n  approach.\n\n  So, instead, we create an `f` which recalculates ALL warnings from scratch\n  every time there is ANY change. It will inspect all the todos, and\n  reset ALL FLAGS every time (overwriting what was there previously)\n  and fully recalculate the list of duplicates (displayed at the bottom?).\n\n  <a href=\\\"https://twitter.com/nathanmarz/status/879722740776939520\\\" target=\\\"_blank\\\">https://twitter.com/nathanmarz/status/879722740776939520</a>\n\n  By applying `f` in an `:enrich` interceptor, after every CRUD event,\n  we keep the handlers simple and yet we ensure this important step\n  (of getting warnings right) is not missed on any change.\n\n  We can test `f` easily - it is a pure function - independently of\n  any CRUD operation.\n\n  This brings huge simplicity at the expense of some re-computation\n  each time. This may be a very satisfactory trade-off in many cases.\n\n  #### Returning nil\n\n  In some cases, it's useful to apply a change to specific situations that can\n  be determined at runtime instead of when defining the handler with an\n  `:enrich` interceptor. Instead of forcing you to return the `db` from every\n  non-applicable branch, you can return `nil` to use the given `db` value:\n\n      #!clj\n      (def set-last-update\n        (core/enrich\n          (fn [{db :db} [_ {user :user}]]\n            (when (active-user? user)  ;; <- Only perform an update if user is active\n              ...))))\n  \"\n  {:api-docs/heading \"Interceptors\"}\n  [f]\n  (std-interceptors/enrich f))\n\n(def ^{:api-docs/heading \"Interceptors\"} unwrap\n  \"> New in v1.2.0\n\n   An interceptor which decreases the amount of destructuring necessary in an\n   event handler where the event is structured as a 2-vector of\n   [event-id payload-map].\n\n   It promotes the `payload-map` part to be the event ultimately given to the\n   event handler. Should you want the full original event, it can be found in\n   `coeffects` under the key `:original-event`.\n\n   If a dispatch looked like this:\n\n      #!clj\n       (dispatch [:event-id {:x 1 :y 2 :z 3}])\n\n   Your event handlers can look like this:\n\n      #!clj\n       (reg-event-fx\n         :event-id\n         [... unwrap ...]                    ;; <-- added to the interceptors\n         (fn [{:keys [db]} {:keys [x y z]}]  ;; <-- instead of [_ {:keys [x y z]}]\n           ...)\n   \"\n  std-interceptors/unwrap)\n\n(def ^{:api-docs/heading \"Interceptors\"} trim-v\n  \"An interceptor which removes the first element of the event vector,\n  before it is supplied to the event handler, allowing you to write more\n   aesthetically pleasing event handlers. No leading underscore on the event-v!\n\n  Should you want the full original event, it can be found in `coeffects` under\n  the key `:original-event`.\n\n  Your event handlers will look like this:\n\n      #!clj\n      (reg-event-db\n        :event-id\n        [... trim-v ...]    ;; <-- added to the interceptors\n        (fn [db [x y z]]    ;; <-- instead of [_ x y z]\n          ...)\n    \"\n  std-interceptors/trim-v)\n\n(defn after\n  \"Returns an interceptor which runs the given function `f` in the `:after`\n  position, presumably for side effects.\n\n  `f` is called with two arguments: the `:effects` value for `:db`\n  (or the `:coeffect` value of `:db` if no `:db` effect is returned) and the event.\n  Its return value is ignored, so `f` can only side-effect.\n\n  An example of use can be seen in the re-frame github repo in `/examples/todomvc/events.cljs`:\n\n     - `f` runs schema validation (reporting any errors found).\n     - `f` writes to localstorage.\"\n  {:api-docs/heading \"Interceptors\"}\n  [f]\n  (std-interceptors/after f))\n\n(defn on-changes\n  \"Returns an interceptor which will observe N paths within `db`, and if any of them\n  test not `identical?` to their previous value  (as a result of a event handler\n  being run), then it will run `f` to compute a new value, which is then assoc-ed\n  into the given `out-path` within `db`.\n\n  Example Usage:\n\n      #!clj\n      (defn my-f\n        [a-val b-val]\n        ... some computation on a and b in here)\n\n      ;; use it\n      (def my-interceptor (on-changes my-f [:c] [:a] [:b]))\n\n      (reg-event-db\n        :event-id\n        [... my-interceptor ...]  ;; <-- ultimately used here\n        (fn [db v]\n           ...))\n\n\n  If you put this interceptor on handlers which might change paths `:a` or `:b`,\n  it will:\n\n    - call `f` each time the value at path `[:a]` or `[:b]` changes\n    - call `f` with the values extracted from `[:a]` `[:b]`\n    - assoc the return value from `f` into the path  `[:c]`\n  \"\n  {:api-docs/heading \"Interceptors\"}\n  [f out-path & in-paths]\n  (apply std-interceptors/on-changes f out-path in-paths))\n\n(defn reg-global-interceptor\n  \"Registers the given `interceptor` as a global interceptor. Global interceptors are\n   included in the processing chain of every event.\n\n   When you register an event handler, you have the option of supplying an\n   interceptor chain. Any global interceptors you register are effectively\n   prepending to this chain.\n\n   Global interceptors are run in the order that they are registered.\n\n   Global interceptors are unique by :id. If a global interceptor with the same :id\n   key as `interceptor` is already registered, `interceptor` will take its place in the\n   global interceptor chain. This facilitates hot-reloading.\n\n   Note: members of re-frame.std-interceptors do not have unique ids. To register\n   more than one, consider:\n\n  (reg-global-interceptor (-> (re-frame.std-interceptors/on-changes + [:a] [:b])\n                              (assoc :id :my-unique-id)))\"\n  {:api-docs/heading \"Global Interceptors\"}\n  [interceptor]\n  (settings/reg-global-interceptor interceptor))\n\n(defn clear-global-interceptor\n  \"Unregisters global interceptors (presumably registered previously via the use of `reg-global-interceptor`).\n\n  When called with no args, it will unregister all currently registered global interceptors.\n\n  When given one arg, assumed to be the `id` of a previously registered\n  global interceptors, it will unregister the associated interceptor. Will produce a warning to\n  console if it finds no matching registration.\"\n  {:api-docs/heading \"Global Interceptors\"}\n  ([]\n   (settings/clear-global-interceptors))\n  ([id]\n   (settings/clear-global-interceptors id)))\n\n(defn ->interceptor\n  \"A utility function for creating interceptors.\n\n  Accepts three optional, named arguments:\n\n     - `:id` - an id for the interceptor (decorative only)\n     - `:before` - the interceptor's before function\n     - `:after`  - the interceptor's after function\n\n  Example use:\n\n      #!clj\n      (def my-interceptor\n        (->interceptor\n         :id     :my-interceptor\n         :before (fn [context]\n                   ... modifies and returns `context`)\n         :after  (fn [context]\n                   ... modifies and returns `context`)))\n\n  Notes:\n\n    - `:before` functions modify and return their `context` argument. Sometimes they\n      only side effect, in which case, they'll perform the side effect and return\n      `context` unchanged.\n    - `:before` functions often modify the `:coeffects` map within `context` and,\n      if they do, then they should use the utility functions `get-coeffect` and\n      `assoc-coeffect`.\n    - `:after` functions modify and return their `context` argument. Sometimes they\n      only side effect, in which case, they'll perform the side effect and return\n      `context` unchanged.\n    - `:after` functions often modify the `:effects` map within `context` and,\n      if they do, then they should use the utility functions `get-effect`\n      and `assoc-effect`\"\n  {:api-docs/heading \"Writing Interceptors\"}\n  [& {:as m :keys [id before after]}]\n  (utils/apply-kw interceptor/->interceptor m))\n\n(defn get-coeffect\n  \"A utility function, typically used when writing an interceptor's `:before` function.\n\n   When called with one argument, it returns the `:coeffects` map from within that `context`.\n\n   When called with two or three arguments, behaves like `clojure.core/get` and\n   returns the value mapped to `key` in the `:coeffects` map within `context`, `not-found` or\n   `nil` if `key` is not present.\"\n  {:api-docs/heading \"Writing Interceptors\"}\n  ([context]\n   (interceptor/get-coeffect context))\n  ([context key]\n   (interceptor/get-coeffect context key))\n  ([context key not-found]\n   (interceptor/get-coeffect context key not-found)))\n\n(defn assoc-coeffect\n  \"A utility function, typically used when writing an interceptor's `:before` function.\n\n   Adds or updates a key/value pair in the `:coeffects` map within `context`. \"\n  {:api-docs/heading \"Writing Interceptors\"}\n  [context key value]\n  (interceptor/assoc-coeffect context key value))\n\n(defn get-effect\n  \"A utility function, used when writing interceptors, typically within an `:after` function.\n\n   When called with one argument, returns the `:effects` map from the `context`.\n\n   When called with two or three arguments, behaves like `clojure.core/get` and\n   returns the value mapped to `key` in the effects map, `not-found` or\n   `nil` if `key` is not present.\"\n  {:api-docs/heading \"Writing Interceptors\"}\n  ([context]\n   (interceptor/get-effect context))\n  ([context key]\n   (interceptor/get-effect context key))\n  ([context key not-found]\n   (interceptor/get-effect context key not-found)))\n\n(defn assoc-effect\n  \"A utility function, typically used when writing an interceptor's `:after` function.\n\n   Adds or updates a key/value pair in the `:effects` map within `context`. \"\n  {:api-docs/heading \"Writing Interceptors\"}\n  [context key value]\n  (interceptor/assoc-effect context key value))\n\n(defn enqueue\n  \"A utility function, used when writing an interceptor's `:before` function.\n\n  Adds the given collection of `interceptors` to those already in `context's`\n  execution `:queue`. It returns the updated `context`.\n\n  So, it provides a way for one interceptor to add more interceptors to the\n  currently executing interceptor chain.\n  \"\n  {:api-docs/heading \"Writing Interceptors\"}\n  [context interceptors]\n  (interceptor/enqueue context interceptors))\n\n;; --  logging ----------------------------------------------------------------\n\n(defn set-loggers!\n  \"re-frame outputs warnings and errors via the API function `console`\n   which, by default, delegates to `js/console`'s default implementation for\n  `log`, `error`, `warn`, `debug`, `group` and `groupEnd`. But, using this function,\n   you can override that behaviour with your own functions.\n\n  The argument `new-loggers` should be a map containing a subset of they keys\n  for the standard `loggers`, namely  `:log` `:error` `:warn` `:debug` `:group`\n  or `:groupEnd`.\n\n  Example Usage:\n\n      #!clj\n      (defn my-logger      ;; my alternative logging function\n        [& args]\n        (post-it-somewhere (apply str args)))\n\n      ;; now install my alternative loggers\n      (re-frame.core/set-loggers!  {:warn my-logger :log my-logger})\n   \"\n  {:api-docs/heading \"Logging\"}\n  [new-loggers]\n  (loggers/set-loggers! new-loggers))\n\n(defn console\n  \"A utility logging function which is used internally within re-frame to produce\n  warnings and other output. It can also be used by libraries which\n  extend re-frame, such as effect handlers.\n\n  By default, it will output the given `args` to `js/console` at the given log `level`.\n  However, an application using re-frame can redirect `console` output via `set-loggers!`.\n\n  `level` can be one of `:log`, `:error`, `:warn`, `:debug`, `:group` or `:groupEnd`.\n\n  Example usage:\n\n      #!clj\n      (console :error \\\"Sure enough it happened:\\\" a-var \\\"and\\\" another)\n      (console :warn \\\"Possible breach of containment wall at:\\\" dt)\n  \"\n  {:api-docs/heading \"Logging\"}\n  [level & args]\n  (apply loggers/console level args))\n\n;; -- unit testing ------------------------------------------------------------\n\n(defn make-restore-fn\n  \"This is a utility function, typically used in testing.\n\n  It checkpoints the current state of re-frame and returns a function which, when\n  later called, will restore re-frame to the checkpointed state.\n\n  The checkpoint includes `app-db`, all registered handlers and all subscriptions.\n  \"\n  {:api-docs/heading \"Miscellaneous\"}\n  []\n  (let [handlers @registrar/kind->id->handler\n        app-db   @db/app-db\n        subs-cache @subs/query->reaction]\n    (fn []\n      ;; call `dispose!` on all current subscriptions which\n      ;; didn't originally exist.\n      (let [original-subs (set (vals subs-cache))\n            current-subs  (set (vals @subs/query->reaction))]\n        (doseq [sub (set/difference current-subs original-subs)]\n          (interop/dispose! sub)))\n\n      ;; Reset the atoms\n      ;; We don't need to reset subs/query->reaction, as\n      ;; disposing of the subs removes them from the cache anyway\n      (reset! registrar/kind->id->handler handlers)\n      (reset! db/app-db app-db)\n      nil)))\n\n(defn purge-event-queue\n  \"Removes all events currently queued for processing\"\n  {:api-docs/heading \"Miscellaneous\"}\n  []\n  (router/purge re-frame.router/event-queue))\n\n;; -- Event Processing Callbacks  ---------------------------------------------\n\n(defn add-post-event-callback\n  \"Registers the given function `f` to be called after each event is processed.\n\n   `f` will be called with two arguments:\n\n    - `event`: a vector. The event just processed.\n    - `queue`: a PersistentQueue, possibly empty, of events yet to be processed.\n\n   This facility is useful in advanced cases like:\n\n     - you are implementing a complex bootstrap pipeline\n     - you want to create your own handling infrastructure, with perhaps multiple\n       handlers for the one event, etc.  Hook in here.\n     - libraries providing 'isomorphic javascript' rendering on  Nodejs or Nashorn.\n\n  `id` is typically a keyword. If it supplied when an `f` is added, it can be\n  subsequently be used to identify it for removal. See `remove-post-event-callback`.\n  \"\n  {:api-docs/heading \"Miscellaneous\"}\n  ([f]\n   (add-post-event-callback f f))   ;; use f as its own identifier\n  ([id f]\n   (router/add-post-event-callback re-frame.router/event-queue id f)))\n\n(defn remove-post-event-callback\n  \"Unregisters a post event callback function, identified by `id`.\n\n  Such a function must have been previously registered via `add-post-event-callback`\"\n  {:api-docs/heading \"Miscellaneous\"}\n  [id]\n  (router/remove-post-event-callback re-frame.router/event-queue id))\n\n;; --  Deprecation ------------------------------------------------------------\n;; Assisting the v0.7.x ->  v0.8.x transition.\n(defn register-handler\n  \"Deprecated. Use `reg-event-db` instead.\"\n  {:deprecated \"0.8.0\"\n   :api-docs/heading \"Deprecated\"}\n  [& args]\n  (console :warn  \"re-frame: \\\"register-handler\\\" has been renamed \\\"reg-event-db\\\" (look for registration of \" (str (first args)) \")\")\n  (apply reg-event-db args))\n\n(defn register-sub\n  \"Deprecated. Use `reg-sub-raw` instead.\"\n  {:deprecated \"0.8.0\"\n   :api-docs/heading \"Deprecated\"}\n  [& args]\n  (console :warn  \"re-frame: \\\"register-sub\\\" is used to register the event \" (str (first args)) \" but it is a deprecated part of the API. Please use \\\"reg-sub-raw\\\" instead.\")\n  (apply reg-sub-raw args))\n","~:reader-features",["^B",["~:cljs"]],"~:used-var-namespaces",["^B",["^J","^Q","^T","^W","^S","^X","^Y","~$js","^11","^15","^N","^18","^V","^L","^P","^13","^D"]],"~:cljc",true,"~:source-map-compact",["^ ","mappings","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","names",["re-frame.core/dispatch","event","re-frame.router/dispatch","re-frame.core/dispatch-sync","re-frame.router/dispatch-sync","var_args","G__11373","re-frame.core/reg-event-db","js/Error","id","handler","re_frame.core.reg_event_db","interceptors","re-frame.events/register","re-frame.cofx/inject-db","re-frame.fx/do-fx","re-frame.std-interceptors/inject-global-interceptors","re-frame.std-interceptors/db-handler->interceptor","G__11382","re-frame.core/reg-event-fx","re_frame.core.reg_event_fx","re-frame.std-interceptors/fx-handler->interceptor","G__11394","re-frame.core/reg-event-ctx","re_frame.core.reg_event_ctx","re-frame.std-interceptors/ctx-handler->interceptor","G__11436","re-frame.core/clear-event","re_frame.registrar.clear_handlers","re-frame.events/kind","args__5882__auto__","len__5876__auto__","i__5877__auto__","argseq__5883__auto__","cljs.core/IndexedSeq","re-frame.core/reg-sub","seq11483","G__11484","cljs.core/first","cljs.core/next","self__5861__auto__","query-id","args","cljs.core.apply","re-frame.subs/reg-sub","G__11536","re-frame.core/subscribe","query","re_frame.subs.subscribe","dynv","G__11563","re-frame.core/clear-sub","re-frame.subs/kind","re-frame.core/reg-sub-raw","handler-fn","re-frame.registrar/register-handler","re-frame.core/clear-subscription-cache!","re-frame.subs/clear-subscription-cache!","re-frame.core/reg-fx","re-frame.fx/reg-fx","G__11585","re-frame.core/clear-fx","re-frame.fx/kind","re-frame.core/reg-cofx","re-frame.cofx/reg-cofx","G__11593","re-frame.core/inject-cofx","re_frame.cofx.inject_cofx","value","G__11614","re-frame.core/clear-cofx","re-frame.cofx/kind","re-frame.core/reg-event-error-handler","re-frame.interceptor/default-error-handler","re-frame.core/debug","re-frame.std-interceptors/debug","re-frame.core/path","seq11621","self__5862__auto__","cljs.core/seq","re-frame.std-interceptors/path","re-frame.core/enrich","f","re-frame.std-interceptors/enrich","re-frame.core/unwrap","re-frame.std-interceptors/unwrap","re-frame.core/trim-v","re-frame.std-interceptors/trim-v","re-frame.core/after","re-frame.std-interceptors/after","re-frame.core/on-changes","seq11645","G__11646","G__11647","out-path","in-paths","re-frame.std-interceptors/on-changes","re-frame.core/reg-global-interceptor","interceptor","re-frame.settings/reg-global-interceptor","G__11672","re-frame.core/clear-global-interceptor","re_frame.settings.clear_global_interceptors","re-frame.core/->interceptor","p__11694","map__11695","cljs.core/--destructure-map","cljs.core.get","seq11685","m","before","after","re_frame.utils.apply_kw","re-frame.interceptor/->interceptor","G__11709","re-frame.core/get-coeffect","context","re_frame.interceptor.get_coeffect","key","not-found","re-frame.core/assoc-coeffect","re-frame.interceptor/assoc-coeffect","G__11727","re-frame.core/get-effect","re_frame.interceptor.get_effect","re-frame.core/assoc-effect","re-frame.interceptor/assoc-effect","re-frame.core/enqueue","re-frame.interceptor/enqueue","re-frame.core/set-loggers!","new-loggers","re-frame.loggers/set-loggers!","re-frame.core/console","seq11737","G__11738","level","re-frame.loggers/console","re-frame.core/make-restore-fn","cljs.core/deref","handlers","re-frame.registrar/kind->id->handler","app-db","re-frame.db/app-db","subs-cache","re-frame.subs/query->reaction","original-subs","cljs.core/set","cljs.core/vals","current-subs","seq__11750","chunk__11751","count__11752","i__11753","temp__5823__auto__","cljs.core/chunked-seq?","c__5673__auto__","cljs.core/chunk-first","cljs.core/chunk-rest","cljs.core/count","sub","clojure.set.difference","re-frame.interop/dispose!","cljs.core/reset!","re-frame.core/purge-event-queue","re-frame.router/event-queue","G__11768","re-frame.core/add-post-event-callback","re_frame.core.add_post_event_callback","re-frame.core/remove-post-event-callback","re-frame.core/register-handler","seq11771","re_frame.core.console","re-frame.core/register-sub","seq11809"]],"~:used-vars",["^B",["~$re-frame.router/purge","~$cljs.core/--destructure-map","~$re-frame.core/add-post-event-callback","~$re-frame.core/remove-post-event-callback","~$re-frame.interceptor/get-effect","~$re-frame.fx/kind","~$re-frame.core/clear-sub","~$re-frame.fx/reg-fx","~$re-frame.db/app-db","~$re-frame.core/clear-event","~$re-frame.core/register-sub","~$re-frame.core/assoc-coeffect","~$re-frame.fx/do-fx","~$re-frame.interop/dispose!","~$re-frame.loggers/set-loggers!","~$re-frame.std-interceptors/debug","~$cljs.core/IndexedSeq","~$re-frame.core/dispatch","~$re-frame.interceptor/->interceptor","~$re-frame.core/on-changes","~$cljs.core/count","~$cljs.core/deref","~$re-frame.events/register","~$cljs.core/seq","~$cljs.core/chunk-first","~$re-frame.settings/reg-global-interceptor","~$cljs.core/apply","~$re-frame.core/unwrap","~$re-frame.core/reg-event-error-handler","~$re-frame.events/kind","~$re-frame.core/enrich","~$re-frame.registrar/clear-handlers","~$re-frame.loggers/console","~$re-frame.core/get-coeffect","~$re-frame.std-interceptors/inject-global-interceptors","~$re-frame.core/assoc-effect","~$cljs.core/chunk-rest","~$re-frame.std-interceptors/trim-v","~$re-frame.core/reg-event-db","~$cljs.core/set","~$re-frame.core/reg-sub-raw","~$re-frame.core/dispatch-sync","~$re-frame.interceptor/enqueue","~$re-frame.core/subscribe","~$re-frame.std-interceptors/db-handler->interceptor","~$re-frame.core/trim-v","~$cljs.core/reset!","~$re-frame.registrar/register-handler","~$re-frame.subs/clear-subscription-cache!","~$re-frame.subs/kind","~$re-frame.core/reg-fx","~$re-frame.core/purge-event-queue","~$re-frame.interceptor/default-error-handler","~$re-frame.core/get-effect","~$cljs.core/vals","~$cljs.core/get","~$re-frame.std-interceptors/enrich","~$re-frame.subs/subscribe","~$re-frame.core/clear-cofx","~$re-frame.core/reg-event-ctx","~$re-frame.std-interceptors/ctx-handler->interceptor","~$cljs.core/-nth","~$re-frame.core/reg-event-fx","~$re-frame.interceptor/assoc-coeffect","~$re-frame.core/clear-fx","~$re-frame.cofx/reg-cofx","~$clojure.set/difference","~$re-frame.cofx/inject-cofx","~$re-frame.std-interceptors/fx-handler->interceptor","~$re-frame.subs/reg-sub","~$re-frame.cofx/kind","~$re-frame.core/register-handler","~$re-frame.router/dispatch-sync","~$re-frame.std-interceptors/after","~$re-frame.router/add-post-event-callback","~$re-frame.core/->interceptor","~$re-frame.core/inject-cofx","~$cljs.core/next","~$re-frame.core/set-loggers!","~$re-frame.interceptor/get-coeffect","~$re-frame.subs/query->reaction","~$re-frame.core/make-restore-fn","~$re-frame.interceptor/assoc-effect","~$re-frame.core/clear-subscription-cache!","~$re-frame.core/reg-sub","~$re-frame.utils/apply-kw","~$re-frame.cofx/inject-db","~$re-frame.router/event-queue","~$re-frame.std-interceptors/path","~$re-frame.core/clear-global-interceptor","~$re-frame.core/console","~$re-frame.router/remove-post-event-callback","~$re-frame.core/reg-global-interceptor","~$re-frame.core/reg-cofx","~$re-frame.router/dispatch","~$cljs.core/first","~$re-frame.core/path","~$re-frame.core/enqueue","~$re-frame.core/debug","~$re-frame.std-interceptors/unwrap","~$js/Error","~$re-frame.std-interceptors/on-changes","~$re-frame.registrar/kind->id->handler","~$re-frame.settings/clear-global-interceptors","~$cljs.core/chunked-seq?","~$re-frame.core/after"]]],"~:cache-keys",["~#cmap",[["^1L","reagent/impl/batching.cljs"],["1b9a181b5c7ed3557768d2ea0c66f5616aef5e97","~:shadow.build.compiler/resolve",["^ ","~:require-id",null,"~:deps-ids",["^B",[]],"~:deps-syms",["^[","^Y","~$reagent.debug","~$reagent.impl.util"]]],["^1L","goog/dom/tagname.js"],["5894b81ddad9694d9b92153e1834889eb8533444","^4B",["^ ","^4C",null,"^4D",["^B",[]],"^4E",["^[","~$goog.dom.HtmlElement"]]],["^1L","goog/labs/useragent/platform.js"],["5894b81ddad9694d9b92153e1834889eb8533444","^4B",["^ ","^4C",null,"^4D",["^B",[]],"^4E",["^[","~$goog.string.internal","~$goog.labs.userAgent.util","~$goog.labs.userAgent.highEntropy.highEntropyValue","~$goog.labs.userAgent.highEntropy.highEntropyData","~$goog.labs.userAgent"]]],["^1L","goog/math/math.js"],["5894b81ddad9694d9b92153e1834889eb8533444","^4B",["^ ","^4C",null,"^4D",["^B",[]],"^4E",["^[","~$goog.asserts"]]],["^1L","goog/html/trustedtypes.js"],["5894b81ddad9694d9b92153e1834889eb8533444","^4B",["^ ","^4C",null,"^4D",["^B",[]],"^4E",["^["]]],["^1L","goog/events/eventtype.js"],["5894b81ddad9694d9b92153e1834889eb8533444","^4B",["^ ","^4C",null,"^4D",["^B",[]],"^4E",["^[","~$goog.events.eventTypeHelpers","~$goog.userAgent"]]],["^1L","goog/labs/useragent/browser.js"],["5894b81ddad9694d9b92153e1834889eb8533444","^4B",["^ ","^4C",null,"^4D",["^B",[]],"^4E",["^[","^4J","^4K","~$goog.labs.userAgent.chromiumRebrands","^4N","^4I","^4L","^4M"]]],["^1L","goog/html/safeurl.js"],["5894b81ddad9694d9b92153e1834889eb8533444","^4B",["^ ","^4C",null,"^4D",["^B",[]],"^4E",["^[","^4N","~$goog.fs.url","~$goog.html.TrustedResourceUrl","~$goog.string.Const","~$goog.string.TypedString","^4I"]]],["^1L","re_frame/loggers.cljc"],["74e132cc593ed2d72a5d4874954c58677a905f0e","^4B",["^ ","^4C",null,"^4D",["^B",[]],"^4E",["^[","^Y","^N"]]],["^1L","goog/array/array.js"],["5894b81ddad9694d9b92153e1834889eb8533444","^4B",["^ ","^4C",null,"^4D",["^B",[]],"^4E",["^[","^4N"]]],["^1L","reagent/impl/util.cljs"],["1b9a181b5c7ed3557768d2ea0c66f5616aef5e97","^4B",["^ ","^4C",null,"^4D",["^B",[]],"^4E",["^[","^Y","~$clojure.string","~$clojure.walk","~$goog.object","^4F"]]],["^1L","goog/useragent/useragent.js"],["5894b81ddad9694d9b92153e1834889eb8533444","^4B",["^ ","^4C",null,"^4D",["^B",[]],"^4E",["^[","~$goog.labs.userAgent.browser","~$goog.labs.userAgent.engine","~$goog.labs.userAgent.platform","^4J","~$goog.reflect","^4I"]]],["^1L","re_frame/router.cljc"],["74e132cc593ed2d72a5d4874954c58677a905f0e","^4B",["^ ","^4C",null,"^4D",["^B",[]],"^4E",["^[","^Y","^T","^J","^V","~$re-frame.trace"]]],["^1L","goog/debug/error.js"],["5894b81ddad9694d9b92153e1834889eb8533444","^4B",["^ ","^4C",null,"^4D",["^B",[]],"^4E",["^["]]],["^1L","goog/flags/flags.js"],["5894b81ddad9694d9b92153e1834889eb8533444","^4B",["^ ","^4C",null,"^4D",["^B",[]],"^4E",["^["]]],["^1L","goog/events/events.js"],["5894b81ddad9694d9b92153e1834889eb8533444","^4B",["^ ","^4C",null,"^4D",["^B",[]],"^4E",["^[","^4N","~$goog.debug.entryPointRegistry","~$goog.events.BrowserEvent","~$goog.events.BrowserFeature","~$goog.events.Listenable","~$goog.events.ListenerMap"]]],["^1L","re_frame/registrar.cljc"],["74e132cc593ed2d72a5d4874954c58677a905f0e","^4B",["^ ","^4C",null,"^4D",["^B",[]],"^4E",["^[","^Y","^J","^V","^W"]]],["^1L","goog/events/browserfeature.js"],["5894b81ddad9694d9b92153e1834889eb8533444","^4B",["^ ","^4C",null,"^4D",["^B",[]],"^4E",["^["]]],["^1L","goog/dom/nodetype.js"],["5894b81ddad9694d9b92153e1834889eb8533444","^4B",["^ ","^4C",null,"^4D",["^B",[]],"^4E",["^["]]],["^1L","goog/labs/useragent/highentropy/highentropyvalue.js"],["5894b81ddad9694d9b92153e1834889eb8533444","^4B",["^ ","^4C",null,"^4D",["^B",[]],"^4E",["^[","^4J","^4I"]]],["^1L","reagent/ratom.cljs"],["1b9a181b5c7ed3557768d2ea0c66f5616aef5e97","^4B",["^ ","^4C",null,"^4D",["^B",[]],"^4E",["^[","^Y","^4G","^4F","~$reagent.impl.batching","^N","^4X"]]],["^1L","re_frame/interop.cljs"],["74e132cc593ed2d72a5d4874954c58677a905f0e","^4B",["^ ","^4C",null,"^4D",["^B",[]],"^4E",["^[","^Y","~$goog.async.nextTick","~$goog.events","~$reagent.core","~$reagent.ratom"]]],["^1L","goog/disposable/disposable.js"],["5894b81ddad9694d9b92153e1834889eb8533444","^4B",["^ ","^4C",null,"^4D",["^B",[]],"^4E",["^[","~$goog.disposable.IDisposable","~$goog.dispose","~$goog.disposeAll"]]],["^1L","goog/string/typedstring.js"],["5894b81ddad9694d9b92153e1834889eb8533444","^4B",["^ ","^4C",null,"^4D",["^B",[]],"^4E",["^["]]],["^1L","shadow/js.js"],["3369d68a8899b66c4dfa49e568f61626a1f40be6","^4B",["^ ","^4C",null,"^4D",["^B",[]],"^4E",["^["]]],["^1L","goog/object/object.js"],["5894b81ddad9694d9b92153e1834889eb8533444","^4B",["^ ","^4C",null,"^4D",["^B",[]],"^4E",["^["]]],["^1L","reagent/impl/template.cljs"],["1b9a181b5c7ed3557768d2ea0c66f5616aef5e97","^4B",["^ ","^4C",null,"^4D",["^B",[]],"^4E",["^[","^Y","^?","^4V","^4G","~$reagent.impl.component","~$reagent.impl.input","~$reagent.impl.protocols","^5;","^4F","^4X"]]],["^1L","goog/dom/asserts.js"],["5894b81ddad9694d9b92153e1834889eb8533444","^4B",["^ ","^4C",null,"^4D",["^B",[]],"^4E",["^[","^4N"]]],"~:SHADOW-TIMESTAMP",[1768666614000,1768666614000,1768666613000],["^1L","re_frame/events.cljc"],["74e132cc593ed2d72a5d4874954c58677a905f0e","^4B",["^ ","^4C",null,"^4D",["^B",[]],"^4E",["^[","^Y","^13","^15","^J","^X","^V","^Q","^51"]]],["^1L","goog/math/long.js"],["5894b81ddad9694d9b92153e1834889eb8533444","^4B",["^ ","^4C",null,"^4D",["^B",[]],"^4E",["^[","^4N","^50"]]],["^1L","goog/events/listener.js"],["5894b81ddad9694d9b92153e1834889eb8533444","^4B",["^ ","^4C",null,"^4D",["^B",[]],"^4E",["^[","~$goog.events.ListenableKey"]]],["^1L","goog/html/trustedresourceurl.js"],["5894b81ddad9694d9b92153e1834889eb8533444","^4B",["^ ","^4C",null,"^4D",["^B",[]],"^4E",["^[","^4N","~$goog.fs.blob","^4R","~$goog.html.SafeScript","~$goog.html.trustedtypes","^4T","^4U"]]],["^1L","goog/events/listenermap.js"],["5894b81ddad9694d9b92153e1834889eb8533444","^4B",["^ ","^4C",null,"^4D",["^B",[]],"^4E",["^[","~$goog.array","~$goog.events.Listener","^4X"]]],["^1L","goog/events/eventid.js"],["5894b81ddad9694d9b92153e1834889eb8533444","^4B",["^ ","^4C",null,"^4D",["^B",[]],"^4E",["^["]]],["^1L","goog/string/internal.js"],["5894b81ddad9694d9b92153e1834889eb8533444","^4B",["^ ","^4C",null,"^4D",["^B",[]],"^4E",["^["]]],["^1L","goog/functions/functions.js"],["5894b81ddad9694d9b92153e1834889eb8533444","^4B",["^ ","^4C",null,"^4D",["^B",[]],"^4E",["^["]]],["^1L","goog/html/safestyle.js"],["5894b81ddad9694d9b92153e1834889eb8533444","^4B",["^ ","^4C",null,"^4D",["^B",[]],"^4E",["^[","^4T","~$goog.html.SafeUrl","^4U","^4N","^4I"]]],["^1L","goog/dom/safe.js"],["5894b81ddad9694d9b92153e1834889eb8533444","^4B",["^ ","^4C",null,"^4D",["^B",[]],"^4E",["^[","^4N","~$goog.asserts.dom","~$goog.dom.asserts","~$goog.functions","~$goog.html.SafeHtml","^5E","~$goog.html.SafeStyle","^5I","^4S","~$goog.html.uncheckedconversions","^4T","^4I"]]],["^1L","goog/asserts/dom.js"],["5894b81ddad9694d9b92153e1834889eb8533444","^4B",["^ ","^4C",null,"^4D",["^B",[]],"^4E",["^[","~$goog.dom.TagName","^4N","~$goog.dom.element"]]],["^1L","reagent/impl/component.cljs"],["1b9a181b5c7ed3557768d2ea0c66f5616aef5e97","^4B",["^ ","^4C",null,"^4D",["^B",[]],"^4E",["^[","^Y","^4X","^?","^4G","^57","^5A","^5;","^4F"]]],["^1L","clojure/walk.cljs"],["bb708c133efd2471c681d172c839d7d979202b70","^4B",["^ ","^4C",null,"^4D",["^B",[]],"^4E",["^[","^Y"]]],["^1L","goog/html/safehtml.js"],["5894b81ddad9694d9b92153e1834889eb8533444","^4B",["^ ","^4C",null,"^4D",["^B",[]],"^4E",["^[","^4T","^5E","^5N","~$goog.html.SafeStyleSheet","^5I","^5P","^4S","^4U","^4N","^4Y","^5G","^4X","^4I","~$goog.dom.tags","^5F"]]],["^1L","goog/dom/tags.js"],["5894b81ddad9694d9b92153e1834889eb8533444","^4B",["^ ","^4C",null,"^4D",["^B",[]],"^4E",["^[","^4X"]]],["^1L","goog/math/size.js"],["5894b81ddad9694d9b92153e1834889eb8533444","^4B",["^ ","^4C",null,"^4D",["^B",[]],"^4E",["^["]]],["^1L","goog/labs/useragent/engine.js"],["5894b81ddad9694d9b92153e1834889eb8533444","^4B",["^ ","^4C",null,"^4D",["^B",[]],"^4E",["^[","^5G","^4I","^4J"]]],["^1L","goog/fs/blob.js"],["5894b81ddad9694d9b92153e1834889eb8533444","^4B",["^ ","^4C",null,"^4D",["^B",[]],"^4E",["^["]]],["^1L","re_frame/settings.cljc"],["74e132cc593ed2d72a5d4874954c58677a905f0e","^4B",["^ ","^4C",null,"^4D",["^B",[]],"^4E",["^[","^Y","^J","^V"]]],["^1L","goog/dom/dom.js"],["5894b81ddad9694d9b92153e1834889eb8533444","^4B",["^ ","^4C",null,"^4D",["^B",[]],"^4E",["^[","^5G","^4N","^5J","~$goog.dom.BrowserFeature","~$goog.dom.NodeType","^5P","~$goog.dom.safe","^5M","^5O","~$goog.math.Coordinate","~$goog.math.Size","^4X","~$goog.string","^4T","~$goog.string.Unicode","^4P"]]],["^1L","goog/asserts/asserts.js"],["5894b81ddad9694d9b92153e1834889eb8533444","^4B",["^ ","^4C",null,"^4D",["^B",[]],"^4E",["^[","~$goog.debug.Error","^5U"]]],["^1L","reagent/impl/protocols.cljs"],["1b9a181b5c7ed3557768d2ea0c66f5616aef5e97","^4B",["^ ","^4C",null,"^4D",["^B",[]],"^4E",["^[","^Y"]]],["^1L","goog/uri/uri.js"],["5894b81ddad9694d9b92153e1834889eb8533444","^4B",["^ ","^4C",null,"^4D",["^B",[]],"^4E",["^[","^5G","^4N","~$goog.collections.maps","^5Y","~$goog.structs","~$goog.uri.utils","~$goog.uri.utils.ComponentIndex","~$goog.uri.utils.StandardQueryParam"]]],["^1L","goog/labs/useragent/highentropy/highentropydata.js"],["5894b81ddad9694d9b92153e1834889eb8533444","^4B",["^ ","^4C",null,"^4D",["^B",[]],"^4E",["^[","^4K"]]],["^1L","goog/collections/maps.js"],["5894b81ddad9694d9b92153e1834889eb8533444","^4B",["^ ","^4C",null,"^4D",["^B",[]],"^4E",["^["]]],["^1L","goog/events/eventtypehelpers.js"],["5894b81ddad9694d9b92153e1834889eb8533444","^4B",["^ ","^4C",null,"^4D",["^B",[]],"^4E",["^[","^54","^4P"]]],["^1L","re_frame/db.cljc"],["74e132cc593ed2d72a5d4874954c58677a905f0e","^4B",["^ ","^4C",null,"^4D",["^B",[]],"^4E",["^[","^Y","^J"]]],["^1L","goog/disposable/idisposable.js"],["5894b81ddad9694d9b92153e1834889eb8533444","^4B",["^ ","^4C",null,"^4D",["^B",[]],"^4E",["^["]]],["^1L","goog/fs/url.js"],["5894b81ddad9694d9b92153e1834889eb8533444","^4B",["^ ","^4C",null,"^4D",["^B",[]],"^4E",["^["]]],["^1L","goog/base.js"],["5894b81ddad9694d9b92153e1834889eb8533444","^4B",["^ ","^4C",null,"^4D",["^B",[]],"^4E",[]]],["^1L","goog/structs/structs.js"],["5894b81ddad9694d9b92153e1834889eb8533444","^4B",["^ ","^4C",null,"^4D",["^B",[]],"^4E",["^[","^5G","^4X"]]],["^1L","goog/disposable/dispose.js"],["5894b81ddad9694d9b92153e1834889eb8533444","^4B",["^ ","^4C",null,"^4D",["^B",[]],"^4E",["^["]]],["^1L","clojure/string.cljs"],["bb708c133efd2471c681d172c839d7d979202b70","^4B",["^ ","^4C",null,"^4D",["^B",[]],"^4E",["^[","^Y","^5Y","~$goog.string.StringBuffer"]]],["^1L","re_frame/cofx.cljc"],["74e132cc593ed2d72a5d4874954c58677a905f0e","^4B",["^ ","^4C",null,"^4D",["^B",[]],"^4E",["^[","^Y","^13","^Q","^X","^V"]]],["~:shadow.build.js-support/require","react"],["^?","shadow.js.shim.module$react.js","require","^4B",["^ ","^4C",null,"^4D",["^B",[]],"^4E",["^[","~$shadow.js"]]],["^1L","goog/debug/entrypointregistry.js"],["5894b81ddad9694d9b92153e1834889eb8533444","^4B",["^ ","^4C",null,"^4D",["^B",[]],"^4E",["^[","^4N"]]],["^1L","goog/string/string.js"],["5894b81ddad9694d9b92153e1834889eb8533444","^4B",["^ ","^4C",null,"^4D",["^B",[]],"^4E",["^[","^5V","^5O","^4T","^4I"]]],["^1L","re_frame/interceptor.cljc"],["74e132cc593ed2d72a5d4874954c58677a905f0e","^4B",["^ ","^4C",null,"^4D",["^B",[]],"^4E",["^[","^Y","^V","^J","^51","^X","^15","^N"]]],["^1L","clojure/data.cljs"],["bb708c133efd2471c681d172c839d7d979202b70","^4B",["^ ","^4C",null,"^4D",["^B",[]],"^4E",["^[","^Y","^N"]]],["^1L","goog/reflect/reflect.js"],["5894b81ddad9694d9b92153e1834889eb8533444","^4B",["^ ","^4C",null,"^4D",["^B",[]],"^4E",["^["]]],["^1L","goog/labs/useragent/util.js"],["5894b81ddad9694d9b92153e1834889eb8533444","^4B",["^ ","^4C",null,"^4D",["^B",[]],"^4E",["^[","^4I","^4M"]]],["^1L","reagent/core.cljs"],["1b9a181b5c7ed3557768d2ea0c66f5616aef5e97","^4B",["^ ","^4C",null,"^4D",["^B",[]],"^4E",["^[","^Y","^?","~$reagent.impl.template","^5?","^4G","^57","^5A","^5;","^4F"]]],["^1L","goog/debug/debug.js"],["5894b81ddad9694d9b92153e1834889eb8533444","^4B",["^ ","^4C",null,"^4D",["^B",[]],"^4E",["^[","^5G","~$goog.debug.errorcontext"]]],["^1L","goog/string/stringbuffer.js"],["5894b81ddad9694d9b92153e1834889eb8533444","^4B",["^ ","^4C",null,"^4D",["^B",[]],"^4E",["^["]]],["^1L","goog/math/coordinate.js"],["5894b81ddad9694d9b92153e1834889eb8533444","^4B",["^ ","^4C",null,"^4D",["^B",[]],"^4E",["^[","~$goog.math"]]],["^1L","re_frame/std_interceptors.cljc"],["74e132cc593ed2d72a5d4874954c58677a905f0e","^4B",["^ ","^4C",null,"^4D",["^B",[]],"^4E",["^[","^Y","^Q","^V","^W","^13","~$clojure.data","^P","^15","^51"]]],["^1L","goog/debug/errorcontext.js"],["5894b81ddad9694d9b92153e1834889eb8533444","^4B",["^ ","^4C",null,"^4D",["^B",[]],"^4E",["^["]]],["^1L","goog/labs/useragent/chromium_rebrands.js"],["5894b81ddad9694d9b92153e1834889eb8533444","^4B",["^ ","^4C",null,"^4D",["^B",[]],"^4E",["^["]]],["^1L","goog/labs/useragent/useragent.js"],["5894b81ddad9694d9b92153e1834889eb8533444","^4B",["^ ","^4C",null,"^4D",["^B",[]],"^4E",["^[","~$goog.flags"]]],["^1L","goog/async/nexttick.js"],["5894b81ddad9694d9b92153e1834889eb8533444","^4B",["^ ","^4C",null,"^4D",["^B",[]],"^4E",["^[","^52","~$goog.dom","^5P","^5L","^4Y","^4Z"]]],["^1L","goog/dom/element.js"],["5894b81ddad9694d9b92153e1834889eb8533444","^4B",["^ ","^4C",null,"^4D",["^B",[]],"^4E",["^[","^5U","^5P"]]],["^1L","goog/html/uncheckedconversions.js"],["5894b81ddad9694d9b92153e1834889eb8533444","^4B",["^ ","^4C",null,"^4D",["^B",[]],"^4E",["^[","^4N","^5M","^5E","^5N","^5R","^5I","^4S","^4T","^4I"]]],["^1L","re_frame/utils.cljc"],["74e132cc593ed2d72a5d4874954c58677a905f0e","^4B",["^ ","^4C",null,"^4D",["^B",[]],"^4E",["^[","^Y","^V","^J"]]],["^1L","re_frame/fx.cljc"],["74e132cc593ed2d72a5d4874954c58677a905f0e","^4B",["^ ","^4C",null,"^4D",["^B",[]],"^4E",["^[","^Y","^11","^13","^Q","^J","^T","^X","^V","^51"]]],["^1L","reagent/impl/input.cljs"],["1b9a181b5c7ed3557768d2ea0c66f5616aef5e97","^4B",["^ ","^4C",null,"^4D",["^B",[]],"^4E",["^[","^Y","^5?","^57","^5A"]]],["^1L","goog/events/event.js"],["5894b81ddad9694d9b92153e1834889eb8533444","^4B",["^ ","^4C",null,"^4D",["^B",[]],"^4E",["^[","~$goog.Disposable","~$goog.events.EventId"]]],["^1L","goog/dom/htmlelement.js"],["5894b81ddad9694d9b92153e1834889eb8533444","^4B",["^ ","^4C",null,"^4D",["^B",[]],"^4E",["^["]]],["^1L","cljs/core.cljs"],["bb708c133efd2471c681d172c839d7d979202b70","^4B",["^ ","^4C",null,"^4D",["^B",[]],"^4E",["^[","~$goog.math.Long","~$goog.math.Integer","^5Y","^4X","^5G","~$goog.Uri","^65"]]],["^1L","goog/html/safescript.js"],["5894b81ddad9694d9b92153e1834889eb8533444","^4B",["^ ","^4C",null,"^4D",["^B",[]],"^4E",["^[","^4T","^4U","^5F","^4N"]]],["^1L","reagent/debug.cljs"],["1b9a181b5c7ed3557768d2ea0c66f5616aef5e97","^4B",["^ ","^4C",null,"^4D",["^B",[]],"^4E",["^[","^Y"]]],["^1L","goog/html/safestylesheet.js"],["5894b81ddad9694d9b92153e1834889eb8533444","^4B",["^ ","^4C",null,"^4D",["^B",[]],"^4E",["^[","^4T","^5N","^4U","^4X","^4N","^4I"]]],["^1L","goog/events/browserevent.js"],["5894b81ddad9694d9b92153e1834889eb8533444","^4B",["^ ","^4C",null,"^4D",["^B",[]],"^4E",["^[","~$goog.debug","~$goog.events.Event","~$goog.events.EventType","^50","^4P"]]],["^1L","goog/math/integer.js"],["5894b81ddad9694d9b92153e1834889eb8533444","^4B",["^ ","^4C",null,"^4D",["^B",[]],"^4E",["^[","^50"]]],["^1L","goog/dom/browserfeature.js"],["5894b81ddad9694d9b92153e1834889eb8533444","^4B",["^ ","^4C",null,"^4D",["^B",[]],"^4E",["^[","^4P"]]],["^1L","clojure/set.cljs"],["bb708c133efd2471c681d172c839d7d979202b70","^4B",["^ ","^4C",null,"^4D",["^B",[]],"^4E",["^[","^Y"]]],["^1L","goog/uri/utils.js"],["5894b81ddad9694d9b92153e1834889eb8533444","^4B",["^ ","^4C",null,"^4D",["^B",[]],"^4E",["^[","^4N","^5Y"]]],["^1L","goog/string/const.js"],["5894b81ddad9694d9b92153e1834889eb8533444","^4B",["^ ","^4C",null,"^4D",["^B",[]],"^4E",["^[","^4N","^4U"]]],["^1L","goog/disposable/disposeall.js"],["5894b81ddad9694d9b92153e1834889eb8533444","^4B",["^ ","^4C",null,"^4D",["^B",[]],"^4E",["^[","^5="]]],["^1L","goog/events/listenable.js"],["5894b81ddad9694d9b92153e1834889eb8533444","^4B",["^ ","^4C",null,"^4D",["^B",[]],"^4E",["^["]]],["^1L","goog/events/listenablekey.js"],["5894b81ddad9694d9b92153e1834889eb8533444","^4B",["^ ","^4C",null,"^4D",["^B",[]],"^4E",["^["]]],["^1L","re_frame/trace.cljc"],["74e132cc593ed2d72a5d4874954c58677a905f0e","^4B",["^ ","^4C",null,"^4D",["^B",[]],"^4E",["^[","^Y","^J","^V","^5L"]]],["^1L","re_frame/subs.cljc"],["74e132cc593ed2d72a5d4874954c58677a905f0e","^4B",["^ ","^4C",null,"^4D",["^B",[]],"^4E",["^[","^Y","^13","^J","^V","^15","^X","^51"]]],["^1L","re_frame/core.cljc"],["74e132cc593ed2d72a5d4874954c58677a905f0e","^4B",["^ ","^4C",null,"^4D",["^B",[]],"^4E",["^[","^Y","^T","^L","^J","^13","^S","^P","^11","^W","^V","^X","^Q","^18","^15","^N"]]]]],"~:clj-info",["^ ","jar:file:/Users/travisbrown/.m2/repository/org/clojure/clojurescript/1.12.134/clojurescript-1.12.134.jar!/cljs/analyzer/impl/namespaces.cljc",1768666613000,"jar:file:/Users/travisbrown/.m2/repository/net/cgrand/macrovich/0.2.1/macrovich-0.2.1.jar!/net/cgrand/macrovich.cljc",1768666613000,"jar:file:/Users/travisbrown/.m2/repository/org/clojure/clojurescript/1.12.134/clojurescript-1.12.134.jar!/cljs/analyzer/passes/and_or.cljc",1768666613000,"jar:file:/Users/travisbrown/.m2/repository/reagent/reagent/1.2.0/reagent-1.2.0.jar!/reagent/ratom.clj",1768666613000,"jar:file:/Users/travisbrown/.m2/repository/org/clojure/clojurescript/1.12.134/clojurescript-1.12.134.jar!/cljs/vendor/clojure/tools/reader/impl/inspect.clj",1768666613000,"jar:file:/Users/travisbrown/.m2/repository/org/clojure/clojurescript/1.12.134/clojurescript-1.12.134.jar!/cljs/analyzer/passes.cljc",1768666613000,"jar:file:/Users/travisbrown/.m2/repository/org/clojure/clojurescript/1.12.134/clojurescript-1.12.134.jar!/cljs/js_deps.cljc",1768666613000,"jar:file:/Users/travisbrown/.m2/repository/org/clojure/clojurescript/1.12.134/clojurescript-1.12.134.jar!/cljs/externs.clj",1768666613000,"jar:file:/Users/travisbrown/.m2/repository/org/clojure/clojurescript/1.12.134/clojurescript-1.12.134.jar!/cljs/analyzer/passes/lite.cljc",1768666613000,"jar:file:/Users/travisbrown/.m2/repository/org/clojure/clojurescript/1.12.134/clojurescript-1.12.134.jar!/cljs/env.cljc",1768666613000,"jar:file:/Users/travisbrown/.m2/repository/reagent/reagent/1.2.0/reagent-1.2.0.jar!/reagent/debug.clj",1768666613000,"jar:file:/Users/travisbrown/.m2/repository/reagent/reagent/1.2.0/reagent-1.2.0.jar!/reagent/interop.clj",1768666613000,"jar:file:/Users/travisbrown/.m2/repository/org/clojure/clojurescript/1.12.134/clojurescript-1.12.134.jar!/cljs/tagged_literals.cljc",1768666613000,"jar:file:/Users/travisbrown/.m2/repository/org/clojure/clojurescript/1.12.134/clojurescript-1.12.134.jar!/cljs/analyzer/impl.cljc",1768666613000,"jar:file:/Users/travisbrown/.m2/repository/re-frame/re-frame/1.4.3/re-frame-1.4.3.jar!/re_frame/interop.clj",1768666613000,"jar:file:/Users/travisbrown/.m2/repository/org/clojure/clojurescript/1.12.134/clojurescript-1.12.134.jar!/cljs/vendor/clojure/tools/reader.clj",1768666613000,"jar:file:/Users/travisbrown/.m2/repository/org/clojure/clojurescript/1.12.134/clojurescript-1.12.134.jar!/cljs/core.cljc",1768666613000,"jar:file:/Users/travisbrown/.m2/repository/org/clojure/clojure/1.12.0/clojure-1.12.0.jar!/clojure/core.clj",1759610846000,"jar:file:/Users/travisbrown/.m2/repository/org/clojure/clojurescript/1.12.134/clojurescript-1.12.134.jar!/cljs/compiler.cljc",1768666613000,"jar:file:/Users/travisbrown/.m2/repository/org/clojure/clojurescript/1.12.134/clojurescript-1.12.134.jar!/cljs/source_map.clj",1768666613000,"jar:file:/Users/travisbrown/.m2/repository/org/clojure/clojure/1.12.0/clojure-1.12.0.jar!/clojure/java/io.clj",1759610846000,"jar:file:/Users/travisbrown/.m2/repository/org/clojure/clojurescript/1.12.134/clojurescript-1.12.134.jar!/cljs/source_map/base64_vlq.clj",1768666613000,"jar:file:/Users/travisbrown/.m2/repository/org/clojure/clojure/1.12.0/clojure-1.12.0.jar!/clojure/edn.clj",1759610846000,"jar:file:/Users/travisbrown/.m2/repository/org/clojure/clojure/1.12.0/clojure-1.12.0.jar!/clojure/pprint.clj",1759610846000,"jar:file:/Users/travisbrown/.m2/repository/org/clojure/clojurescript/1.12.134/clojurescript-1.12.134.jar!/cljs/source_map/base64.clj",1768666613000,"jar:file:/Users/travisbrown/.m2/repository/org/clojure/clojurescript/1.12.134/clojurescript-1.12.134.jar!/cljs/instant.clj",1768666613000,"jar:file:/Users/travisbrown/.m2/repository/org/clojure/clojure/1.12.0/clojure-1.12.0.jar!/clojure/set.clj",1759610846000,"jar:file:/Users/travisbrown/.m2/repository/org/clojure/clojure/1.12.0/clojure-1.12.0.jar!/clojure/string.clj",1759610846000,"jar:file:/Users/travisbrown/.m2/repository/org/clojure/clojurescript/1.12.134/clojurescript-1.12.134.jar!/cljs/vendor/clojure/tools/reader/reader_types.clj",1768666613000,"jar:file:/Users/travisbrown/.m2/repository/org/clojure/clojurescript/1.12.134/clojurescript-1.12.134.jar!/cljs/util.cljc",1768666613000,"jar:file:/Users/travisbrown/.m2/repository/org/clojure/clojurescript/1.12.134/clojurescript-1.12.134.jar!/cljs/vendor/clojure/data/json.clj",1768666613000,"jar:file:/Users/travisbrown/.m2/repository/reagent/reagent/1.2.0/reagent-1.2.0.jar!/reagent/core.clj",1768666613000,"jar:file:/Users/travisbrown/.m2/repository/org/clojure/clojurescript/1.12.134/clojurescript-1.12.134.jar!/cljs/vendor/clojure/tools/reader/default_data_readers.clj",1768666613000,"jar:file:/Users/travisbrown/.m2/repository/re-frame/re-frame/1.4.3/re-frame-1.4.3.jar!/re_frame/trace.cljc",1768666613000,"jar:file:/Users/travisbrown/.m2/repository/org/clojure/clojure/1.12.0/clojure-1.12.0.jar!/clojure/instant.clj",1759610846000,"jar:file:/Users/travisbrown/.m2/repository/org/clojure/clojurescript/1.12.134/clojurescript-1.12.134.jar!/cljs/vendor/clojure/tools/reader/impl/errors.clj",1768666613000,"jar:file:/Users/travisbrown/.m2/repository/org/clojure/clojurescript/1.12.134/clojurescript-1.12.134.jar!/cljs/analyzer.cljc",1768666613000],"~:analyzer",["^ ","^3",null,"^4",["^ "],"^5",["^ ","^6","re_frame/core.cljc","^7",1,"^8",5,"^9",1,"^:",18],"^;",["^ ","^<","^=","^>","^?"],"^@",null,"^A",["^B",[]],"^C","^D","^E",["^ "],"^H",null,"^I",["^ ","^J","^J","^K","^L","^M","^N","^O","^P","^Q","^Q","^R","^S","^T","^T","^U","^V","^W","^W","^S","^S","^X","^X","^Y","^Y","^Z","^Q","^[","^[","^10","^11","^12","^13","^14","^X","^11","^11","^15","^15","^N","^N","^16","^T","^17","^W","^18","^18","^V","^V","^L","^L","^19","^J","^1:","^15","^1;","^18","^P","^P","^13","^13"],"^1<",["^B",["^1="]],"~:shadow/js-access-global",["^B",["Error"]],"^1>",["^ ","^1?","^18","^1@","^18","^1A","^18"],"~:defs",["^ ","~$console",["^ ","~:protocol-inline",null,"^5",["^ ","~:api-docs/heading","Logging","^6","re_frame/core.cljc","^:",14,"~:top-fn",["^ ","~:variadic?",true,"~:fixed-arity",1,"~:max-fixed-arity",1,"~:method-params",[["^1D",["~$level","~$args"]]],"~:arglists",["^1D",[["^7K","~$&","^7L"]]],"~:arglists-meta",["^1D",[null]]],"^8",7,"^7",1103,"^9",1103,"^7M",["^1D",["~$quote",["^1D",[["^7K","~$&","^7L"]]]]],"~:doc","A utility logging function which is used internally within re-frame to produce\n  warnings and other output. It can also be used by libraries which\n  extend re-frame, such as effect handlers.\n\n  By default, it will output the given `args` to `js/console` at the given log `level`.\n  However, an application using re-frame can redirect `console` output via `set-loggers!`.\n\n  `level` can be one of `:log`, `:error`, `:warn`, `:debug`, `:group` or `:groupEnd`.\n\n  Example usage:\n\n      #!clj\n      (console :error \"Sure enough it happened:\" a-var \"and\" another)\n      (console :warn \"Possible breach of containment wall at:\" dt)\n  "],"^C","^40","^7E","Logging","^6","re_frame/core.cljc","^:",14,"^7F",["^ ","^7G",true,"^7H",1,"^7I",1,"^7J",[["^1D",["^7K","^7L"]]],"^7M",["^1D",[["^7K","~$&","^7L"]]],"^7N",["^1D",[null]]],"^7J",[["^1D",["^7K","^7L"]]],"~:protocol-impl",null,"^7H",1,"^7N",["^1D",[null]],"^8",1,"^7G",true,"~:methods",[["^ ","^7H",1,"^7G",true,"~:tag","~$any"]],"^7",1103,"~:ret-tag","^7T","^9",1103,"^7I",1,"~:fn-var",true,"^7M",["^1D",[["^7K","~$&","^7L"]]],"^7P","A utility logging function which is used internally within re-frame to produce\n  warnings and other output. It can also be used by libraries which\n  extend re-frame, such as effect handlers.\n\n  By default, it will output the given `args` to `js/console` at the given log `level`.\n  However, an application using re-frame can redirect `console` output via `set-loggers!`.\n\n  `level` can be one of `:log`, `:error`, `:warn`, `:debug`, `:group` or `:groupEnd`.\n\n  Example usage:\n\n      #!clj\n      (console :error \"Sure enough it happened:\" a-var \"and\" another)\n      (console :warn \"Possible breach of containment wall at:\" dt)\n  "],"~$unwrap",["^ ","^5",["^ ","^6","re_frame/core.cljc","^7",845,"^8",42,"^9",845,"^:",48,"^7E","Interceptors"],"^C","^2I","^7E","Interceptors","^6","re_frame/core.cljc","^:",48,"^8",1,"^7",845,"^9",845,"^7S","~$clj","^7P","> New in v1.2.0\n\n   An interceptor which decreases the amount of destructuring necessary in an\n   event handler where the event is structured as a 2-vector of\n   [event-id payload-map].\n\n   It promotes the `payload-map` part to be the event ultimately given to the\n   event handler. Should you want the full original event, it can be found in\n   `coeffects` under the key `:original-event`.\n\n   If a dispatch looked like this:\n\n      #!clj\n       (dispatch [:event-id {:x 1 :y 2 :z 3}])\n\n   Your event handlers can look like this:\n\n      #!clj\n       (reg-event-fx\n         :event-id\n         [... unwrap ...]                    ;; <-- added to the interceptors\n         (fn [{:keys [db]} {:keys [x y z]}]  ;; <-- instead of [_ {:keys [x y z]}]\n           ...)\n   "],"~$on-changes",["^ ","^7D",null,"^5",["^ ","^7E","Interceptors","^6","re_frame/core.cljc","^:",17,"^7F",["^ ","^7G",true,"^7H",2,"^7I",2,"^7J",[["^1D",["~$f","~$out-path","~$in-paths"]]],"^7M",["^1D",[["~$f","^7Z","~$&","^7["]]],"^7N",["^1D",[null]]],"^8",7,"^7",907,"^9",907,"^7M",["^1D",["^7O",["^1D",[["~$f","^7Z","~$&","^7["]]]]],"^7P","Returns an interceptor which will observe N paths within `db`, and if any of them\n  test not `identical?` to their previous value  (as a result of a event handler\n  being run), then it will run `f` to compute a new value, which is then assoc-ed\n  into the given `out-path` within `db`.\n\n  Example Usage:\n\n      #!clj\n      (defn my-f\n        [a-val b-val]\n        ... some computation on a and b in here)\n\n      ;; use it\n      (def my-interceptor (on-changes my-f [:c] [:a] [:b]))\n\n      (reg-event-db\n        :event-id\n        [... my-interceptor ...]  ;; <-- ultimately used here\n        (fn [db v]\n           ...))\n\n\n  If you put this interceptor on handlers which might change paths `:a` or `:b`,\n  it will:\n\n    - call `f` each time the value at path `[:a]` or `[:b]` changes\n    - call `f` with the values extracted from `[:a]` `[:b]`\n    - assoc the return value from `f` into the path  `[:c]`\n  "],"^C","^2A","^7E","Interceptors","^6","re_frame/core.cljc","^:",17,"^7F",["^ ","^7G",true,"^7H",2,"^7I",2,"^7J",[["^1D",["~$f","^7Z","^7["]]],"^7M",["^1D",[["~$f","^7Z","~$&","^7["]]],"^7N",["^1D",[null]]],"^7J",[["^1D",["~$f","^7Z","^7["]]],"^7Q",null,"^7H",2,"^7N",["^1D",[null]],"^8",1,"^7G",true,"^7R",[["^ ","^7H",2,"^7G",true,"^7S","^7T"]],"^7",907,"^7U","^7T","^9",907,"^7I",2,"^7V",true,"^7M",["^1D",[["~$f","^7Z","~$&","^7["]]],"^7P","Returns an interceptor which will observe N paths within `db`, and if any of them\n  test not `identical?` to their previous value  (as a result of a event handler\n  being run), then it will run `f` to compute a new value, which is then assoc-ed\n  into the given `out-path` within `db`.\n\n  Example Usage:\n\n      #!clj\n      (defn my-f\n        [a-val b-val]\n        ... some computation on a and b in here)\n\n      ;; use it\n      (def my-interceptor (on-changes my-f [:c] [:a] [:b]))\n\n      (reg-event-db\n        :event-id\n        [... my-interceptor ...]  ;; <-- ultimately used here\n        (fn [db v]\n           ...))\n\n\n  If you put this interceptor on handlers which might change paths `:a` or `:b`,\n  it will:\n\n    - call `f` each time the value at path `[:a]` or `[:b]` changes\n    - call `f` with the values extracted from `[:a]` `[:b]`\n    - assoc the return value from `f` into the path  `[:c]`\n  "],"~$enrich",["^ ","^7D",null,"^5",["^ ","^6","re_frame/core.cljc","^7",779,"^8",7,"^9",779,"^:",13,"^7M",["^1D",["^7O",["^1D",[["~$f"]]]]],"^7P","Returns an interceptor which will run the given function `f` in the `:after`\n  position.\n\n  `f` is called with two arguments: `db` and `event`, and is expected to\n  return a modified `db`.\n\n  Unlike the `after` interceptor which is only about side effects, `enrich`\n  expects `f` to process and alter the given `db` coeffect in some useful way,\n  contributing to the derived data, flowing vibe.\n\n  If `f` returns `nil`, the `db` value passed to `f` will be returned instead.\n\n  #### Example Use:\n\n  Imagine that todomvc needed to do duplicate detection - if any two todos had\n  the same text, then highlight their background, and report them via a warning\n  at the bottom of the panel.\n\n  Almost any user action (edit text, add new todo, remove a todo) requires a\n  complete reassessment of duplication errors and warnings. E.g. that edit\n  just made might have introduced a new duplicate, or removed one. Same with\n  any todo removal. So we need to re-calculate warnings after any CRUD events\n  associated with the todos list.\n\n  Unless we are careful, we might end up coding subtly different checks\n  for each kind of CRUD operation.  The duplicates check made after\n  'delete todo' event might be subtly different to that done after an\n  editing operation. Nice and efficient, but fiddly. A bug generator\n  approach.\n\n  So, instead, we create an `f` which recalculates ALL warnings from scratch\n  every time there is ANY change. It will inspect all the todos, and\n  reset ALL FLAGS every time (overwriting what was there previously)\n  and fully recalculate the list of duplicates (displayed at the bottom?).\n\n  <a href=\"https://twitter.com/nathanmarz/status/879722740776939520\" target=\"_blank\">https://twitter.com/nathanmarz/status/879722740776939520</a>\n\n  By applying `f` in an `:enrich` interceptor, after every CRUD event,\n  we keep the handlers simple and yet we ensure this important step\n  (of getting warnings right) is not missed on any change.\n\n  We can test `f` easily - it is a pure function - independently of\n  any CRUD operation.\n\n  This brings huge simplicity at the expense of some re-computation\n  each time. This may be a very satisfactory trade-off in many cases.\n\n  #### Returning nil\n\n  In some cases, it's useful to apply a change to specific situations that can\n  be determined at runtime instead of when defining the handler with an\n  `:enrich` interceptor. Instead of forcing you to return the `db` from every\n  non-applicable branch, you can return `nil` to use the given `db` value:\n\n      #!clj\n      (def set-last-update\n        (core/enrich\n          (fn [{db :db} [_ {user :user}]]\n            (when (active-user? user)  ;; <- Only perform an update if user is active\n              ...))))\n  ","^7E","Interceptors"],"^C","^2L","^7E","Interceptors","^6","re_frame/core.cljc","^:",13,"^7J",["^1D",[["~$f"]]],"^7Q",null,"^7N",["^1D",[null,null]],"^8",1,"^7G",false,"^7",779,"^7U","^7X","^9",779,"^7I",1,"^7V",true,"^7M",["^1D",["^7O",["^1D",[["~$f"]]]]],"^7P","Returns an interceptor which will run the given function `f` in the `:after`\n  position.\n\n  `f` is called with two arguments: `db` and `event`, and is expected to\n  return a modified `db`.\n\n  Unlike the `after` interceptor which is only about side effects, `enrich`\n  expects `f` to process and alter the given `db` coeffect in some useful way,\n  contributing to the derived data, flowing vibe.\n\n  If `f` returns `nil`, the `db` value passed to `f` will be returned instead.\n\n  #### Example Use:\n\n  Imagine that todomvc needed to do duplicate detection - if any two todos had\n  the same text, then highlight their background, and report them via a warning\n  at the bottom of the panel.\n\n  Almost any user action (edit text, add new todo, remove a todo) requires a\n  complete reassessment of duplication errors and warnings. E.g. that edit\n  just made might have introduced a new duplicate, or removed one. Same with\n  any todo removal. So we need to re-calculate warnings after any CRUD events\n  associated with the todos list.\n\n  Unless we are careful, we might end up coding subtly different checks\n  for each kind of CRUD operation.  The duplicates check made after\n  'delete todo' event might be subtly different to that done after an\n  editing operation. Nice and efficient, but fiddly. A bug generator\n  approach.\n\n  So, instead, we create an `f` which recalculates ALL warnings from scratch\n  every time there is ANY change. It will inspect all the todos, and\n  reset ALL FLAGS every time (overwriting what was there previously)\n  and fully recalculate the list of duplicates (displayed at the bottom?).\n\n  <a href=\"https://twitter.com/nathanmarz/status/879722740776939520\" target=\"_blank\">https://twitter.com/nathanmarz/status/879722740776939520</a>\n\n  By applying `f` in an `:enrich` interceptor, after every CRUD event,\n  we keep the handlers simple and yet we ensure this important step\n  (of getting warnings right) is not missed on any change.\n\n  We can test `f` easily - it is a pure function - independently of\n  any CRUD operation.\n\n  This brings huge simplicity at the expense of some re-computation\n  each time. This may be a very satisfactory trade-off in many cases.\n\n  #### Returning nil\n\n  In some cases, it's useful to apply a change to specific situations that can\n  be determined at runtime instead of when defining the handler with an\n  `:enrich` interceptor. Instead of forcing you to return the `db` from every\n  non-applicable branch, you can return `nil` to use the given `db` value:\n\n      #!clj\n      (def set-last-update\n        (core/enrich\n          (fn [{db :db} [_ {user :user}]]\n            (when (active-user? user)  ;; <- Only perform an update if user is active\n              ...))))\n  "],"~$reg-sub-raw",["^ ","^7D",null,"^5",["^ ","^6","re_frame/core.cljc","^7",519,"^8",7,"^9",519,"^:",18,"^7M",["^1D",["^7O",["^1D",[["~$query-id","~$handler-fn"]]]]],"^7P","This is a low level, advanced function.  You should probably be\n  using `reg-sub` instead.\n\n  Some explanation is available in the docs at\n  <a href=\"http://day8.github.io/re-frame/flow-mechanics/\" target=\"_blank\">http://day8.github.io/re-frame/flow-mechanics/</a>","^7E","Subscriptions"],"^C","^2V","^7E","Subscriptions","^6","re_frame/core.cljc","^:",18,"^7J",["^1D",[["^82","^83"]]],"^7Q",null,"^7N",["^1D",[null,null]],"^8",1,"^7G",false,"^7",519,"^7U","^7T","^9",519,"^7I",2,"^7V",true,"^7M",["^1D",["^7O",["^1D",[["^82","^83"]]]]],"^7P","This is a low level, advanced function.  You should probably be\n  using `reg-sub` instead.\n\n  Some explanation is available in the docs at\n  <a href=\"http://day8.github.io/re-frame/flow-mechanics/\" target=\"_blank\">http://day8.github.io/re-frame/flow-mechanics/</a>"],"~$subscribe",["^ ","^7D",null,"^5",["^ ","^7E","Subscriptions","^6","re_frame/core.cljc","^:",16,"^7F",["^ ","^7G",false,"^7H",2,"^7I",2,"^7J",[["~$query"],["^85","~$dynv"]],"^7M",["^1D",[["^85"],["^85","^86"]]],"^7N",["^1D",[null,null]]],"^8",7,"^7",437,"^9",437,"^7M",["^1D",["^7O",["^1D",[["^85"],["^85","^86"]]]]],"^7P","Given a `query` vector, returns a Reagent `reaction` which will, over\n  time, reactively deliver a stream of values. So, in FRP-ish terms,\n  it returns a `Signal`.\n\n  To obtain the current value from the Signal, it must be dereferenced:\n\n      #!clj\n      (let [signal (subscribe [:items])\n            value  (deref signal)]     ;; could be written as @signal\n        ...)\n\n   which is typically written tersely as simple:\n\n      #!clj\n      (let [items  @(subscribe [:items])]\n        ...)\n\n\n  `query` is a vector of at least one element. The first element is the\n  `query-id`, typically a namespaced keyword. The rest of the vector's\n  elements are optional, additional values which parameterise the query\n  performed.\n\n  `dynv` exists for historical reasons and is borderline deprecated these days.\n  It is a vector of signals. Re-frame will dereference each of them and pass a\n  vector of their values to your subscription handler as a third argument.\n  If there's logic determing __what__ query to subscribe __to__, consider\n  expressing it in a `signal function`, or use `reg-sub-raw`. Failing that, `dynv`\n  allows you to colocate this logic with the `subscribe` call.\n\n  **Example Usage**:\n\n      #!clj\n      (subscribe [:items])\n      (subscribe [:items \"blue\" :small])\n      (subscribe [:items {:colour \"blue\"  :size :small}])\n\n  Note: for any given call to `subscribe` there must have been a previous call\n  to `reg-sub`, registering the query handler (functions) associated with\n  `query-id`.\n\n  **Hint**\n\n  When used in a view function BE SURE to `deref` the returned value.\n  In fact, to avoid any mistakes, some prefer to define:\n\n      #!clj\n      (def <sub  (comp deref re-frame.core/subscribe))\n\n  And then, within their views, they call  `(<sub [:items :small])` rather\n  than using `subscribe` directly.\n\n  **De-duplication**\n\n  Two, or more, concurrent subscriptions for the same query will\n  source reactive updates from the one executing handler.\n\n  See also: `reg-sub`\n  "],"^C","^2Y","^7E","Subscriptions","^6","re_frame/core.cljc","^:",16,"^7F",["^ ","^7G",false,"^7H",2,"^7I",2,"^7J",[["^85"],["^85","^86"]],"^7M",["^1D",[["^85"],["^85","^86"]]],"^7N",["^1D",[null,null]]],"^7J",[["^85"],["^85","^86"]],"^7Q",null,"^7H",2,"^7N",["^1D",[null,null]],"^8",1,"^7G",false,"^7R",[["^ ","^7H",1,"^7G",false,"^7S","^7T"],["^ ","^7H",2,"^7G",false,"^7S","^7T"]],"^7",437,"^9",437,"^7I",2,"^7V",true,"^7M",["^1D",[["^85"],["^85","^86"]]],"^7P","Given a `query` vector, returns a Reagent `reaction` which will, over\n  time, reactively deliver a stream of values. So, in FRP-ish terms,\n  it returns a `Signal`.\n\n  To obtain the current value from the Signal, it must be dereferenced:\n\n      #!clj\n      (let [signal (subscribe [:items])\n            value  (deref signal)]     ;; could be written as @signal\n        ...)\n\n   which is typically written tersely as simple:\n\n      #!clj\n      (let [items  @(subscribe [:items])]\n        ...)\n\n\n  `query` is a vector of at least one element. The first element is the\n  `query-id`, typically a namespaced keyword. The rest of the vector's\n  elements are optional, additional values which parameterise the query\n  performed.\n\n  `dynv` exists for historical reasons and is borderline deprecated these days.\n  It is a vector of signals. Re-frame will dereference each of them and pass a\n  vector of their values to your subscription handler as a third argument.\n  If there's logic determing __what__ query to subscribe __to__, consider\n  expressing it in a `signal function`, or use `reg-sub-raw`. Failing that, `dynv`\n  allows you to colocate this logic with the `subscribe` call.\n\n  **Example Usage**:\n\n      #!clj\n      (subscribe [:items])\n      (subscribe [:items \"blue\" :small])\n      (subscribe [:items {:colour \"blue\"  :size :small}])\n\n  Note: for any given call to `subscribe` there must have been a previous call\n  to `reg-sub`, registering the query handler (functions) associated with\n  `query-id`.\n\n  **Hint**\n\n  When used in a view function BE SURE to `deref` the returned value.\n  In fact, to avoid any mistakes, some prefer to define:\n\n      #!clj\n      (def <sub  (comp deref re-frame.core/subscribe))\n\n  And then, within their views, they call  `(<sub [:items :small])` rather\n  than using `subscribe` directly.\n\n  **De-duplication**\n\n  Two, or more, concurrent subscriptions for the same query will\n  source reactive updates from the one executing handler.\n\n  See also: `reg-sub`\n  "],"~$reg-global-interceptor",["^ ","^7D",null,"^5",["^ ","^6","re_frame/core.cljc","^7",941,"^8",7,"^9",941,"^:",29,"^7M",["^1D",["^7O",["^1D",[["^Z"]]]]],"^7P","Registers the given `interceptor` as a global interceptor. Global interceptors are\n   included in the processing chain of every event.\n\n   When you register an event handler, you have the option of supplying an\n   interceptor chain. Any global interceptors you register are effectively\n   prepending to this chain.\n\n   Global interceptors are run in the order that they are registered.\n\n   Global interceptors are unique by :id. If a global interceptor with the same :id\n   key as `interceptor` is already registered, `interceptor` will take its place in the\n   global interceptor chain. This facilitates hot-reloading.\n\n   Note: members of re-frame.std-interceptors do not have unique ids. To register\n   more than one, consider:\n\n  (reg-global-interceptor (-> (re-frame.std-interceptors/on-changes + [:a] [:b])\n                              (assoc :id :my-unique-id)))","^7E","Global Interceptors"],"^C","^42","^7E","Global Interceptors","^6","re_frame/core.cljc","^:",29,"^7J",["^1D",[["^Z"]]],"^7Q",null,"^7N",["^1D",[null,null]],"^8",1,"^7G",false,"^7",941,"^7U",["^B",[null,"^7T"]],"^9",941,"^7I",1,"^7V",true,"^7M",["^1D",["^7O",["^1D",[["^Z"]]]]],"^7P","Registers the given `interceptor` as a global interceptor. Global interceptors are\n   included in the processing chain of every event.\n\n   When you register an event handler, you have the option of supplying an\n   interceptor chain. Any global interceptors you register are effectively\n   prepending to this chain.\n\n   Global interceptors are run in the order that they are registered.\n\n   Global interceptors are unique by :id. If a global interceptor with the same :id\n   key as `interceptor` is already registered, `interceptor` will take its place in the\n   global interceptor chain. This facilitates hot-reloading.\n\n   Note: members of re-frame.std-interceptors do not have unique ids. To register\n   more than one, consider:\n\n  (reg-global-interceptor (-> (re-frame.std-interceptors/on-changes + [:a] [:b])\n                              (assoc :id :my-unique-id)))"],"~$assoc-coeffect",["^ ","^7D",null,"^5",["^ ","^6","re_frame/core.cljc","^7",1032,"^8",7,"^9",1032,"^:",21,"^7M",["^1D",["^7O",["^1D",[["~$context","~$key","~$value"]]]]],"^7P","A utility function, typically used when writing an interceptor's `:before` function.\n\n   Adds or updates a key/value pair in the `:coeffects` map within `context`. ","^7E","Writing Interceptors"],"^C","^29","^7E","Writing Interceptors","^6","re_frame/core.cljc","^:",21,"^7J",["^1D",[["^89","^8:","^8;"]]],"^7Q",null,"^7N",["^1D",[null,null]],"^8",1,"^7G",false,"^7",1032,"^7U","^7X","^9",1032,"^7I",3,"^7V",true,"^7M",["^1D",["^7O",["^1D",[["^89","^8:","^8;"]]]]],"^7P","A utility function, typically used when writing an interceptor's `:before` function.\n\n   Adds or updates a key/value pair in the `:coeffects` map within `context`. "],"~$register-sub",["^ ","^7D",null,"^5",["^ ","^7E","Deprecated","^6","re_frame/core.cljc","^:",19,"^7F",["^ ","^7G",true,"^7H",0,"^7I",0,"^7J",[["^1D",["^7L"]]],"^7M",["^1D",[["~$&","^7L"]]],"^7N",["^1D",[null]]],"^8",7,"^7",1203,"~:deprecated","0.8.0","^9",1203,"^7M",["^1D",["^7O",["^1D",[["~$&","^7L"]]]]],"^7P","Deprecated. Use `reg-sub-raw` instead."],"^C","^28","^7E","Deprecated","^6","re_frame/core.cljc","^:",19,"^7F",["^ ","^7G",true,"^7H",0,"^7I",0,"^7J",[["^1D",["^7L"]]],"^7M",["^1D",[["~$&","^7L"]]],"^7N",["^1D",[null]]],"^7J",[["^1D",["^7L"]]],"^7Q",null,"^7H",0,"^7N",["^1D",[null]],"^8",1,"^7G",true,"^7R",[["^ ","^7H",0,"^7G",true,"^7S","^7T"]],"^7",1203,"^8=","0.8.0","^7U","^7T","^9",1203,"^7I",0,"^7V",true,"^7M",["^1D",[["~$&","^7L"]]],"^7P","Deprecated. Use `reg-sub-raw` instead."],"~$purge-event-queue",["^ ","^7D",null,"^5",["^ ","^6","re_frame/core.cljc","^7",1153,"^8",7,"^9",1153,"^:",24,"^7M",["^1D",["^7O",["^1D",[[]]]]],"^7P","Removes all events currently queued for processing","^7E","Miscellaneous"],"^C","^35","^7E","Miscellaneous","^6","re_frame/core.cljc","^:",24,"^7J",["^1D",[[]]],"^7Q",null,"^7N",["^1D",[null,null]],"^8",1,"^7G",false,"^7",1153,"^7U","^7T","^9",1153,"^7I",0,"^7V",true,"^7M",["^1D",["^7O",["^1D",[[]]]]],"^7P","Removes all events currently queued for processing"],"~$remove-post-event-callback",["^ ","^7D",null,"^5",["^ ","^6","re_frame/core.cljc","^7",1185,"^8",7,"^9",1185,"^:",33,"^7M",["^1D",["^7O",["^1D",[["~$id"]]]]],"^7P","Unregisters a post event callback function, identified by `id`.\n\n  Such a function must have been previously registered via `add-post-event-callback`","^7E","Miscellaneous"],"^C","^21","^7E","Miscellaneous","^6","re_frame/core.cljc","^:",33,"^7J",["^1D",[["^8@"]]],"^7Q",null,"^7N",["^1D",[null,null]],"^8",1,"^7G",false,"^7",1185,"^7U","^7T","^9",1185,"^7I",1,"^7V",true,"^7M",["^1D",["^7O",["^1D",[["^8@"]]]]],"^7P","Unregisters a post event callback function, identified by `id`.\n\n  Such a function must have been previously registered via `add-post-event-callback`"],"~$path",["^ ","^7D",null,"^5",["^ ","^7E","Interceptors","^6","re_frame/core.cljc","^:",11,"^7F",["^ ","^7G",true,"^7H",0,"^7I",0,"^7J",[["^1D",["^7L"]]],"^7M",["^1D",[["~$&","^7L"]]],"^7N",["^1D",[null]]],"^8",7,"^7",745,"^9",745,"^7M",["^1D",["^7O",["^1D",[["~$&","^7L"]]]]],"^7P","Returns an interceptor which acts somewhat like `clojure.core/update-in`, in the sense that\n  the event handler is given a specific part of `app-db` to change, not all of `app-db`.\n\n  The interceptor has both a `:before` and `:after` functions. The `:before` replaces\n  the `:db` key within coeffects with a sub-path within `app-db`. The `:after` reverses the process,\n  and it grafts the handler's return value back into db, at the right path.\n\n  Examples:\n\n      #!clj\n      (path :some :path)\n      (path [:some :path])\n      (path [:some :path] :to :here)\n      (path [:some :path] [:to] :here)\n\n  Example Use:\n\n      #!clj\n      (reg-event-db\n        :event-id\n        (path [:a :b])  ;; <-- used here, in interceptor chain\n        (fn [b v]       ;; 1st arg is not db. Is the value from path [:a :b] within db\n          ... new-b))   ;; returns a new value for that path (not the entire db)\n\n  Notes:\n\n    1. `path` may appear more than once in an interceptor chain. Progressive narrowing.\n    2. if `:effects` contains no `:db` effect, can't graft a value back in.\n  "],"^C","^46","^7E","Interceptors","^6","re_frame/core.cljc","^:",11,"^7F",["^ ","^7G",true,"^7H",0,"^7I",0,"^7J",[["^1D",["^7L"]]],"^7M",["^1D",[["~$&","^7L"]]],"^7N",["^1D",[null]]],"^7J",[["^1D",["^7L"]]],"^7Q",null,"^7H",0,"^7N",["^1D",[null]],"^8",1,"^7G",true,"^7R",[["^ ","^7H",0,"^7G",true,"^7S","^7T"]],"^7",745,"^7U","^7T","^9",745,"^7I",0,"^7V",true,"^7M",["^1D",[["~$&","^7L"]]],"^7P","Returns an interceptor which acts somewhat like `clojure.core/update-in`, in the sense that\n  the event handler is given a specific part of `app-db` to change, not all of `app-db`.\n\n  The interceptor has both a `:before` and `:after` functions. The `:before` replaces\n  the `:db` key within coeffects with a sub-path within `app-db`. The `:after` reverses the process,\n  and it grafts the handler's return value back into db, at the right path.\n\n  Examples:\n\n      #!clj\n      (path :some :path)\n      (path [:some :path])\n      (path [:some :path] :to :here)\n      (path [:some :path] [:to] :here)\n\n  Example Use:\n\n      #!clj\n      (reg-event-db\n        :event-id\n        (path [:a :b])  ;; <-- used here, in interceptor chain\n        (fn [b v]       ;; 1st arg is not db. Is the value from path [:a :b] within db\n          ... new-b))   ;; returns a new value for that path (not the entire db)\n\n  Notes:\n\n    1. `path` may appear more than once in an interceptor chain. Progressive narrowing.\n    2. if `:effects` contains no `:db` effect, can't graft a value back in.\n  "],"~$reg-sub",["^ ","^7D",null,"^5",["^ ","^7E","Subscriptions","^6","re_frame/core.cljc","^:",14,"^7F",["^ ","^7G",true,"^7H",1,"^7I",1,"^7J",[["^1D",["^82","^7L"]]],"^7M",["^1D",[["^82","~$&","^7L"]]],"^7N",["^1D",[null]]],"^8",7,"^7",186,"^9",186,"^7M",["^1D",["^7O",["^1D",[["^82","~$&","^7L"]]]]],"^7P","A call to `reg-sub` associates a `query-id` WITH two functions.\n\n  The two functions provide 'a mechanism' for creating a node\n  in the Signal Graph. When a node of type `query-id` is needed,\n  the two functions can be used to create it.\n\n  The three arguments are:\n\n    - `query-id` - typically a namespaced keyword (later used in subscribe)\n    - optionally, an `input signals` function which returns the input data\n      flows required by this kind of node.\n    - a `computation function` which computes the value (output) of the\n      node (from the input data flows)\n\n  Later, during app execution, a call to `(subscribe [:sub-id 3 :blue])`,\n  will trigger the need for a new `:sub-id` Signal Graph node (matching the\n  query `[:sub-id 3 :blue]`). And, to create that node the two functions\n  associated with `:sub-id` will be looked up and used.\n\n  Just to be clear: calling `reg-sub` does not immediately create a node.\n  It only registers 'a mechanism' (the two functions) by which nodes\n  can be created later, when a node is bought into existence by the\n  use of `subscribe` in a `View Function`.\n\n  `reg-sub` arguments are:\n\n    - a `query-id` (typically a namespaced keyword)\n    - a function which returns the inputs required by this kind of node (can be supplied  in one of three ways)\n    - a function which computes the value of this kind of node (can be supplied in one of three ways)\n\n  The `computation function` is always the last argument supplied and has three ways to be called.\n  Two of these methods are syntactic sugar to provide easier access to functional abstractions around your data.\n\n  1. A function that will accept two parameters, the `input-values` and `query-vector`. This is the\n     standard way to provide a `computation-function`\n\n          #!clj\n          (reg-sub\n            :query-id\n            (fn [input-values query-vector]\n              (:foo input-values)))\n\n  2. A single sugary tuple of `:->` and a 1-arity `computation-function`:\n\n          #!clj\n          (reg-sub\n            :query-id\n            :-> computation-fn)\n\n      This sugary variation allows you to pass a function that will expect only one parameter,\n      namely the `input-values` and entirely omit the `query-vector`. A typical `computation-function`\n      expects two parameters which can cause unfortunate results when attempting to use\n      clojure standard library functions, or other functions, in a functional manner.\n\n      For example, a significant number of subscriptions exist only to get a value\n      from the `input-values`. As shown below, this subscription will simply retrieve\n      the value associated with the `:foo` key in our db:\n\n          #!clj\n          (reg-sub\n            :query-id\n            (fn [db _]    ;; :<---- trivial boilerplate we might want to skip over\n              (:foo db)))\n\n      This is slightly more boilerplate than we might like to do,\n      as we can use a keyword directly as a function, and we might like to do this:\n\n          #!clj\n          (reg-sub\n            :query-id\n            :foo)  ;; :<---- This could be dangerous. If `:foo` is not in db, we get the `query-vector` instead of `nil`.\n\n      By using `:->` our function would not contain the `query-vector`, and any\n      missing keys would be represented as such:\n\n          #!clj\n          (reg-sub\n            :query-id\n            :-> :foo)\n\n      This form allows us to ignore the `query-vector` if our `computation-function`\n      has no need for it, and be safe from any accidents. Any 1-arity function can be provided,\n      and for more complicated use cases, `partial`, `comp`, and anonymous functions can still be used.\n\n  3. A single sugary tuple of `:=>` and a multi-arity `computation-function`\n\n          #!clj\n          (reg-sub\n            :query-id\n            :=> computation-fn)\n\n      The `query-vector` can be broken into two components `[query-id & optional-values]`, and\n      some subscriptions require the `optional-values` for extra work within the subscription.\n      To use them in variation #1, we need to destructure our `computation-function` parameters\n      in order to use them.\n\n          #!clj\n          (reg-sub\n            :query-id\n            (fn [db [_ foo]]\n              [db foo]))\n\n      Again we are writing boilerplate just to reach our values, and we might prefer to\n      have direction access through a parameter vector like `[input-values optional-values]`\n      instead, so we might be able to use a multi-arity function directly as our `computation-function`.\n      A rewrite of the above sub using this sugary syntax would look like this:\n\n          #!clj\n          (reg-sub\n            :query-id\n            :=> vector)  ;; :<---- Could also be `(fn [db foo] [db foo])`\n\n  The `computation function` is expected to take two arguments:\n\n    - `input-values` - the values which flow into this node (how is it wired into the graph?)\n    - `query-vector` - the vector given to `subscribe`\n\n  and it returns a computed value (which then becomes the output of the node)\n\n  When `computation function` is called, the 2nd `query-vector` argument will be that\n  vector supplied to the `subscribe`. So, if the call was `(subscribe [:sub-id 3 :blue])`,\n  then the `query-vector` supplied to the computation function will be `[:sub-id 3 :blue]`.\n\n  The argument(s) supplied to `reg-sub` between `query-id` and the `computation-function`\n  can vary in 3 ways, but whatever is there defines the `input signals` part\n  of `the mechanism`, specifying what input values \"flow into\" the\n  `computation function` (as the 1st argument) when it is called.\n\n  So, `reg-sub` can be called in one of three ways, because there are three ways\n  to define the input signals part. But note, the 2nd method, in which a\n  `signals function` is explicitly supplied, is the most canonical and\n  instructive. The other two are really just sugary variations.\n\n  **First variation** - no input signal function given:\n\n      #!clj\n      (reg-sub\n        :query-id\n        a-computation-fn)   ;; has signature:  (fn [db query-vec]  ... ret-value)\n\n     In the absence of an explicit `signals function`, the node's input signal defaults to `app-db`\n     and, as a result, the value within `app-db` (a map) is\n     given as the 1st argument when `a-computation-fn` is called.\n\n\n  **Second variation** - a signal function is explicitly supplied:\n\n      #!clj\n      (reg-sub\n        :query-id\n        signal-fn     ;; <-- here\n        computation-fn)\n\n  This is the most canonical and instructive of the three variations.\n\n  When a node is created from the template, the `signal function` will be called and it\n  is expected to return the input signal(s) as either a singleton, if there is only\n  one, or a sequence if there are many, or a map with the signals as the values.\n\n  The current values of the returned signals will be supplied as the 1st argument to\n  the `a-computation-fn` when it is called - and subject to what this `signal-fn` returns,\n  this value will be either a singleton, sequence or map of them (paralleling\n  the structure returned by the `signal function`).\n\n  This example `signal function` returns a 2-vector of input signals.\n\n      #!clj\n      (fn [query-vec dynamic-vec]\n         [(subscribe [:a-sub])\n          (subscribe [:b-sub])])\n\n  The associated computation function must be written\n  to expect a 2-vector of values for its first argument:\n\n      #!clj\n      (fn [[a b] query-vec]     ;; 1st argument is a seq of two values\n        ....)\n\n  If, on the other hand, the signal function was simpler and returned a singleton, like this:\n\n      #!clj\n      (fn [query-vec dynamic-vec]\n        (subscribe [:a-sub]))      ;; <-- returning a singleton\n\n  then the associated computation function must be written to expect a single value\n  as the 1st argument:\n\n      #!clj\n      (fn [a query-vec]       ;; 1st argument is a single value\n         ...)\n\n  Further Note: variation #1 above, in which an `signal-fn` was not supplied, like this:\n\n      #!clj\n      (reg-sub\n        :query-id\n        a-computation-fn)   ;; has signature:  (fn [db query-vec]  ... ret-value)\n\n  is the equivalent of using this\n  2nd variation and explicitly supplying a `signal-fn` which returns `app-db`:\n\n      #!clj\n      (reg-sub\n        :query-id\n        (fn [_ _]  re-frame/app-db)   ;; <--- explicit signal-fn\n        a-computation-fn)             ;; has signature:  (fn [db query-vec]  ... ret-value)\n\n  **Third variation** - syntax Sugar\n\n      #!clj\n      (reg-sub\n        :a-b-sub\n        :<- [:a-sub]\n        :<- [:b-sub]\n        (fn [[a b] query-vec]    ;; 1st argument is a seq of two values\n          {:a a :b b}))\n\n  This 3rd variation is just syntactic sugar for the 2nd.  Instead of providing an\n  `signals-fn` you provide one or more pairs of `:<-` and a subscription vector.\n\n  If you supply only one pair a singleton will be supplied to the computation function,\n  as if you had supplied a `signal-fn` returning only a single value:\n\n      #!clj\n      (reg-sub\n        :a-sub\n        :<- [:a-sub]\n        (fn [a query-vec]      ;; only one pair, so 1st argument is a single value\n          ...))\n\n  Syntactic sugar for both the `signal-fn` and `computation-fn` can be used together\n  and the direction of arrows shows the flow of data and functions. The example from\n  directly above is reproduced here:\n\n      #!clj\n      (reg-sub\n        :a-b-sub\n        :<- [:a-sub]\n        :<- [:b-sub]\n        :-> (partial zipmap [:a :b]))\n\n  For further understanding, read the tutorials, and look at the detailed comments in\n  /examples/todomvc/src/subs.cljs.\n\n  See also: `subscribe`\n  "],"^C","^3V","^7E","Subscriptions","^6","re_frame/core.cljc","^:",14,"^7F",["^ ","^7G",true,"^7H",1,"^7I",1,"^7J",[["^1D",["^82","^7L"]]],"^7M",["^1D",[["^82","~$&","^7L"]]],"^7N",["^1D",[null]]],"^7J",[["^1D",["^82","^7L"]]],"^7Q",null,"^7H",1,"^7N",["^1D",[null]],"^8",1,"^7G",true,"^7R",[["^ ","^7H",1,"^7G",true,"^7S","^7T"]],"^7",186,"^7U","^7T","^9",186,"^7I",1,"^7V",true,"^7M",["^1D",[["^82","~$&","^7L"]]],"^7P","A call to `reg-sub` associates a `query-id` WITH two functions.\n\n  The two functions provide 'a mechanism' for creating a node\n  in the Signal Graph. When a node of type `query-id` is needed,\n  the two functions can be used to create it.\n\n  The three arguments are:\n\n    - `query-id` - typically a namespaced keyword (later used in subscribe)\n    - optionally, an `input signals` function which returns the input data\n      flows required by this kind of node.\n    - a `computation function` which computes the value (output) of the\n      node (from the input data flows)\n\n  Later, during app execution, a call to `(subscribe [:sub-id 3 :blue])`,\n  will trigger the need for a new `:sub-id` Signal Graph node (matching the\n  query `[:sub-id 3 :blue]`). And, to create that node the two functions\n  associated with `:sub-id` will be looked up and used.\n\n  Just to be clear: calling `reg-sub` does not immediately create a node.\n  It only registers 'a mechanism' (the two functions) by which nodes\n  can be created later, when a node is bought into existence by the\n  use of `subscribe` in a `View Function`.\n\n  `reg-sub` arguments are:\n\n    - a `query-id` (typically a namespaced keyword)\n    - a function which returns the inputs required by this kind of node (can be supplied  in one of three ways)\n    - a function which computes the value of this kind of node (can be supplied in one of three ways)\n\n  The `computation function` is always the last argument supplied and has three ways to be called.\n  Two of these methods are syntactic sugar to provide easier access to functional abstractions around your data.\n\n  1. A function that will accept two parameters, the `input-values` and `query-vector`. This is the\n     standard way to provide a `computation-function`\n\n          #!clj\n          (reg-sub\n            :query-id\n            (fn [input-values query-vector]\n              (:foo input-values)))\n\n  2. A single sugary tuple of `:->` and a 1-arity `computation-function`:\n\n          #!clj\n          (reg-sub\n            :query-id\n            :-> computation-fn)\n\n      This sugary variation allows you to pass a function that will expect only one parameter,\n      namely the `input-values` and entirely omit the `query-vector`. A typical `computation-function`\n      expects two parameters which can cause unfortunate results when attempting to use\n      clojure standard library functions, or other functions, in a functional manner.\n\n      For example, a significant number of subscriptions exist only to get a value\n      from the `input-values`. As shown below, this subscription will simply retrieve\n      the value associated with the `:foo` key in our db:\n\n          #!clj\n          (reg-sub\n            :query-id\n            (fn [db _]    ;; :<---- trivial boilerplate we might want to skip over\n              (:foo db)))\n\n      This is slightly more boilerplate than we might like to do,\n      as we can use a keyword directly as a function, and we might like to do this:\n\n          #!clj\n          (reg-sub\n            :query-id\n            :foo)  ;; :<---- This could be dangerous. If `:foo` is not in db, we get the `query-vector` instead of `nil`.\n\n      By using `:->` our function would not contain the `query-vector`, and any\n      missing keys would be represented as such:\n\n          #!clj\n          (reg-sub\n            :query-id\n            :-> :foo)\n\n      This form allows us to ignore the `query-vector` if our `computation-function`\n      has no need for it, and be safe from any accidents. Any 1-arity function can be provided,\n      and for more complicated use cases, `partial`, `comp`, and anonymous functions can still be used.\n\n  3. A single sugary tuple of `:=>` and a multi-arity `computation-function`\n\n          #!clj\n          (reg-sub\n            :query-id\n            :=> computation-fn)\n\n      The `query-vector` can be broken into two components `[query-id & optional-values]`, and\n      some subscriptions require the `optional-values` for extra work within the subscription.\n      To use them in variation #1, we need to destructure our `computation-function` parameters\n      in order to use them.\n\n          #!clj\n          (reg-sub\n            :query-id\n            (fn [db [_ foo]]\n              [db foo]))\n\n      Again we are writing boilerplate just to reach our values, and we might prefer to\n      have direction access through a parameter vector like `[input-values optional-values]`\n      instead, so we might be able to use a multi-arity function directly as our `computation-function`.\n      A rewrite of the above sub using this sugary syntax would look like this:\n\n          #!clj\n          (reg-sub\n            :query-id\n            :=> vector)  ;; :<---- Could also be `(fn [db foo] [db foo])`\n\n  The `computation function` is expected to take two arguments:\n\n    - `input-values` - the values which flow into this node (how is it wired into the graph?)\n    - `query-vector` - the vector given to `subscribe`\n\n  and it returns a computed value (which then becomes the output of the node)\n\n  When `computation function` is called, the 2nd `query-vector` argument will be that\n  vector supplied to the `subscribe`. So, if the call was `(subscribe [:sub-id 3 :blue])`,\n  then the `query-vector` supplied to the computation function will be `[:sub-id 3 :blue]`.\n\n  The argument(s) supplied to `reg-sub` between `query-id` and the `computation-function`\n  can vary in 3 ways, but whatever is there defines the `input signals` part\n  of `the mechanism`, specifying what input values \"flow into\" the\n  `computation function` (as the 1st argument) when it is called.\n\n  So, `reg-sub` can be called in one of three ways, because there are three ways\n  to define the input signals part. But note, the 2nd method, in which a\n  `signals function` is explicitly supplied, is the most canonical and\n  instructive. The other two are really just sugary variations.\n\n  **First variation** - no input signal function given:\n\n      #!clj\n      (reg-sub\n        :query-id\n        a-computation-fn)   ;; has signature:  (fn [db query-vec]  ... ret-value)\n\n     In the absence of an explicit `signals function`, the node's input signal defaults to `app-db`\n     and, as a result, the value within `app-db` (a map) is\n     given as the 1st argument when `a-computation-fn` is called.\n\n\n  **Second variation** - a signal function is explicitly supplied:\n\n      #!clj\n      (reg-sub\n        :query-id\n        signal-fn     ;; <-- here\n        computation-fn)\n\n  This is the most canonical and instructive of the three variations.\n\n  When a node is created from the template, the `signal function` will be called and it\n  is expected to return the input signal(s) as either a singleton, if there is only\n  one, or a sequence if there are many, or a map with the signals as the values.\n\n  The current values of the returned signals will be supplied as the 1st argument to\n  the `a-computation-fn` when it is called - and subject to what this `signal-fn` returns,\n  this value will be either a singleton, sequence or map of them (paralleling\n  the structure returned by the `signal function`).\n\n  This example `signal function` returns a 2-vector of input signals.\n\n      #!clj\n      (fn [query-vec dynamic-vec]\n         [(subscribe [:a-sub])\n          (subscribe [:b-sub])])\n\n  The associated computation function must be written\n  to expect a 2-vector of values for its first argument:\n\n      #!clj\n      (fn [[a b] query-vec]     ;; 1st argument is a seq of two values\n        ....)\n\n  If, on the other hand, the signal function was simpler and returned a singleton, like this:\n\n      #!clj\n      (fn [query-vec dynamic-vec]\n        (subscribe [:a-sub]))      ;; <-- returning a singleton\n\n  then the associated computation function must be written to expect a single value\n  as the 1st argument:\n\n      #!clj\n      (fn [a query-vec]       ;; 1st argument is a single value\n         ...)\n\n  Further Note: variation #1 above, in which an `signal-fn` was not supplied, like this:\n\n      #!clj\n      (reg-sub\n        :query-id\n        a-computation-fn)   ;; has signature:  (fn [db query-vec]  ... ret-value)\n\n  is the equivalent of using this\n  2nd variation and explicitly supplying a `signal-fn` which returns `app-db`:\n\n      #!clj\n      (reg-sub\n        :query-id\n        (fn [_ _]  re-frame/app-db)   ;; <--- explicit signal-fn\n        a-computation-fn)             ;; has signature:  (fn [db query-vec]  ... ret-value)\n\n  **Third variation** - syntax Sugar\n\n      #!clj\n      (reg-sub\n        :a-b-sub\n        :<- [:a-sub]\n        :<- [:b-sub]\n        (fn [[a b] query-vec]    ;; 1st argument is a seq of two values\n          {:a a :b b}))\n\n  This 3rd variation is just syntactic sugar for the 2nd.  Instead of providing an\n  `signals-fn` you provide one or more pairs of `:<-` and a subscription vector.\n\n  If you supply only one pair a singleton will be supplied to the computation function,\n  as if you had supplied a `signal-fn` returning only a single value:\n\n      #!clj\n      (reg-sub\n        :a-sub\n        :<- [:a-sub]\n        (fn [a query-vec]      ;; only one pair, so 1st argument is a single value\n          ...))\n\n  Syntactic sugar for both the `signal-fn` and `computation-fn` can be used together\n  and the direction of arrows shows the flow of data and functions. The example from\n  directly above is reproduced here:\n\n      #!clj\n      (reg-sub\n        :a-b-sub\n        :<- [:a-sub]\n        :<- [:b-sub]\n        :-> (partial zipmap [:a :b]))\n\n  For further understanding, read the tutorials, and look at the detailed comments in\n  /examples/todomvc/src/subs.cljs.\n\n  See also: `subscribe`\n  "],"~$make-restore-fn",["^ ","^7D",null,"^5",["^ ","^6","re_frame/core.cljc","^7",1125,"^8",7,"^9",1125,"^:",22,"^7M",["^1D",["^7O",["^1D",[[]]]]],"^7P","This is a utility function, typically used in testing.\n\n  It checkpoints the current state of re-frame and returns a function which, when\n  later called, will restore re-frame to the checkpointed state.\n\n  The checkpoint includes `app-db`, all registered handlers and all subscriptions.\n  ","^7E","Miscellaneous"],"^C","^3S","^7E","Miscellaneous","^6","re_frame/core.cljc","^:",22,"^7J",["^1D",[[]]],"^7Q",null,"^7N",["^1D",[null,null]],"^8",1,"^7G",false,"^7",1125,"^7U","~$function","^9",1125,"^7I",0,"^7V",true,"^7M",["^1D",["^7O",["^1D",[[]]]]],"^7P","This is a utility function, typically used in testing.\n\n  It checkpoints the current state of re-frame and returns a function which, when\n  later called, will restore re-frame to the checkpointed state.\n\n  The checkpoint includes `app-db`, all registered handlers and all subscriptions.\n  "],"~$clear-fx",["^ ","^7D",null,"^5",["^ ","^7E","Effect Handlers","^6","re_frame/core.cljc","^:",15,"^7F",["^ ","^7G",false,"^7H",1,"^7I",1,"^7J",[[],["^8@"]],"^7M",["^1D",[[],["^8@"]]],"^7N",["^1D",[null,null]]],"^8",7,"^7",572,"^9",572,"^7M",["^1D",["^7O",["^1D",[[],["^8@"]]]]],"^7P","Unregisters effect handlers (presumably registered previously via the use of `reg-fx`).\n\n  When called with no args, it will unregister all currently registered effect handlers.\n\n  When given one arg, assumed to be the `id` of a previously registered\n  effect handler, it will unregister the associated handler. Will produce a warning to\n  console if it finds no matching registration.\n  "],"^C","^3B","^7E","Effect Handlers","^6","re_frame/core.cljc","^:",15,"^7F",["^ ","^7G",false,"^7H",1,"^7I",1,"^7J",[[],["^8@"]],"^7M",["^1D",[[],["^8@"]]],"^7N",["^1D",[null,null]]],"^7J",[[],["^8@"]],"^7Q",null,"^7H",1,"^7N",["^1D",[null,null]],"^8",1,"^7G",false,"^7R",[["^ ","^7H",0,"^7G",false,"^7S",["^B",[null,"^7T"]]],["^ ","^7H",1,"^7G",false,"^7S",["^B",[null,"^7T"]]]],"^7",572,"^9",572,"^7I",1,"^7V",true,"^7M",["^1D",[[],["^8@"]]],"^7P","Unregisters effect handlers (presumably registered previously via the use of `reg-fx`).\n\n  When called with no args, it will unregister all currently registered effect handlers.\n\n  When given one arg, assumed to be the `id` of a previously registered\n  effect handler, it will unregister the associated handler. Will produce a warning to\n  console if it finds no matching registration.\n  "],"~$get-effect",["^ ","^7D",null,"^5",["^ ","^7E","Writing Interceptors","^6","re_frame/core.cljc","^:",17,"^7F",["^ ","^7G",false,"^7H",3,"^7I",3,"^7J",[["^89"],["^89","^8:"],["^89","^8:","~$not-found"]],"^7M",["^1D",[["^89"],["^89","^8:"],["^89","^8:","^8G"]]],"^7N",["^1D",[null,null,null]]],"^8",7,"^7",1040,"^9",1040,"^7M",["^1D",["^7O",["^1D",[["^89"],["^89","^8:"],["^89","^8:","^8G"]]]]],"^7P","A utility function, used when writing interceptors, typically within an `:after` function.\n\n   When called with one argument, returns the `:effects` map from the `context`.\n\n   When called with two or three arguments, behaves like `clojure.core/get` and\n   returns the value mapped to `key` in the effects map, `not-found` or\n   `nil` if `key` is not present."],"^C","^37","^7E","Writing Interceptors","^6","re_frame/core.cljc","^:",17,"^7F",["^ ","^7G",false,"^7H",3,"^7I",3,"^7J",[["^89"],["^89","^8:"],["^89","^8:","^8G"]],"^7M",["^1D",[["^89"],["^89","^8:"],["^89","^8:","^8G"]]],"^7N",["^1D",[null,null,null]]],"^7J",[["^89"],["^89","^8:"],["^89","^8:","^8G"]],"^7Q",null,"^7H",3,"^7N",["^1D",[null,null,null]],"^8",1,"^7G",false,"^7R",[["^ ","^7H",1,"^7G",false,"^7S","^7T"],["^ ","^7H",2,"^7G",false,"^7S","^7T"],["^ ","^7H",3,"^7G",false,"^7S",["^B",[null,"^7T"]]]],"^7",1040,"^9",1040,"^7I",3,"^7V",true,"^7M",["^1D",[["^89"],["^89","^8:"],["^89","^8:","^8G"]]],"^7P","A utility function, used when writing interceptors, typically within an `:after` function.\n\n   When called with one argument, returns the `:effects` map from the `context`.\n\n   When called with two or three arguments, behaves like `clojure.core/get` and\n   returns the value mapped to `key` in the effects map, `not-found` or\n   `nil` if `key` is not present."],"~$reg-event-db",["^ ","^7D",null,"^5",["^ ","^7E","Event Handlers","^6","re_frame/core.cljc","^:",19,"^7F",["^ ","^7G",false,"^7H",3,"^7I",3,"^7J",[["^8@","~$handler"],["^8@","~$interceptors","^8I"]],"^7M",["^1D",[["^8@","^8I"],["^8@","^8J","^8I"]]],"^7N",["^1D",[null,null]]],"^8",7,"^7",72,"^9",72,"^7M",["^1D",["^7O",["^1D",[["^8@","^8I"],["^8@","^8J","^8I"]]]]],"^7P","Register the given event `handler` (function) for the given `id`. Optionally, provide\n  an `interceptors` chain:\n\n    - `id` is typically a namespaced keyword  (but can be anything)\n    - `handler` is a function: (db event) -> db\n    - `interceptors` is a collection of interceptors. Will be flattened and nils removed.\n\n  Example Usage:\n\n      #!clj\n      (reg-event-db\n        :token\n        (fn [db event]\n          (assoc db :some-key (get event 2)))  ;; return updated db\n\n  Or perhaps:\n\n      #!clj\n      (reg-event-db\n        :namespaced/id           ;; <-- namespaced keywords are often used\n        [one two three]          ;; <-- a seq of interceptors\n        (fn [db [_ arg1 arg2]]   ;; <-- event vector is destructured\n          (-> db\n            (dissoc arg1)\n            (update :key + arg2))))   ;; return updated db\n  "],"^C","^2T","^7E","Event Handlers","^6","re_frame/core.cljc","^:",19,"^7F",["^ ","^7G",false,"^7H",3,"^7I",3,"^7J",[["^8@","^8I"],["^8@","^8J","^8I"]],"^7M",["^1D",[["^8@","^8I"],["^8@","^8J","^8I"]]],"^7N",["^1D",[null,null]]],"^7J",[["^8@","^8I"],["^8@","^8J","^8I"]],"^7Q",null,"^7H",3,"^7N",["^1D",[null,null]],"^8",1,"^7G",false,"^7R",[["^ ","^7H",2,"^7G",false,"^7S","^7T"],["^ ","^7H",3,"^7G",false,"^7S","^7T"]],"^7",72,"^9",72,"^7I",3,"^7V",true,"^7M",["^1D",[["^8@","^8I"],["^8@","^8J","^8I"]]],"^7P","Register the given event `handler` (function) for the given `id`. Optionally, provide\n  an `interceptors` chain:\n\n    - `id` is typically a namespaced keyword  (but can be anything)\n    - `handler` is a function: (db event) -> db\n    - `interceptors` is a collection of interceptors. Will be flattened and nils removed.\n\n  Example Usage:\n\n      #!clj\n      (reg-event-db\n        :token\n        (fn [db event]\n          (assoc db :some-key (get event 2)))  ;; return updated db\n\n  Or perhaps:\n\n      #!clj\n      (reg-event-db\n        :namespaced/id           ;; <-- namespaced keywords are often used\n        [one two three]          ;; <-- a seq of interceptors\n        (fn [db [_ arg1 arg2]]   ;; <-- event vector is destructured\n          (-> db\n            (dissoc arg1)\n            (update :key + arg2))))   ;; return updated db\n  "],"~$dispatch-sync",["^ ","^7D",null,"^5",["^ ","^6","re_frame/core.cljc","^7",42,"^8",7,"^9",42,"^:",20,"^7M",["^1D",["^7O",["^1D",[["~$event"]]]]],"^7P","Synchronously (immediately) process `event`. It does **not** queue\n  the event for handling later as `dispatch` does.\n\n  `event` is a vector and the first element is typically a keyword\n  which identifies the kind of event.\n\n  It is an error to use `dispatch-sync` within an event handler because\n  you can't immediately process an new event when one is already\n  part way through being processed.\n\n  Generally, avoid using this function, and instead, use `dispatch`.\n  Only use it in the narrow set of cases where any delay in\n  processing is a problem:\n\n    1. the `:on-change` handler of a text field where we are expecting fast typing\n    2. when initialising your app - see 'main' in examples/todomvc/src/core.cljs\n    3. in a unit test where immediate, synchronous processing is useful\n\n  Usage:\n\n      #!clj\n      (dispatch-sync [:sing :falsetto \"piano accordion\"])\n  ","^7E","Dispatching Events"],"^C","^2W","^7E","Dispatching Events","^6","re_frame/core.cljc","^:",20,"^7J",["^1D",[["^8L"]]],"^7Q",null,"^7N",["^1D",[null,null]],"^8",1,"^7G",false,"^7",42,"^7U","~$clj-nil","^9",42,"^7I",1,"^7V",true,"^7M",["^1D",["^7O",["^1D",[["^8L"]]]]],"^7P","Synchronously (immediately) process `event`. It does **not** queue\n  the event for handling later as `dispatch` does.\n\n  `event` is a vector and the first element is typically a keyword\n  which identifies the kind of event.\n\n  It is an error to use `dispatch-sync` within an event handler because\n  you can't immediately process an new event when one is already\n  part way through being processed.\n\n  Generally, avoid using this function, and instead, use `dispatch`.\n  Only use it in the narrow set of cases where any delay in\n  processing is a problem:\n\n    1. the `:on-change` handler of a text field where we are expecting fast typing\n    2. when initialising your app - see 'main' in examples/todomvc/src/core.cljs\n    3. in a unit test where immediate, synchronous processing is useful\n\n  Usage:\n\n      #!clj\n      (dispatch-sync [:sing :falsetto \"piano accordion\"])\n  "],"~$clear-event",["^ ","^7D",null,"^5",["^ ","^7E","Event Handlers","^6","re_frame/core.cljc","^:",18,"^7F",["^ ","^7G",false,"^7H",1,"^7I",1,"^7J",[[],["^8@"]],"^7M",["^1D",[[],["^8@"]]],"^7N",["^1D",[null,null]]],"^8",7,"^7",170,"^9",170,"^7M",["^1D",["^7O",["^1D",[[],["^8@"]]]]],"^7P","Unregisters event handlers (presumably registered previously via the use of `reg-event-db` or `reg-event-fx`).\n\n  When called with no args, it will unregister all currently registered event handlers.\n\n  When given one arg, assumed to be the `id` of a previously registered\n  event handler, it will unregister the associated handler. Will produce a warning to\n  console if it finds no matching registration."],"^C","^27","^7E","Event Handlers","^6","re_frame/core.cljc","^:",18,"^7F",["^ ","^7G",false,"^7H",1,"^7I",1,"^7J",[[],["^8@"]],"^7M",["^1D",[[],["^8@"]]],"^7N",["^1D",[null,null]]],"^7J",[[],["^8@"]],"^7Q",null,"^7H",1,"^7N",["^1D",[null,null]],"^8",1,"^7G",false,"^7R",[["^ ","^7H",0,"^7G",false,"^7S",["^B",[null,"^7T"]]],["^ ","^7H",1,"^7G",false,"^7S",["^B",[null,"^7T"]]]],"^7",170,"^9",170,"^7I",1,"^7V",true,"^7M",["^1D",[[],["^8@"]]],"^7P","Unregisters event handlers (presumably registered previously via the use of `reg-event-db` or `reg-event-fx`).\n\n  When called with no args, it will unregister all currently registered event handlers.\n\n  When given one arg, assumed to be the `id` of a previously registered\n  event handler, it will unregister the associated handler. Will produce a warning to\n  console if it finds no matching registration."],"~$->interceptor",["^ ","^7D",null,"^5",["^ ","^7E","Writing Interceptors","^6","re_frame/core.cljc","^:",20,"^7F",["^ ","^7G",true,"^7H",0,"^7I",0,"^7J",[["^1D",[["^ ","^1F","~$m","~:keys",["^8@","~$before","~$after"]]]]],"^7M",["^1D",[["~$&",["^ ","^1F","~$m","^8P",["^8@","^8Q","^8R"]]]]],"^7N",["^1D",[null]]],"^8",7,"^7",978,"^9",978,"^7M",["^1D",["^7O",["^1D",[["~$&",["^ ","^1F","~$m","^8P",["^8@","^8Q","^8R"]]]]]]],"^7P","A utility function for creating interceptors.\n\n  Accepts three optional, named arguments:\n\n     - `:id` - an id for the interceptor (decorative only)\n     - `:before` - the interceptor's before function\n     - `:after`  - the interceptor's after function\n\n  Example use:\n\n      #!clj\n      (def my-interceptor\n        (->interceptor\n         :id     :my-interceptor\n         :before (fn [context]\n                   ... modifies and returns `context`)\n         :after  (fn [context]\n                   ... modifies and returns `context`)))\n\n  Notes:\n\n    - `:before` functions modify and return their `context` argument. Sometimes they\n      only side effect, in which case, they'll perform the side effect and return\n      `context` unchanged.\n    - `:before` functions often modify the `:coeffects` map within `context` and,\n      if they do, then they should use the utility functions `get-coeffect` and\n      `assoc-coeffect`.\n    - `:after` functions modify and return their `context` argument. Sometimes they\n      only side effect, in which case, they'll perform the side effect and return\n      `context` unchanged.\n    - `:after` functions often modify the `:effects` map within `context` and,\n      if they do, then they should use the utility functions `get-effect`\n      and `assoc-effect`"],"^C","^3M","^7E","Writing Interceptors","^6","re_frame/core.cljc","^:",20,"^7F",["^ ","^7G",true,"^7H",0,"^7I",0,"^7J",[["^1D",[["^ ","^1F","~$m","^8P",["^8@","^8Q","^8R"]]]]],"^7M",["^1D",[["~$&",["^ ","^1F","~$m","^8P",["^8@","^8Q","^8R"]]]]],"^7N",["^1D",[null]]],"^7J",[["^1D",[["^ ","^1F","~$m","^8P",["^8@","^8Q","^8R"]]]]],"^7Q",null,"^7H",0,"^7N",["^1D",[null]],"^8",1,"^7G",true,"^7R",[["^ ","^7H",0,"^7G",true,"^7S","^7T"]],"^7",978,"^7U","^7T","^9",978,"^7I",0,"^7V",true,"^7M",["^1D",[["~$&",["^ ","^1F","~$m","^8P",["^8@","^8Q","^8R"]]]]],"^7P","A utility function for creating interceptors.\n\n  Accepts three optional, named arguments:\n\n     - `:id` - an id for the interceptor (decorative only)\n     - `:before` - the interceptor's before function\n     - `:after`  - the interceptor's after function\n\n  Example use:\n\n      #!clj\n      (def my-interceptor\n        (->interceptor\n         :id     :my-interceptor\n         :before (fn [context]\n                   ... modifies and returns `context`)\n         :after  (fn [context]\n                   ... modifies and returns `context`)))\n\n  Notes:\n\n    - `:before` functions modify and return their `context` argument. Sometimes they\n      only side effect, in which case, they'll perform the side effect and return\n      `context` unchanged.\n    - `:before` functions often modify the `:coeffects` map within `context` and,\n      if they do, then they should use the utility functions `get-coeffect` and\n      `assoc-coeffect`.\n    - `:after` functions modify and return their `context` argument. Sometimes they\n      only side effect, in which case, they'll perform the side effect and return\n      `context` unchanged.\n    - `:after` functions often modify the `:effects` map within `context` and,\n      if they do, then they should use the utility functions `get-effect`\n      and `assoc-effect`"],"~$set-loggers!",["^ ","^7D",null,"^5",["^ ","^6","re_frame/core.cljc","^7",1079,"^8",7,"^9",1079,"^:",19,"^7M",["^1D",["^7O",["^1D",[["~$new-loggers"]]]]],"^7P","re-frame outputs warnings and errors via the API function `console`\n   which, by default, delegates to `js/console`'s default implementation for\n  `log`, `error`, `warn`, `debug`, `group` and `groupEnd`. But, using this function,\n   you can override that behaviour with your own functions.\n\n  The argument `new-loggers` should be a map containing a subset of they keys\n  for the standard `loggers`, namely  `:log` `:error` `:warn` `:debug` `:group`\n  or `:groupEnd`.\n\n  Example Usage:\n\n      #!clj\n      (defn my-logger      ;; my alternative logging function\n        [& args]\n        (post-it-somewhere (apply str args)))\n\n      ;; now install my alternative loggers\n      (re-frame.core/set-loggers!  {:warn my-logger :log my-logger})\n   ","^7E","Logging"],"^C","^3P","^7E","Logging","^6","re_frame/core.cljc","^:",19,"^7J",["^1D",[["^8T"]]],"^7Q",null,"^7N",["^1D",[null,null]],"^8",1,"^7G",false,"^7",1079,"^7U",["^B",[null,"^7T"]],"^9",1079,"^7I",1,"^7V",true,"^7M",["^1D",["^7O",["^1D",[["^8T"]]]]],"^7P","re-frame outputs warnings and errors via the API function `console`\n   which, by default, delegates to `js/console`'s default implementation for\n  `log`, `error`, `warn`, `debug`, `group` and `groupEnd`. But, using this function,\n   you can override that behaviour with your own functions.\n\n  The argument `new-loggers` should be a map containing a subset of they keys\n  for the standard `loggers`, namely  `:log` `:error` `:warn` `:debug` `:group`\n  or `:groupEnd`.\n\n  Example Usage:\n\n      #!clj\n      (defn my-logger      ;; my alternative logging function\n        [& args]\n        (post-it-somewhere (apply str args)))\n\n      ;; now install my alternative loggers\n      (re-frame.core/set-loggers!  {:warn my-logger :log my-logger})\n   "],"~$inject-cofx",["^ ","^7D",null,"^5",["^ ","^7E","Coeffects","^6","re_frame/core.cljc","^:",18,"^7F",["^ ","^7G",false,"^7H",2,"^7I",2,"^7J",[["^8@"],["^8@","^8;"]],"^7M",["^1D",[["^8@"],["^8@","^8;"]]],"^7N",["^1D",[null,null]]],"^8",7,"^7",603,"^9",603,"^7M",["^1D",["^7O",["^1D",[["^8@"],["^8@","^8;"]]]]],"^7P","Given an `id`, and an optional, arbitrary `value`, returns an interceptor\n  whose `:before` adds to the `:coeffects` (map) by calling a pre-registered\n  'coeffect handler' identified by the `id`.\n\n  The previous association of a `coeffect handler` with an `id` will have\n  happened via a call to `re-frame.core/reg-cofx` - generally on program startup.\n\n  Within the created interceptor, this 'looked up' `coeffect handler` will\n  be called (within the `:before`) with two arguments:\n\n  - the current value of `:coeffects`\n  - optionally, the originally supplied arbitrary `value`\n\n  This `coeffect handler` is expected to modify and return its first, `coeffects` argument.\n\n  **Example of `inject-cofx` and `reg-cofx` working together**\n\n\n  First - Early in app startup, you register a `coeffect handler` for `:datetime`:\n\n      #!clj\n      (re-frame.core/reg-cofx\n        :datetime                        ;; usage  (inject-cofx :datetime)\n        (fn coeffect-handler\n          [coeffect]\n          (assoc coeffect :now (js/Date.))))   ;; modify and return first arg\n\n  Second - Later, add an interceptor to an -fx event handler, using `inject-cofx`:\n\n      #!clj\n      (re-frame.core/reg-event-fx            ;; when registering an event handler\n        :event-id\n        [ ... (inject-cofx :datetime) ... ]  ;; <-- create an injecting interceptor\n        (fn event-handler\n          [coeffect event]\n            ;;... in here can access (:now coeffect) to obtain current datetime ...\n          )))\n\n  **Background**\n\n  `coeffects` are the input resources required by an event handler\n  to perform its job. The two most obvious ones are `db` and `event`.\n  But sometimes an event handler might need other resources.\n\n  Perhaps an event handler needs a random number or a GUID or the current\n  datetime. Perhaps it needs access to a DataScript database connection.\n\n  If an event handler directly accesses these resources, it stops being\n  pure and, consequently, it becomes harder to test, etc. So we don't\n  want that.\n\n  Instead, the interceptor created by this function is a way to 'inject'\n  'necessary resources' into the `:coeffects` (map) subsequently given\n  to the event handler at call time.\n\n  See also `reg-cofx`\n  "],"^C","^3N","^7E","Coeffects","^6","re_frame/core.cljc","^:",18,"^7F",["^ ","^7G",false,"^7H",2,"^7I",2,"^7J",[["^8@"],["^8@","^8;"]],"^7M",["^1D",[["^8@"],["^8@","^8;"]]],"^7N",["^1D",[null,null]]],"^7J",[["^8@"],["^8@","^8;"]],"^7Q",null,"^7H",2,"^7N",["^1D",[null,null]],"^8",1,"^7G",false,"^7R",[["^ ","^7H",1,"^7G",false,"^7S","^7X"],["^ ","^7H",2,"^7G",false,"^7S","^7X"]],"^7",603,"^9",603,"^7I",2,"^7V",true,"^7M",["^1D",[["^8@"],["^8@","^8;"]]],"^7P","Given an `id`, and an optional, arbitrary `value`, returns an interceptor\n  whose `:before` adds to the `:coeffects` (map) by calling a pre-registered\n  'coeffect handler' identified by the `id`.\n\n  The previous association of a `coeffect handler` with an `id` will have\n  happened via a call to `re-frame.core/reg-cofx` - generally on program startup.\n\n  Within the created interceptor, this 'looked up' `coeffect handler` will\n  be called (within the `:before`) with two arguments:\n\n  - the current value of `:coeffects`\n  - optionally, the originally supplied arbitrary `value`\n\n  This `coeffect handler` is expected to modify and return its first, `coeffects` argument.\n\n  **Example of `inject-cofx` and `reg-cofx` working together**\n\n\n  First - Early in app startup, you register a `coeffect handler` for `:datetime`:\n\n      #!clj\n      (re-frame.core/reg-cofx\n        :datetime                        ;; usage  (inject-cofx :datetime)\n        (fn coeffect-handler\n          [coeffect]\n          (assoc coeffect :now (js/Date.))))   ;; modify and return first arg\n\n  Second - Later, add an interceptor to an -fx event handler, using `inject-cofx`:\n\n      #!clj\n      (re-frame.core/reg-event-fx            ;; when registering an event handler\n        :event-id\n        [ ... (inject-cofx :datetime) ... ]  ;; <-- create an injecting interceptor\n        (fn event-handler\n          [coeffect event]\n            ;;... in here can access (:now coeffect) to obtain current datetime ...\n          )))\n\n  **Background**\n\n  `coeffects` are the input resources required by an event handler\n  to perform its job. The two most obvious ones are `db` and `event`.\n  But sometimes an event handler might need other resources.\n\n  Perhaps an event handler needs a random number or a GUID or the current\n  datetime. Perhaps it needs access to a DataScript database connection.\n\n  If an event handler directly accesses these resources, it stops being\n  pure and, consequently, it becomes harder to test, etc. So we don't\n  want that.\n\n  Instead, the interceptor created by this function is a way to 'inject'\n  'necessary resources' into the `:coeffects` (map) subsequently given\n  to the event handler at call time.\n\n  See also `reg-cofx`\n  "],"~$clear-global-interceptor",["^ ","^7D",null,"^5",["^ ","^7E","Global Interceptors","^6","re_frame/core.cljc","^:",31,"^7F",["^ ","^7G",false,"^7H",1,"^7I",1,"^7J",[[],["^8@"]],"^7M",["^1D",[[],["^8@"]]],"^7N",["^1D",[null,null]]],"^8",7,"^7",964,"^9",964,"^7M",["^1D",["^7O",["^1D",[[],["^8@"]]]]],"^7P","Unregisters global interceptors (presumably registered previously via the use of `reg-global-interceptor`).\n\n  When called with no args, it will unregister all currently registered global interceptors.\n\n  When given one arg, assumed to be the `id` of a previously registered\n  global interceptors, it will unregister the associated interceptor. Will produce a warning to\n  console if it finds no matching registration."],"^C","^3[","^7E","Global Interceptors","^6","re_frame/core.cljc","^:",31,"^7F",["^ ","^7G",false,"^7H",1,"^7I",1,"^7J",[[],["^8@"]],"^7M",["^1D",[[],["^8@"]]],"^7N",["^1D",[null,null]]],"^7J",[[],["^8@"]],"^7Q",null,"^7H",1,"^7N",["^1D",[null,null]],"^8",1,"^7G",false,"^7R",[["^ ","^7H",0,"^7G",false,"^7S",["^B",[null,"^7T"]]],["^ ","^7H",1,"^7G",false,"^7S",["^B",[null,"^7T"]]]],"^7",964,"^9",964,"^7I",1,"^7V",true,"^7M",["^1D",[[],["^8@"]]],"^7P","Unregisters global interceptors (presumably registered previously via the use of `reg-global-interceptor`).\n\n  When called with no args, it will unregister all currently registered global interceptors.\n\n  When given one arg, assumed to be the `id` of a previously registered\n  global interceptors, it will unregister the associated interceptor. Will produce a warning to\n  console if it finds no matching registration."],"~$get-coeffect",["^ ","^7D",null,"^5",["^ ","^7E","Writing Interceptors","^6","re_frame/core.cljc","^:",19,"^7F",["^ ","^7G",false,"^7H",3,"^7I",3,"^7J",[["^89"],["^89","^8:"],["^89","^8:","^8G"]],"^7M",["^1D",[["^89"],["^89","^8:"],["^89","^8:","^8G"]]],"^7N",["^1D",[null,null,null]]],"^8",7,"^7",1016,"^9",1016,"^7M",["^1D",["^7O",["^1D",[["^89"],["^89","^8:"],["^89","^8:","^8G"]]]]],"^7P","A utility function, typically used when writing an interceptor's `:before` function.\n\n   When called with one argument, it returns the `:coeffects` map from within that `context`.\n\n   When called with two or three arguments, behaves like `clojure.core/get` and\n   returns the value mapped to `key` in the `:coeffects` map within `context`, `not-found` or\n   `nil` if `key` is not present."],"^C","^2O","^7E","Writing Interceptors","^6","re_frame/core.cljc","^:",19,"^7F",["^ ","^7G",false,"^7H",3,"^7I",3,"^7J",[["^89"],["^89","^8:"],["^89","^8:","^8G"]],"^7M",["^1D",[["^89"],["^89","^8:"],["^89","^8:","^8G"]]],"^7N",["^1D",[null,null,null]]],"^7J",[["^89"],["^89","^8:"],["^89","^8:","^8G"]],"^7Q",null,"^7H",3,"^7N",["^1D",[null,null,null]],"^8",1,"^7G",false,"^7R",[["^ ","^7H",1,"^7G",false,"^7S","^7T"],["^ ","^7H",2,"^7G",false,"^7S","^7T"],["^ ","^7H",3,"^7G",false,"^7S",["^B",[null,"^7T"]]]],"^7",1016,"^9",1016,"^7I",3,"^7V",true,"^7M",["^1D",[["^89"],["^89","^8:"],["^89","^8:","^8G"]]],"^7P","A utility function, typically used when writing an interceptor's `:before` function.\n\n   When called with one argument, it returns the `:coeffects` map from within that `context`.\n\n   When called with two or three arguments, behaves like `clojure.core/get` and\n   returns the value mapped to `key` in the `:coeffects` map within `context`, `not-found` or\n   `nil` if `key` is not present."],"~$debug",["^ ","^5",["^ ","^6","re_frame/core.cljc","^7",714,"^8",42,"^9",714,"^:",47,"^7E","Interceptors"],"^C","^48","^7E","Interceptors","^6","re_frame/core.cljc","^:",47,"^8",1,"^7",714,"^9",714,"^7S","^7X","^7P","An interceptor which logs/instruments an event handler's actions to\n  `re-frame/console` at the `:log` level.\n\n  Output includes:\n\n    1. the event vector\n    2. a `clojure.data/diff` of db, before vs after, which shows\n       the changes caused by the event handler. To understand the output,\n       you should understand:\n       <a href=\"https://clojuredocs.org/clojure.data/diff\" target=\"_blank\">https://clojuredocs.org/clojure.data/diff</a>.\n\n  You'd typically include this interceptor after (to the right of) any\n  `path` interceptor.\n\n  Warning:  calling `clojure.data/diff` on large, complex data structures\n  can be slow. So, you won't want this interceptor present in production\n  code. So, you should condition it out like this:\n\n      #!clj\n      (re-frame.core/reg-event-db\n        :evt-id\n        [(when ^boolean goog.DEBUG re-frame.core/debug)]  ;; <-- conditional\n        (fn [db v]\n           ...))\n\n  To make this code fragment work, you'll also have to set `goog.DEBUG` to\n  `false` in your production builds. For an example, look in `project.clj` of /examples/todomvc.\n  "],"~$assoc-effect",["^ ","^7D",null,"^5",["^ ","^6","re_frame/core.cljc","^7",1056,"^8",7,"^9",1056,"^:",19,"^7M",["^1D",["^7O",["^1D",[["^89","^8:","^8;"]]]]],"^7P","A utility function, typically used when writing an interceptor's `:after` function.\n\n   Adds or updates a key/value pair in the `:effects` map within `context`. ","^7E","Writing Interceptors"],"^C","^2Q","^7E","Writing Interceptors","^6","re_frame/core.cljc","^:",19,"^7J",["^1D",[["^89","^8:","^8;"]]],"^7Q",null,"^7N",["^1D",[null,null]],"^8",1,"^7G",false,"^7",1056,"^7U","^7X","^9",1056,"^7I",3,"^7V",true,"^7M",["^1D",["^7O",["^1D",[["^89","^8:","^8;"]]]]],"^7P","A utility function, typically used when writing an interceptor's `:after` function.\n\n   Adds or updates a key/value pair in the `:effects` map within `context`. "],"~$enqueue",["^ ","^7D",null,"^5",["^ ","^6","re_frame/core.cljc","^7",1064,"^8",7,"^9",1064,"^:",14,"^7M",["^1D",["^7O",["^1D",[["^89","^8J"]]]]],"^7P","A utility function, used when writing an interceptor's `:before` function.\n\n  Adds the given collection of `interceptors` to those already in `context's`\n  execution `:queue`. It returns the updated `context`.\n\n  So, it provides a way for one interceptor to add more interceptors to the\n  currently executing interceptor chain.\n  ","^7E","Writing Interceptors"],"^C","^47","^7E","Writing Interceptors","^6","re_frame/core.cljc","^:",14,"^7J",["^1D",[["^89","^8J"]]],"^7Q",null,"^7N",["^1D",[null,null]],"^8",1,"^7G",false,"^7",1064,"^7U","^7X","^9",1064,"^7I",2,"^7V",true,"^7M",["^1D",["^7O",["^1D",[["^89","^8J"]]]]],"^7P","A utility function, used when writing an interceptor's `:before` function.\n\n  Adds the given collection of `interceptors` to those already in `context's`\n  execution `:queue`. It returns the updated `context`.\n\n  So, it provides a way for one interceptor to add more interceptors to the\n  currently executing interceptor chain.\n  "],"~$clear-cofx",["^ ","^7D",null,"^5",["^ ","^7E","Coeffects","^6","re_frame/core.cljc","^:",17,"^7F",["^ ","^7G",false,"^7H",1,"^7I",1,"^7J",[[],["^8@"]],"^7M",["^1D",[[],["^8@"]]],"^7N",["^1D",[null,null]]],"^8",7,"^7",667,"^9",667,"^7M",["^1D",["^7O",["^1D",[[],["^8@"]]]]],"^7P","Unregisters coeffect handlers (presumably registered previously via the use of `reg-cofx`).\n\n  When called with no args, it will unregister all currently registered coeffect handlers.\n\n  When given one arg, assumed to be the `id` of a previously registered\n  coeffect handler, it will unregister the associated handler. Will produce a warning to\n  console if it finds no matching registration."],"^C","^3<","^7E","Coeffects","^6","re_frame/core.cljc","^:",17,"^7F",["^ ","^7G",false,"^7H",1,"^7I",1,"^7J",[[],["^8@"]],"^7M",["^1D",[[],["^8@"]]],"^7N",["^1D",[null,null]]],"^7J",[[],["^8@"]],"^7Q",null,"^7H",1,"^7N",["^1D",[null,null]],"^8",1,"^7G",false,"^7R",[["^ ","^7H",0,"^7G",false,"^7S",["^B",[null,"^7T"]]],["^ ","^7H",1,"^7G",false,"^7S",["^B",[null,"^7T"]]]],"^7",667,"^9",667,"^7I",1,"^7V",true,"^7M",["^1D",[[],["^8@"]]],"^7P","Unregisters coeffect handlers (presumably registered previously via the use of `reg-cofx`).\n\n  When called with no args, it will unregister all currently registered coeffect handlers.\n\n  When given one arg, assumed to be the `id` of a previously registered\n  coeffect handler, it will unregister the associated handler. Will produce a warning to\n  console if it finds no matching registration."],"~$reg-event-ctx",["^ ","^7D",null,"^5",["^ ","^7E","Event Handlers","^6","re_frame/core.cljc","^:",20,"^7F",["^ ","^7G",false,"^7H",3,"^7I",3,"^7J",[["^8@","^8I"],["^8@","^8J","^8I"]],"^7M",["^1D",[["^8@","^8I"],["^8@","^8J","^8I"]]],"^7N",["^1D",[null,null]]],"^8",7,"^7",139,"^9",139,"^7M",["^1D",["^7O",["^1D",[["^8@","^8I"],["^8@","^8J","^8I"]]]]],"^7P","Register the given event `handler` (function) for the given `id`. Optionally, provide\n  an `interceptors` chain:\n\n    - `id` is typically a namespaced keyword  (but can be anything)\n    - `handler` is a function: context-map -> context-map\n\n  You can explore what is provided in `context` [here](https://day8.github.io/re-frame/Interceptors/#what-is-context).\n\n  Example Usage:\n\n      #!clj\n      (reg-event-ctx\n        :event-id\n        (fn [{:keys [coeffects] :as context}]\n          (let [initial  {:db     (:db coeffects)\n                          :event  (:event coeffects)\n                          :fx     []}\n                result   (-> initial\n                             function1\n                             function2\n                             function3)\n                effects  (select-keys result [:db :fx])]\n             (assoc context :effects effects))))\n  "],"^C","^3=","^7E","Event Handlers","^6","re_frame/core.cljc","^:",20,"^7F",["^ ","^7G",false,"^7H",3,"^7I",3,"^7J",[["^8@","^8I"],["^8@","^8J","^8I"]],"^7M",["^1D",[["^8@","^8I"],["^8@","^8J","^8I"]]],"^7N",["^1D",[null,null]]],"^7J",[["^8@","^8I"],["^8@","^8J","^8I"]],"^7Q",null,"^7H",3,"^7N",["^1D",[null,null]],"^8",1,"^7G",false,"^7R",[["^ ","^7H",2,"^7G",false,"^7S","^7T"],["^ ","^7H",3,"^7G",false,"^7S","^7T"]],"^7",139,"^9",139,"^7I",3,"^7V",true,"^7M",["^1D",[["^8@","^8I"],["^8@","^8J","^8I"]]],"^7P","Register the given event `handler` (function) for the given `id`. Optionally, provide\n  an `interceptors` chain:\n\n    - `id` is typically a namespaced keyword  (but can be anything)\n    - `handler` is a function: context-map -> context-map\n\n  You can explore what is provided in `context` [here](https://day8.github.io/re-frame/Interceptors/#what-is-context).\n\n  Example Usage:\n\n      #!clj\n      (reg-event-ctx\n        :event-id\n        (fn [{:keys [coeffects] :as context}]\n          (let [initial  {:db     (:db coeffects)\n                          :event  (:event coeffects)\n                          :fx     []}\n                result   (-> initial\n                             function1\n                             function2\n                             function3)\n                effects  (select-keys result [:db :fx])]\n             (assoc context :effects effects))))\n  "],"~$reg-fx",["^ ","^7D",null,"^5",["^ ","^6","re_frame/core.cljc","^7",545,"^8",7,"^9",545,"^:",13,"^7M",["^1D",["^7O",["^1D",[["^8@","^8I"]]]]],"^7P","Register the given effect `handler` for the given `id`:\n\n    - `id` is keyword, often namespaced.\n    - `handler` is a side-effecting function which takes a single argument and whose return\n      value is ignored.\n\n  To use, first, associate `:effect2` with a handler:\n\n      #!clj\n      (reg-fx\n         :effect2\n         (fn [value]\n            ... do something side-effect-y))\n\n  Then, later, if an event handler were to return this effects map:\n\n      #!clj\n      {:effect2  [1 2]}\n\n  then the `handler` `fn` we registered previously, using `reg-fx`, will be\n  called with an argument of `[1 2]`.\n  ","^7E","Effect Handlers"],"^C","^34","^7E","Effect Handlers","^6","re_frame/core.cljc","^:",13,"^7J",["^1D",[["^8@","^8I"]]],"^7Q",null,"^7N",["^1D",[null,null]],"^8",1,"^7G",false,"^7",545,"^7U","^7T","^9",545,"^7I",2,"^7V",true,"^7M",["^1D",["^7O",["^1D",[["^8@","^8I"]]]]],"^7P","Register the given effect `handler` for the given `id`:\n\n    - `id` is keyword, often namespaced.\n    - `handler` is a side-effecting function which takes a single argument and whose return\n      value is ignored.\n\n  To use, first, associate `:effect2` with a handler:\n\n      #!clj\n      (reg-fx\n         :effect2\n         (fn [value]\n            ... do something side-effect-y))\n\n  Then, later, if an event handler were to return this effects map:\n\n      #!clj\n      {:effect2  [1 2]}\n\n  then the `handler` `fn` we registered previously, using `reg-fx`, will be\n  called with an argument of `[1 2]`.\n  "],"~$trim-v",["^ ","^5",["^ ","^6","re_frame/core.cljc","^7",872,"^8",42,"^9",872,"^:",48,"^7E","Interceptors"],"^C","^2[","^7E","Interceptors","^6","re_frame/core.cljc","^:",48,"^8",1,"^7",872,"^9",872,"^7S","^7X","^7P","An interceptor which removes the first element of the event vector,\n  before it is supplied to the event handler, allowing you to write more\n   aesthetically pleasing event handlers. No leading underscore on the event-v!\n\n  Should you want the full original event, it can be found in `coeffects` under\n  the key `:original-event`.\n\n  Your event handlers will look like this:\n\n      #!clj\n      (reg-event-db\n        :event-id\n        [... trim-v ...]    ;; <-- added to the interceptors\n        (fn [db [x y z]]    ;; <-- instead of [_ x y z]\n          ...)\n    "],"~$clear-sub",["^ ","^7D",null,"^5",["^ ","^7E","Subscriptions","^6","re_frame/core.cljc","^:",16,"^7F",["^ ","^7G",false,"^7H",1,"^7I",1,"^7J",[[],["^82"]],"^7M",["^1D",[[],["^82"]]],"^7N",["^1D",[null,null]]],"^8",7,"^7",503,"^9",503,"^7M",["^1D",["^7O",["^1D",[[],["^82"]]]]],"^7P","Unregisters subscription handlers (presumably registered previously via the use of `reg-sub`).\n\n  When called with no args, it will unregister all currently registered subscription handlers.\n\n  When given one arg, assumed to be the `id` of a previously registered\n  subscription handler, it will unregister the associated handler. Will produce a warning to\n  console if it finds no matching registration.\n\n  NOTE: Depending on the usecase, it may be necessary to call `clear-subscription-cache!` afterwards"],"^C","^24","^7E","Subscriptions","^6","re_frame/core.cljc","^:",16,"^7F",["^ ","^7G",false,"^7H",1,"^7I",1,"^7J",[[],["^82"]],"^7M",["^1D",[[],["^82"]]],"^7N",["^1D",[null,null]]],"^7J",[[],["^82"]],"^7Q",null,"^7H",1,"^7N",["^1D",[null,null]],"^8",1,"^7G",false,"^7R",[["^ ","^7H",0,"^7G",false,"^7S",["^B",[null,"^7T"]]],["^ ","^7H",1,"^7G",false,"^7S",["^B",[null,"^7T"]]]],"^7",503,"^9",503,"^7I",1,"^7V",true,"^7M",["^1D",[[],["^82"]]],"^7P","Unregisters subscription handlers (presumably registered previously via the use of `reg-sub`).\n\n  When called with no args, it will unregister all currently registered subscription handlers.\n\n  When given one arg, assumed to be the `id` of a previously registered\n  subscription handler, it will unregister the associated handler. Will produce a warning to\n  console if it finds no matching registration.\n\n  NOTE: Depending on the usecase, it may be necessary to call `clear-subscription-cache!` afterwards"],"~$dispatch",["^ ","^7D",null,"^5",["^ ","^6","re_frame/core.cljc","^7",22,"^8",7,"^9",22,"^:",15,"^7M",["^1D",["^7O",["^1D",[["^8L"]]]]],"^7P","Queue `event` for processing (handling).\n\n  `event` is a vector and the first element is typically a keyword\n  which identifies the kind of event.\n\n  The event will be added to a FIFO processing queue, so event\n  handling does not happen immediately. It will happen 'very soon'\n  but not now. And if the queue already contains events, they\n  will be processed first.\n\n  Usage:\n\n      #!clj\n      (dispatch [:order \"pizza\" {:supreme 2 :meatlovers 1 :veg 1}])\n  ","^7E","Dispatching Events"],"^C","^2?","^7E","Dispatching Events","^6","re_frame/core.cljc","^:",15,"^7J",["^1D",[["^8L"]]],"^7Q",null,"^7N",["^1D",[null,null]],"^8",1,"^7G",false,"^7",22,"^7U","^8M","^9",22,"^7I",1,"^7V",true,"^7M",["^1D",["^7O",["^1D",[["^8L"]]]]],"^7P","Queue `event` for processing (handling).\n\n  `event` is a vector and the first element is typically a keyword\n  which identifies the kind of event.\n\n  The event will be added to a FIFO processing queue, so event\n  handling does not happen immediately. It will happen 'very soon'\n  but not now. And if the queue already contains events, they\n  will be processed first.\n\n  Usage:\n\n      #!clj\n      (dispatch [:order \"pizza\" {:supreme 2 :meatlovers 1 :veg 1}])\n  "],"^8R",["^ ","^7D",null,"^5",["^ ","^6","re_frame/core.cljc","^7",891,"^8",7,"^9",891,"^:",12,"^7M",["^1D",["^7O",["^1D",[["~$f"]]]]],"^7P","Returns an interceptor which runs the given function `f` in the `:after`\n  position, presumably for side effects.\n\n  `f` is called with two arguments: the `:effects` value for `:db`\n  (or the `:coeffect` value of `:db` if no `:db` effect is returned) and the event.\n  Its return value is ignored, so `f` can only side-effect.\n\n  An example of use can be seen in the re-frame github repo in `/examples/todomvc/events.cljs`:\n\n     - `f` runs schema validation (reporting any errors found).\n     - `f` writes to localstorage.","^7E","Interceptors"],"^C","^4?","^7E","Interceptors","^6","re_frame/core.cljc","^:",12,"^7J",["^1D",[["~$f"]]],"^7Q",null,"^7N",["^1D",[null,null]],"^8",1,"^7G",false,"^7",891,"^7U","^7X","^9",891,"^7I",1,"^7V",true,"^7M",["^1D",["^7O",["^1D",[["~$f"]]]]],"^7P","Returns an interceptor which runs the given function `f` in the `:after`\n  position, presumably for side effects.\n\n  `f` is called with two arguments: the `:effects` value for `:db`\n  (or the `:coeffect` value of `:db` if no `:db` effect is returned) and the event.\n  Its return value is ignored, so `f` can only side-effect.\n\n  An example of use can be seen in the re-frame github repo in `/examples/todomvc/events.cljs`:\n\n     - `f` runs schema validation (reporting any errors found).\n     - `f` writes to localstorage."],"~$add-post-event-callback",["^ ","^7D",null,"^5",["^ ","^7E","Miscellaneous","^6","re_frame/core.cljc","^:",30,"^7F",["^ ","^7G",false,"^7H",2,"^7I",2,"^7J",[["~$f"],["^8@","~$f"]],"^7M",["^1D",[["~$f"],["^8@","~$f"]]],"^7N",["^1D",[null,null]]],"^8",7,"^7",1161,"^9",1161,"^7M",["^1D",["^7O",["^1D",[["~$f"],["^8@","~$f"]]]]],"^7P","Registers the given function `f` to be called after each event is processed.\n\n   `f` will be called with two arguments:\n\n    - `event`: a vector. The event just processed.\n    - `queue`: a PersistentQueue, possibly empty, of events yet to be processed.\n\n   This facility is useful in advanced cases like:\n\n     - you are implementing a complex bootstrap pipeline\n     - you want to create your own handling infrastructure, with perhaps multiple\n       handlers for the one event, etc.  Hook in here.\n     - libraries providing 'isomorphic javascript' rendering on  Nodejs or Nashorn.\n\n  `id` is typically a keyword. If it supplied when an `f` is added, it can be\n  subsequently be used to identify it for removal. See `remove-post-event-callback`.\n  "],"^C","^20","^7E","Miscellaneous","^6","re_frame/core.cljc","^:",30,"^7F",["^ ","^7G",false,"^7H",2,"^7I",2,"^7J",[["~$f"],["^8@","~$f"]],"^7M",["^1D",[["~$f"],["^8@","~$f"]]],"^7N",["^1D",[null,null]]],"^7J",[["~$f"],["^8@","~$f"]],"^7Q",null,"^7H",2,"^7N",["^1D",[null,null]],"^8",1,"^7G",false,"^7R",[["^ ","^7H",1,"^7G",false,"^7S","^7T"],["^ ","^7H",2,"^7G",false,"^7S","^7T"]],"^7",1161,"^9",1161,"^7I",2,"^7V",true,"^7M",["^1D",[["~$f"],["^8@","~$f"]]],"^7P","Registers the given function `f` to be called after each event is processed.\n\n   `f` will be called with two arguments:\n\n    - `event`: a vector. The event just processed.\n    - `queue`: a PersistentQueue, possibly empty, of events yet to be processed.\n\n   This facility is useful in advanced cases like:\n\n     - you are implementing a complex bootstrap pipeline\n     - you want to create your own handling infrastructure, with perhaps multiple\n       handlers for the one event, etc.  Hook in here.\n     - libraries providing 'isomorphic javascript' rendering on  Nodejs or Nashorn.\n\n  `id` is typically a keyword. If it supplied when an `f` is added, it can be\n  subsequently be used to identify it for removal. See `remove-post-event-callback`.\n  "],"~$reg-cofx",["^ ","^7D",null,"^5",["^ ","^6","re_frame/core.cljc","^7",589,"^8",7,"^9",589,"^:",15,"^7M",["^1D",["^7O",["^1D",[["^8@","^8I"]]]]],"^7P","Register the given coeffect `handler` for the given `id`, for later use\n  within `inject-cofx`:\n\n    - `id` is keyword, often namespaced.\n    - `handler` is a function which takes either one or two arguments, the first of which is\n       always `coeffects` and which returns an updated `coeffects`.\n\n  See also: `inject-cofx`\n  ","^7E","Coeffects"],"^C","^43","^7E","Coeffects","^6","re_frame/core.cljc","^:",15,"^7J",["^1D",[["^8@","^8I"]]],"^7Q",null,"^7N",["^1D",[null,null]],"^8",1,"^7G",false,"^7",589,"^7U","^7T","^9",589,"^7I",2,"^7V",true,"^7M",["^1D",["^7O",["^1D",[["^8@","^8I"]]]]],"^7P","Register the given coeffect `handler` for the given `id`, for later use\n  within `inject-cofx`:\n\n    - `id` is keyword, often namespaced.\n    - `handler` is a function which takes either one or two arguments, the first of which is\n       always `coeffects` and which returns an updated `coeffects`.\n\n  See also: `inject-cofx`\n  "],"~$reg-event-fx",["^ ","^7D",null,"^5",["^ ","^7E","Event Handlers","^6","re_frame/core.cljc","^:",19,"^7F",["^ ","^7G",false,"^7H",3,"^7I",3,"^7J",[["^8@","^8I"],["^8@","^8J","^8I"]],"^7M",["^1D",[["^8@","^8I"],["^8@","^8J","^8I"]]],"^7N",["^1D",[null,null]]],"^8",7,"^7",105,"^9",105,"^7M",["^1D",["^7O",["^1D",[["^8@","^8I"],["^8@","^8J","^8I"]]]]],"^7P","Register the given event `handler` (function) for the given `id`. Optionally, provide\n  an `interceptors` chain:\n\n    - `id` is typically a namespaced keyword  (but can be anything)\n    - `handler` is a function: (coeffects-map event-vector) -> effects-map\n    - `interceptors` is a collection of interceptors. Will be flattened and nils removed.\n\n\n  Example Usage:\n\n      #!clj\n      (reg-event-fx\n        :event-id\n        (fn [cofx event]\n          {:db (assoc (:db cofx) :some-key (get event 2))}))   ;; return a map of effects\n\n\n  Or perhaps:\n\n      #!clj\n      (reg-event-fx\n        :namespaced/id           ;; <-- namespaced keywords are often used\n        [one two three]          ;; <-- a seq of interceptors\n        (fn [{:keys [db] :as cofx} [_ arg1 arg2]] ;; destructure both arguments\n          {:db (assoc db :some-key arg1)          ;; return a map of effects\n           :fx [[:dispatch [:some-event arg2]]]}))\n  "],"^C","^3@","^7E","Event Handlers","^6","re_frame/core.cljc","^:",19,"^7F",["^ ","^7G",false,"^7H",3,"^7I",3,"^7J",[["^8@","^8I"],["^8@","^8J","^8I"]],"^7M",["^1D",[["^8@","^8I"],["^8@","^8J","^8I"]]],"^7N",["^1D",[null,null]]],"^7J",[["^8@","^8I"],["^8@","^8J","^8I"]],"^7Q",null,"^7H",3,"^7N",["^1D",[null,null]],"^8",1,"^7G",false,"^7R",[["^ ","^7H",2,"^7G",false,"^7S","^7T"],["^ ","^7H",3,"^7G",false,"^7S","^7T"]],"^7",105,"^9",105,"^7I",3,"^7V",true,"^7M",["^1D",[["^8@","^8I"],["^8@","^8J","^8I"]]],"^7P","Register the given event `handler` (function) for the given `id`. Optionally, provide\n  an `interceptors` chain:\n\n    - `id` is typically a namespaced keyword  (but can be anything)\n    - `handler` is a function: (coeffects-map event-vector) -> effects-map\n    - `interceptors` is a collection of interceptors. Will be flattened and nils removed.\n\n\n  Example Usage:\n\n      #!clj\n      (reg-event-fx\n        :event-id\n        (fn [cofx event]\n          {:db (assoc (:db cofx) :some-key (get event 2))}))   ;; return a map of effects\n\n\n  Or perhaps:\n\n      #!clj\n      (reg-event-fx\n        :namespaced/id           ;; <-- namespaced keywords are often used\n        [one two three]          ;; <-- a seq of interceptors\n        (fn [{:keys [db] :as cofx} [_ arg1 arg2]] ;; destructure both arguments\n          {:db (assoc db :some-key arg1)          ;; return a map of effects\n           :fx [[:dispatch [:some-event arg2]]]}))\n  "],"~$reg-event-error-handler",["^ ","^7D",null,"^5",["^ ","^6","re_frame/core.cljc","^7",683,"^8",7,"^9",683,"^:",30,"^7M",["^1D",["^7O",["^1D",[["^8I"]]]]],"^7P","Register the given event error `handler` (function) that will catch unhandled exceptions\n  thrown in the interceptors/handler chain.\n\n  Only one `handler` can be registered. Registering a new `handler` clears the existing `handler`.\n\n  This `handler` function has the signature:\n\n  `(handler [original-error re-frame-error])`\n\n  - `original-error`: A plaform-native Error object.\n     Represents the original error thrown by user code.\n     this is the error you see when no `handler` is registered.\n\n  - `re-frame-error`: A clojure ExceptionInfo object.\n     Includes the stacktrace of re-frame's internal functions,\n     and extra data about the interceptor process.\n     Call `(ex-data re-frame-error)` to get this info.\n\n     The data includes:\n\n     - `:interceptor`: the `:id` of the throwing interceptor.\n     - `:direction`: `:before` or `:after`.\n     - `:event-v`: the re-frame event which invoked this interceptor."],"^C","^2J","^6","re_frame/core.cljc","^:",30,"^7J",["^1D",[["^8I"]]],"^7Q",null,"^7N",["^1D",[null,null]],"^8",1,"^7G",false,"^7",683,"^7U","^7T","^9",683,"^7I",1,"^7V",true,"^7M",["^1D",["^7O",["^1D",[["^8I"]]]]],"^7P","Register the given event error `handler` (function) that will catch unhandled exceptions\n  thrown in the interceptors/handler chain.\n\n  Only one `handler` can be registered. Registering a new `handler` clears the existing `handler`.\n\n  This `handler` function has the signature:\n\n  `(handler [original-error re-frame-error])`\n\n  - `original-error`: A plaform-native Error object.\n     Represents the original error thrown by user code.\n     this is the error you see when no `handler` is registered.\n\n  - `re-frame-error`: A clojure ExceptionInfo object.\n     Includes the stacktrace of re-frame's internal functions,\n     and extra data about the interceptor process.\n     Call `(ex-data re-frame-error)` to get this info.\n\n     The data includes:\n\n     - `:interceptor`: the `:id` of the throwing interceptor.\n     - `:direction`: `:before` or `:after`.\n     - `:event-v`: the re-frame event which invoked this interceptor."],"~$register-handler",["^ ","^7D",null,"^5",["^ ","^7E","Deprecated","^6","re_frame/core.cljc","^:",23,"^7F",["^ ","^7G",true,"^7H",0,"^7I",0,"^7J",[["^1D",["^7L"]]],"^7M",["^1D",[["~$&","^7L"]]],"^7N",["^1D",[null]]],"^8",7,"^7",1195,"^8=","0.8.0","^9",1195,"^7M",["^1D",["^7O",["^1D",[["~$&","^7L"]]]]],"^7P","Deprecated. Use `reg-event-db` instead."],"^C","^3I","^7E","Deprecated","^6","re_frame/core.cljc","^:",23,"^7F",["^ ","^7G",true,"^7H",0,"^7I",0,"^7J",[["^1D",["^7L"]]],"^7M",["^1D",[["~$&","^7L"]]],"^7N",["^1D",[null]]],"^7J",[["^1D",["^7L"]]],"^7Q",null,"^7H",0,"^7N",["^1D",[null]],"^8",1,"^7G",true,"^7R",[["^ ","^7H",0,"^7G",true,"^7S","^7T"]],"^7",1195,"^8=","0.8.0","^7U","^7T","^9",1195,"^7I",0,"^7V",true,"^7M",["^1D",[["~$&","^7L"]]],"^7P","Deprecated. Use `reg-event-db` instead."],"~$clear-subscription-cache!",["^ ","^7D",null,"^5",["^ ","^6","re_frame/core.cljc","^7",530,"^8",7,"^9",530,"^:",32,"^7M",["^1D",["^7O",["^1D",[[]]]]],"^7P","Removes all subscriptions from the cache.\n\n  This function can be used at development time or test time. Useful when hot reloading\n  namespaces containing subscription handlers. Also call it after a React/render exception,\n  because React components won't have been cleaned up properly. And this, in turn, means\n  the subscriptions within those components won't have been cleaned up correctly. So this\n  forces the issue.\n  ","^7E","Subscriptions"],"^C","^3U","^7E","Subscriptions","^6","re_frame/core.cljc","^:",32,"^7J",["^1D",[[]]],"^7Q",null,"^7N",["^1D",[null,null]],"^8",1,"^7G",false,"^7",530,"^7U",["^B",["^7T","^8M"]],"^9",530,"^7I",0,"^7V",true,"^7M",["^1D",["^7O",["^1D",[[]]]]],"^7P","Removes all subscriptions from the cache.\n\n  This function can be used at development time or test time. Useful when hot reloading\n  namespaces containing subscription handlers. Also call it after a React/render exception,\n  because React components won't have been cleaned up properly. And this, in turn, means\n  the subscriptions within those components won't have been cleaned up correctly. So this\n  forces the issue.\n  "]],"^1B",["^ ","^Y","^Y"],"~:cljs.analyzer/constants",["^ ","^1<",["^B",["~:event-handler","~:warn","~:after","~:id","~:error","~:before"]],"~:order",["^9@","^9<","^9?","^9A","^9>","^9="]],"^1H",["^ ","^1=",["^B",[]]],"^1I",[],"^1J",["^[","^Y","^T","^L","^J","^13","^S","^P","^11","^W","^V","^X","^Q","^18","^15","^N"]],"^G","^D","~:ns-specs",["^ "],"~:ns-spec-vars",["^B",[]],"~:compiler-options",["^4A",[["^9E","~:static-fns"],true,["~:js-options","~:use-babel"],null,["^9E","~:lite-mode"],null,["^9E","~:shadow-tweaks"],null,["^9E","~:source-map-inline"],null,["^9E","~:shadow-optimize-constants"],null,["^9E","~:elide-asserts"],false,["^9E","~:optimize-constants"],null,["^9E","^1O"],null,["^9E","~:external-config"],null,["^9E","~:tooling-config"],null,["^9E","~:emit-constants"],null,["^9E","~:load-tests"],true,["^9E","~:form-size-threshold"],null,["^9E","~:global-goog-object&array"],null,["^9E","~:data-readers"],null,["~:shadow.build/config","~:target"],"~:node-test",["^9E","~:infer-externs"],"~:auto",["^9E","^1Q"],null,["^9G","~:js-provider"],"^1=",["~:mode"],"~:dev",["^9E","~:fn-invoke-direct"],null,["^9E","~:elide-to-string"],null,["^9E","~:source-map"],"/dev/null"]]]