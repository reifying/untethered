{"version":3,"sources":["voice_code/json.cljs"],"mappings":";AAMA;;;;kCAAA,lCAAMA,4EAGHC;AAHH,AAIE,GAAI,cAAAC,bAAUD;AACZ,8EAAI,AAACE,eAAKF,tCACN,yCAAA,IAAA,7CAACG,hDACDC;;AACJJ;;;AAEJ;;;;kCAAA,lCAAMK,4EAGHL;AAHH,AAIE,GAAI,cAAAC,bAAUD;AACZ,8EAAI,AAACE,eAAKF,tCACN,yCAAA,IAAA,7CAACG,hDACDC;;AACJJ;;;AAEJ;;;iCAAA,jCAAMM,0EAEHC,EAAEC;AAFL,AAGE,OAACC,sBACA,WAAKC;AAAL,AACE,GAAI,AAACC,qBAAKD;AACR,oDAAA,7CAACE,gFAAQ,AAACC,4CAAI,WAAAC;AAAA,AAAA,IAAAC,aAAAD;QAAA,AAAAE,4CAAAD,WAAA,IAAA,/DAAMf;QAAN,AAAAgB,4CAAAD,WAAA,IAAA,/DAAQE;AAAR,AAAA,0FAAa,CAACV,kCAAAA,qCAAAA,LAAEP,iBAAAA,IAAGiB;GAAIP;;AACrCA;;GACJF;;AAEH;;;iCAAA,jCAAOU,0EAEJV;AAFH,AAGE,OAACC,sBACA,WAAKC;AAAL,AACE,GAAI,AAACC,qBAAKD;AACR,oDAAA,7CAACE,gFAAQ,AAACC,4CAAI,WAAAM;AAAA,AAAA,IAAAC,aAAAD;QAAA,AAAAH,4CAAAI,WAAA,IAAA,/DAAMpB;QAAN,AAAAgB,4CAAAI,WAAA,IAAA,/DAAQH;AAAR,AAAA,0FAAa,EAAI,cAAAhB,bAAUD,iCAAG,AAACE,eAAKF,GAAGA,GAAGiB;GAAIP;;AAC5DA;;GACJF;;AAEH;;;;+BAAA,/BAAMa,sEAGHb;AAHH,AAIE,IAAMc,aAAW,AAAChB,+BAAeP,gCAAaS;IACxCe,cAAY,AAACL,+BAAeI;IAC5BE,SAAO,AAACC,qBAAQF;AAFtB,AAGE,OAACG,eAAkBF;;AAEvB;;;;+BAAA,/BAAMG,sEAGHC;AAHH,AAIE,IAAMC,SAAO,AAACC,WAAcF;IACtBG,UAAQ,mHAAA,2EAAA,9LAACC,0DAAQH;IACjBI,YAAU,AAAC3B,+BAAeD,gCAAa0B;AAF7C,AAGEE;;AAEJ;;;kCAAA,lCAAMC,4EAEHN;AAFH,AAGE,IAAA,AACE,OAACD,6BAAUC;gBADb,QAAAO,JAEkBC;AAFlB,AAAA","names":["voice-code.json/kebab->snake","k","cljs.core/Keyword","cljs.core/name","clojure.string/replace","cljs.core.keyword","voice-code.json/snake->kebab","voice-code.json/transform-keys","f","m","clojure.walk/postwalk","x","cljs.core/map?","cljs.core.into","cljs.core.map","p__11012","vec__11014","cljs.core.nth","v","voice-code.json/stringify-keys","p__11023","vec__11024","voice-code.json/clj->json","snake-keys","string-keys","js-obj","cljs.core/clj->js","js/JSON.stringify","voice-code.json/json->clj","s","parsed","js/JSON.parse","clj-map","cljs.core.js__GT_clj","kebab-map","voice-code.json/parse-json-safe","e11029","_"],"sourcesContent":["(ns voice-code.json\n  \"JSON conversion utilities for WebSocket protocol.\n   Handles conversion between Clojure kebab-case and JSON snake_case.\"\n  (:require [clojure.string :as str]\n            [clojure.walk :as walk]))\n\n(defn kebab->snake\n  \"Convert kebab-case keyword to snake_case keyword.\n   Example: :session-id -> :session_id\"\n  [k]\n  (if (keyword? k)\n    (-> (name k)\n        (str/replace \"-\" \"_\")\n        keyword)\n    k))\n\n(defn snake->kebab\n  \"Convert snake_case keyword to kebab-case keyword.\n   Example: :session_id -> :session-id\"\n  [k]\n  (if (keyword? k)\n    (-> (name k)\n        (str/replace \"_\" \"-\")\n        keyword)\n    k))\n\n(defn transform-keys\n  \"Recursively transform all keys in a map using function f.\"\n  [f m]\n  (walk/postwalk\n   (fn [x]\n     (if (map? x)\n       (into {} (map (fn [[k v]] [(f k) v]) x))\n       x))\n   m))\n\n(defn- stringify-keys\n  \"Convert all keywords to strings in a map (recursively).\"\n  [m]\n  (walk/postwalk\n   (fn [x]\n     (if (map? x)\n       (into {} (map (fn [[k v]] [(if (keyword? k) (name k) k) v]) x))\n       x))\n   m))\n\n(defn clj->json\n  \"Convert Clojure map to JSON string with snake_case keys.\n   Used for outbound WebSocket messages.\"\n  [m]\n  (let [snake-keys (transform-keys kebab->snake m)\n        string-keys (stringify-keys snake-keys)\n        js-obj (clj->js string-keys)]\n    (js/JSON.stringify js-obj)))\n\n(defn json->clj\n  \"Parse JSON string to Clojure map with kebab-case keys.\n   Used for inbound WebSocket messages.\"\n  [s]\n  (let [parsed (js/JSON.parse s)\n        clj-map (js->clj parsed :keywordize-keys true)\n        kebab-map (transform-keys snake->kebab clj-map)]\n    kebab-map))\n\n(defn parse-json-safe\n  \"Parse JSON string safely, returning nil on error.\"\n  [s]\n  (try\n    (json->clj s)\n    (catch :default _\n      nil)))\n"]}