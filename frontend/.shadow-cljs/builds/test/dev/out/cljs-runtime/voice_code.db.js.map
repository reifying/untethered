{"version":3,"sources":["voice_code/db.cljs"],"mappings":";AAIA;;;2BAAA,wCAAA,4EAAA,6DAAA,2DAAA,yEAAA,4DAAA,4DAAA,iDAAA,8EAAA,6DAAA,+DAAA,mEAAA,kCAAA,2CAAA,iEAAA,YAAA,kEAAA,OAAA,8EAAA,KAAA,sFAAA,KAAA,kFAAA,cAAA,2CAAA,gEAAA,iCAAA,yDAAA,2CAAA,KAAA,2CAAA,gEAAA,mCAAA,2DAAA,mCAAA,2DAAA,yCAAA,mCAAA,2CAAA,6DAAA,MAAA,uEAAA,KAAA,yDAAA,2CAAA,KAAA,mCAAA,2CAAA,oDAAA,iCAAA,0EAAA,YAAA,2CAAA,0DAAA,sEAAA,0EAAA,MAAA,uDAAA,KAAA,kFAAA,pwFAAKA;AAmDL;;;sCAAA,tCAAMC,oFAEHC,GAAGC;AAFN,AAGE,OAACC,0BAAU,AAAA,0GAAkBF,IAAIC;;AAEnC;;;yCAAA,zCAAME,0FAEHH,GAAGC;AAFN,AAGE,yDAAA,mFAAA,+EAAA,pNAACG,+CAAOJ,kJAAcC;;AAExB;;;4BAAA,5BAAMI,gEAEHL,GAAGC;AAFN,AAGE,yDAAA,mFAAA,rIAACG,+CAAOJ,mJAAcC;;AAExB;;;+BAAA,/BAAMK,sEAEHN;AAFH,AAGE,IAAAO,qBAAc,AAAA,4GAAoBP;AAAlC,AAAA,oBAAAO;AAAA,AAAA,SAAAA,LAAWC;AAAX,AACE,OAACH,0BAAYL,GAAGQ;;AADlB","names":["voice-code.db/default-db","voice-code.db/session-locked?","db","session-id","cljs.core/contains?","voice-code.db/get-messages-for-session","cljs.core.get_in","voice-code.db/get-session","voice-code.db/active-session","temp__5823__auto__","id"],"sourcesContent":["(ns voice-code.db\n  \"re-frame app-db schema and initialization.\n   Mirrors iOS CoreData schema with idiomatic Clojure structures.\")\n\n(def default-db\n  \"Initial application state.\"\n  {:connection {:status :disconnected ; :disconnected | :connecting | :connected\n                :authenticated? false\n                :error nil\n                :reconnect-attempts 0}\n\n   ;; Sessions indexed by session-id\n   ;; Each session: {:id :backend-name :custom-name :working-directory\n   ;;                :last-modified :message-count :preview :queue-position\n   ;;                :priority :priority-order :is-user-deleted}\n   :sessions {}\n\n   ;; Messages indexed by session-id -> [message-vec]\n   ;; Each message: {:id :session-id :role :text :timestamp :status}\n   :messages {}\n\n   ;; Currently active session\n   :active-session-id nil\n\n   ;; iOS session UUID for backend registration\n   :ios-session-id nil\n\n   ;; Set of session IDs currently processing prompts\n   :locked-sessions #{}\n\n   ;; Command execution state\n   :commands {:available {} ; working-dir -> command tree\n              :running {} ; command-session-id -> command state\n              :history []} ; Recent command executions\n\n   ;; Resource/file upload state\n   :resources {:list [] ; Uploaded files\n               :pending-uploads 0}\n\n   ;; Recipe orchestration state\n   :recipes {:available [] ; Recipe definitions\n             :active {}} ; session-id -> active recipe\n\n   ;; Application settings\n   :settings {:server-url \"localhost\"\n              :server-port 3000\n              :voice-identifier nil\n              :recent-sessions-limit 10\n              :max-message-size-kb 200}\n\n   ;; UI state\n   :ui {:loading? false\n        :current-error nil\n        :drafts {}}}) ; session-id -> draft text\n\n(defn session-locked?\n  \"Check if a session is currently locked (processing a prompt).\"\n  [db session-id]\n  (contains? (:locked-sessions db) session-id))\n\n(defn get-messages-for-session\n  \"Get all messages for a session in chronological order.\"\n  [db session-id]\n  (get-in db [:messages session-id] []))\n\n(defn get-session\n  \"Get session by ID.\"\n  [db session-id]\n  (get-in db [:sessions session-id]))\n\n(defn active-session\n  \"Get the currently active session.\"\n  [db]\n  (when-let [id (:active-session-id db)]\n    (get-session db id)))\n"]}