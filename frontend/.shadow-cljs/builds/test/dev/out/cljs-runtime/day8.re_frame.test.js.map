{"version":3,"sources":["day8/re_frame/test.cljc"],"mappings":"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","names":["day8.re-frame.test/dequeue!","queue-atom","cljs.core/deref","queue","cljs.core/seq","cljs.core/compare-and-set!","cljs.core/pop","cljs.core/peek","day8.re-frame.test/*test-timeout*","day8.re-frame.test/*test-context*","day8.re-frame.test/run-test-async*","f","test-context","cljs.core.atom","day8.re-frame.test/t_day8$re_frame$test13402","done","restore-fn","re-frame.core/make-restore-fn","*test-context*-orig-val__13418","*test-context*-temp-val__13419","cljs.core.assoc","day8.re-frame.test/as-callback-pred","callback-pred","cljs.core/set?","cljs.core/vector?","event","cljs.core/some","pred","cljs.core.map","cljs.core/fn?","cljs.core/Keyword","p__13443","vec__13444","cljs.core.nth","event-id","_","cljs.core._EQ_","cljs.core.ex_info","cljs.core.pr_str","day8.re-frame.test/wait-for*","ok-ids","failure-ids","callback","map__13454","cljs.core/--destructure-map","cljs.core.get","cljs.core.update","cljs.core/inc","cljs.core.swap_BANG_","ok-pred","fail-pred","cb-id","cljs.core.gensym","re_frame.core.add_post_event_callback","and__5140__auto__","cljs.core/not","values__10011__auto__","cljs.core/List","result__10012__auto__","cljs.core.apply","cljs.test/report","cljs.core/cons","t__10048__auto__","e13459","re-frame.core/remove-post-event-callback","cljs.core/reset!","*test-context*-orig-val__13470","*test-context*-temp-val__13471","day8.re-frame.test/*handling*","day8.re-frame.test/run-test-sync*","restore-fn__13316__auto__","my-queue","re-frame.interop/empty-queue","new-dispatch","argv","cljs.core/conj","*handling*-orig-val__13485","*handling*-temp-val__13486","temp__5823__auto__","queue-head","re-frame.router/dispatch-sync","dispatch-orig-val__13492","dispatch-orig-val__13493","dispatch-temp-val__13494","dispatch-temp-val__13495","re-frame.core/dispatch","re-frame.router/dispatch"],"sourcesContent":["(ns day8.re-frame.test\n  #?(:cljs (:require-macros day8.re-frame.test))\n  (:require #?(:cljs [cljs.test :as test]\n               :clj  [clojure.test :as test])\n            [re-frame.core :as rf]\n            [re-frame.router :as rf.router]\n            [re-frame.db :as rf.db]\n            [re-frame.interop :as rf.int])\n  #?(:clj (:import [java.util.concurrent Executors TimeUnit])))\n\n\n;;;;\n;;;; General test utils\n;;;;\n\n(defn- dequeue!\n  \"Dequeue an item from a persistent queue which is stored as the value in\n  queue-atom. Returns the item, and updates the atom with the new queue\n  value. If the queue is empty, does not alter it and returns nil.\"\n  [queue-atom]\n  (let [queue @queue-atom]\n    (when (seq queue)\n      (if (compare-and-set! queue-atom queue (pop queue))\n        (peek queue)\n        (recur queue-atom)))))\n\n\n#?(:clj\n   (defmacro with-temp-re-frame-state\n     \"Run `body`, but discard whatever effects it may have on re-frame's internal\n      state (by resetting `app-db` and re-frame's various different types of\n      handlers after `body` has run).\n\n      Note: you *can't* use this macro to clean up a JS async test, since the macro\n      will perform the cleanup before your async code actually has a chance to run.\n      `run-test-async` will automatically do this cleanup for you.\"\n     [& body]\n     `(let [restore-fn# (rf/make-restore-fn)]\n        (try\n          ~@body\n          (finally\n            (restore-fn#))))))\n\n\n;;;;\n;;;; Async tests\n;;;;\n\n(def ^:dynamic *test-timeout* 5000)\n\n(def ^{:dynamic true, :private true} *test-context*\n  \"`*test-context*` is used to communicate internal details of the test between\n  `run-test-async*` and `wait-for*`. It is dynamically bound so that it doesn't\n  need to appear as a lexical argument to a `wait-for` block, since we don't\n  want it to be visible when you're writing tests.  But care must be taken to\n  pass it around lexically across callbacks, since ClojureScript doesn't have\n  `bound-fn`.\"\n  nil)\n\n\n(defn run-test-async* [f]\n  (let [test-context {:wait-for-depth     0\n                      :max-wait-for-depth (atom 0)\n                      :now-waiting-for    (atom nil)}]\n    #?(:clj  (with-temp-re-frame-state\n               (let [done-promise (promise)\n                     executor     (Executors/newSingleThreadExecutor)\n                     fail-ex      (atom nil)\n                     test-context (assoc test-context :done #(deliver done-promise ::done))]\n                 (with-redefs [rf.int/executor executor]\n                   ;; Execute the test code itself on the same thread as the\n                   ;; re-frame event handlers run, so that we accurately\n                   ;; simulate the single-threaded JS environment and also so\n                   ;; that we don't have to worry about making the JVM\n                   ;; implementation of the re-frame EventQueue thread-safe.\n                   (rf.int/next-tick #(try\n                                        (binding [*test-context* test-context]\n                                          (f))\n                                        (catch Throwable t\n                                          (reset! fail-ex t))))\n                   (let [result (deref done-promise *test-timeout* ::timeout)]\n                     (.shutdown executor)\n                     (when-not (.awaitTermination executor 5 TimeUnit/SECONDS)\n                       (throw (ex-info (str \"Couldn't cleanly shut down the re-frame event queue's \"\n                                            \"executor.  Possibly this could result in a polluted \"\n                                            \"`app-db` for other tests.  Probably it means you're \"\n                                            \"doing something very strange in an event handler.  \"\n                                            \"(Catching InterruptedException, for a start.)\")\n                                       {})))\n                     (if-let [ex @fail-ex]\n                       (throw ex)\n                       (test/is (not= ::timeout result)\n                                (str \"Test timed out after \" *test-timeout* \"ms\"\n                                     (when-let [ev @(:now-waiting-for test-context)]\n                                       (str \", waiting for \" (pr-str ev) \".\")))))))))\n\n       :cljs (test/async done\n               (let [restore-fn (rf/make-restore-fn)]\n                 (binding [*test-context* (assoc test-context :done (fn [] (restore-fn) (done)))]\n                   (f)))))))\n\n\n(defmacro run-test-async\n  \"Run `body` as an async re-frame test. The async nature means you'll need to\n  use `wait-for` any time you want to make any assertions that should be true\n  *after* an event has been handled.  It's assumed that there will be at least\n  one `wait-for` in the body of your test (otherwise you don't need this macro\n  at all).\n\n  Note: unlike regular ClojureScript `cljs.test/async` tests, `wait-for` takes\n  care of calling `(done)` for you: you don't need to do anything specific to\n  handle the fact that your test is asynchronous, other than make sure that all\n  your assertions happen with `wait-for` blocks.\n\n  This macro will automatically clean up any changes to re-frame state made\n  within the test body, as per `with-temp-re-frame-state` (except that the way\n  it's done here *does* work for async tests, whereas that macro used by itself\n  doesn't).\"\n  [& body]\n  `(run-test-async* (fn [] ~@body)))\n\n\n(defn- as-callback-pred\n  \"Interprets the acceptable input values for `wait-for`'s `ok-ids` and\n  `failure-ids` params to produce a predicate function on an event.  See\n  `wait-for` for details.\"\n  [callback-pred]\n  (when callback-pred\n    (cond (or (set? callback-pred)\n              (vector? callback-pred)) (fn [event]\n                                         (some (fn [pred] (pred event))\n                                               (map as-callback-pred (seq callback-pred))))\n          (fn? callback-pred)          callback-pred\n          (keyword? callback-pred)     (fn [[event-id _]]\n                                         (= callback-pred event-id))\n          :else                        (throw\n                                        (ex-info (str (pr-str callback-pred)\n                                                      \" isn't an event predicate\")\n                                                 {:callback-pred callback-pred})))))\n\n\n(defn wait-for*\n  \"This function is an implementation detail: in your async tests (within a\n  `run-test-async`), you should use the `wait-for` macro instead.  (For\n  synchronous tests within `run-test-sync`, you don't need this capability at\n  all.)\n\n  Installs `callback` as a re-frame post-event callback handler, called as soon\n  as any event matching `ok-ids` is handled.  Aborts the test as a failure if\n  any event matching `failure-ids` is handled.\n\n  Since this is intended for use in asynchronous tests: it will return\n  immediately after installing the callback -- it doesn't *actually* wait.\n\n  Note that `wait-for*` tracks whether, during your callback, you call\n  `wait-for*` again.  If you *don't*, then, given the way asynchronous tests\n  work, your test must necessarily be finished.  So `wait-for*` will\n  call `(done)` for you.\"\n  [ok-ids failure-ids callback]\n  ;; `:wait-for-depth` and `:max-wait-for-depth` are used together to track how\n  ;; \"deep\" we are in callback functions as the test progresses.  We increment\n  ;; `:max-wait-for-depth` before installing a post-event callback handler, then\n  ;; after the event later occurs and the callback handler subsequently runs, we\n  ;; check whether it has been incremented further (indicating another\n  ;; `wait-for*` callback handler has been installed).  If it *hasn't*, since\n  ;; `wait-for*` only makes sense in a tail position, this means the test is\n  ;; complete, and we can call `(done)`, saving the test author the trouble of\n  ;; passing `done` through every single callback.\n  (let [{:keys [done] :as test-context} (update *test-context* :wait-for-depth inc)]\n    (swap! (:max-wait-for-depth test-context) inc)\n\n    (let [ok-pred   (as-callback-pred ok-ids)\n          fail-pred (as-callback-pred failure-ids)\n          cb-id     (gensym \"wait-for-cb-fn\")]\n      (rf/add-post-event-callback cb-id (#?(:cljs fn :clj bound-fn) [event _]\n                                          (cond (and fail-pred\n                                                     (not (test/is (not (fail-pred event))\n                                                                   \"Received failure event\")))\n                                                (do\n                                                  (rf/remove-post-event-callback cb-id)\n                                                  (reset! (:now-waiting-for test-context) nil)\n                                                  (done))\n\n                                                (ok-pred event)\n                                                (do\n                                                  (rf/remove-post-event-callback cb-id)\n                                                  (reset! (:now-waiting-for test-context) nil)\n                                                  (binding [*test-context* test-context]\n                                                    (callback event))\n                                                  (when (= (:wait-for-depth test-context)\n                                                           @(:max-wait-for-depth test-context))\n                                                    ;; `callback` has completed with no `wait-for*`\n                                                    ;; calls, so we're not waiting for anything\n                                                    ;; further.  Given that `wait-for*` calls are\n                                                    ;; only valid in tail position, the test must\n                                                    ;; now be finished.\n                                                    (done)))\n\n                                                ;; Test is not interested this event, but we still\n                                                ;; need to wait for the one we *are* interested in.\n                                                :else\n                                                nil)))\n      (reset! (:now-waiting-for test-context) ok-ids))))\n\n\n(defmacro wait-for\n  \"Execute `body` once an event identified by the predicate(s) `ids` has been handled.\n\n  `ids` and `failure-ids` are means to identify an event. Normally, each would\n  be a simple keyword or a set of keywords.  If an event with event-id of (or\n  in) `ids` is handled, the test will continue by executing the body. If an\n  event with an event-id of (or in) `failure-ids` is handled, the test will\n  abort and fail.\n\n  IMPORTANT NOTE: due to the way async tests in re-frame work, code you want\n  executed after the event you're waiting for has to happen in the `body` of the\n  `wait-for` (in an implicit callback), not just lexically after the the\n  `wait-for` call. In practice, this means `wait-for` must always be in a tail\n  position.\n\n  Eg:\n      (run-test-async\n        (dispatch [:get-user 2])\n        (wait-for [#{:got-user} #{:no-such-user :system-unavailable} event]\n          (is (= (:username @(subscribe [:user])) \\\"johnny\\\")))\n        ;; Don't put code here, it will run *before* the event you're waiting\n        ;; for.\n        )\n\n  Acceptable inputs for `ids` and `failure-ids` are:\n    - `:some-event-id` => matches an event with that ID\n\n    - `#{:some-event-id :other-event-id}` => matches an event with any of the\n                                             given IDs\n\n    - `[:some-event-id :other-event-id]` => ditto (checks in order)\n\n    - `(fn [event] ,,,) => uses the function as a predicate\n\n    - `[(fn [event] ,,,) (fn [event] ,,,)]` => tries each predicate in turn,\n                                               matching an event which matches\n                                               at least one predicate\n\n    - `#{:some-event-id (fn [event] ,,,)}` => tries each\n\n  Note that because we're liberal about whether you supply `failure-ids` and/or\n  `event-sym`, if you do choose to supply only one, and you want that one to be\n  `event-sym`, you can't supply it as a destructuring form (because we can't\n  disambiguate that from a vector of `failure-ids`).  You can just supply `nil`\n  as `failure-ids` in this case, and then you'll be able to destructure.\"\n  [[ids failure-ids event-sym :as argv] & body]\n  (let [[failure-ids event-sym] (case (count argv)\n                                  3 [failure-ids event-sym]\n                                  2 (if (symbol? (second argv))\n                                      [nil (second argv)]\n                                      [(second argv) (gensym \"event\")])\n                                  1 [nil (gensym \"event\")]\n                                  0 (throw (ex-info \"wait-for needs to know what to wait for!\"\n                                                    {})))]\n   `(wait-for* ~ids ~failure-ids (fn [~event-sym] ~@body))))\n\n\n\n;;;;\n;;;; Sync tests\n;;;;\n\n(def ^{:dynamic true, :private true} *handling* false)\n\n(defn run-test-sync* [f]\n  (day8.re-frame.test/with-temp-re-frame-state\n    ;; Bypass the actual re-frame EventQueue and use a local alternative over\n    ;; which we have full control.\n    (let [my-queue     (atom rf.int/empty-queue)\n          new-dispatch (fn [argv]\n                         (swap! my-queue conj argv)\n                         (when-not *handling*\n                           (binding [*handling* true]\n                             (loop []\n                               (when-let [queue-head (dequeue! my-queue)]\n                                 (rf.router/dispatch-sync queue-head)\n                                 (recur))))))]\n      (with-redefs [rf/dispatch        new-dispatch\n                    rf.router/dispatch new-dispatch]\n        (f)))))\n\n\n(defmacro run-test-sync\n  \"Execute `body` as a test, where each `dispatch` call is executed\n  synchronously (via `dispatch-sync`), and any subsequent dispatches which are\n  caused by that dispatch are also fully handled/executed prior to control flow\n  returning to your test.\n\n  Think of it kind of as though every `dispatch` in your app had been magically\n  turned into `dispatch-sync`, and re-frame had lifted the restriction that says\n  you can't call `dispatch-sync` from within an event handler.\n\n  Note that this is *not* achieved with blocking.  It relies on you not doing\n  anything asynchronous (such as an actual AJAX call or `js/setTimeout`)\n  directly in your event handlers.  In a real app running in the real browser,\n  of course that won't apply, so this might seem useless at first.  But if\n  you're a well-behaved re-framer, all of your asynchronous stuff (which is by\n  definition side-effecty) will happen in effectful event handlers installed\n  with `reg-fx`.  Which works very nicely: in your tests, install an alternative\n  version of those effectful event handlers which behaves synchronously.  For\n  maximum coolness, you might want to consider running your tests on the JVM and\n  installing a `reg-fx` handler which actually invokes your JVM Clojure\n  server-side Ring handler where your in-browser code would make an AJAX call.\"\n  [& body]\n  `(run-test-sync* (fn [] ~@body)))\n"],"x_google_ignoreList":[0]}